//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    invObjAccountList(): Observable<GetAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/InvObjAccountList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvObjAccountList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvObjAccountList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountOutput>;
        }));
    }

    protected processInvObjAccountList(response: HttpResponseBase): Observable<GetAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountOutput>(null as any);
    }

    /**
     * @return Success
     */
    imoAssetAccountList(): Observable<GetAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ImoAssetAccountList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImoAssetAccountList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImoAssetAccountList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountOutput>;
        }));
    }

    protected processImoAssetAccountList(response: HttpResponseBase): Observable<GetAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountOutput>(null as any);
    }

    /**
     * @param prepaymentType (optional) 
     * @return Success
     */
    prepaymentsAccountList(prepaymentType: number | undefined): Observable<GetAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/PrepaymentsAccountList?";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepaymentsAccountList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepaymentsAccountList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountOutput>;
        }));
    }

    protected processPrepaymentsAccountList(response: HttpResponseBase): Observable<GetAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountOutput>(null as any);
    }

    /**
     * @param prefix (optional) 
     * @param accountType (optional) 
     * @return Success
     */
    invoiceElementAccountList(prefix: string | null | undefined, accountType: string | null | undefined): Observable<GetAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/InvoiceElementAccountList?";
        if (prefix !== undefined && prefix !== null)
            url_ += "Prefix=" + encodeURIComponent("" + prefix) + "&";
        if (accountType !== undefined && accountType !== null)
            url_ += "accountType=" + encodeURIComponent("" + accountType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceElementAccountList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceElementAccountList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountOutput>;
        }));
    }

    protected processInvoiceElementAccountList(response: HttpResponseBase): Observable<GetAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountOutput>(null as any);
    }

    /**
     * @param prefix (optional) 
     * @return Success
     */
    getAllSyntheticAccounts(prefix: string | null | undefined): Observable<GetAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/GetAllSyntheticAccounts?";
        if (prefix !== undefined && prefix !== null)
            url_ += "Prefix=" + encodeURIComponent("" + prefix) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSyntheticAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSyntheticAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountOutput>;
        }));
    }

    protected processGetAllSyntheticAccounts(response: HttpResponseBase): Observable<GetAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountOutput>(null as any);
    }

    /**
     * @return Success
     */
    accountListComputingAll(): Observable<AccountListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountListComputingAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountListComputingAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountListComputingAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListDDDto[]>;
        }));
    }

    protected processAccountListComputingAll(response: HttpResponseBase): Observable<AccountListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDDDto[]>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @return Success
     */
    getAccountbyId(accountId: number | undefined): Observable<AccountListDDDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/GetAccountbyId?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListDDDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListDDDto>;
        }));
    }

    protected processGetAccountbyId(response: HttpResponseBase): Observable<AccountListDDDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountListDDDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDDDto>(null as any);
    }

    /**
     * @param search (optional) 
     * @param currencyId (optional) 
     * @return Success
     */
    accountListComputing(search: string | null | undefined, currencyId: number | undefined): Observable<AccountListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountListComputing?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountListComputing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountListComputing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListDDDto[]>;
        }));
    }

    protected processAccountListComputing(response: HttpResponseBase): Observable<AccountListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDDDto[]>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    accountListAll(search: string | null | undefined): Observable<AccountListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountListAll?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountListAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountListAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListDDDto[]>;
        }));
    }

    protected processAccountListAll(response: HttpResponseBase): Observable<AccountListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDDDto[]>(null as any);
    }

    /**
     * @return Success
     */
    accountListInit(): Observable<AccountListFormDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountListInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountListInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountListInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListFormDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListFormDto>;
        }));
    }

    protected processAccountListInit(response: HttpResponseBase): Observable<AccountListFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountListFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListFormDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accountList(body: AccountListFormDto | undefined): Observable<AccountListFormDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListFormDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListFormDto>;
        }));
    }

    protected processAccountList(response: HttpResponseBase): Observable<AccountListFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountListFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListFormDto>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @return Success
     */
    accountEditInit(accountId: number | undefined): Observable<AccountEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountEditInit?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountEditInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountEditInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountEditDto>;
        }));
    }

    protected processAccountEditInit(response: HttpResponseBase): Observable<AccountEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAccount(body: AccountEditDto | undefined): Observable<AccountEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/SaveAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountEditDto>;
        }));
    }

    protected processSaveAccount(response: HttpResponseBase): Observable<AccountEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAccountOld(body: AccountEditDto | undefined): Observable<AccountEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/SaveAccountOld";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAccountOld(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAccountOld(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountEditDto>;
        }));
    }

    protected processSaveAccountOld(response: HttpResponseBase): Observable<AccountEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountEditDto>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @return Success
     */
    deleteAccount(accountId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/DeleteAccount?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param accountSearch (optional) 
     * @param accountId (optional) 
     * @return Success
     */
    accountDeductibilityInit(accountSearch: string | null | undefined, accountId: number | undefined): Observable<AccountDeductibilityForm> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountDeductibilityInit?";
        if (accountSearch !== undefined && accountSearch !== null)
            url_ += "accountSearch=" + encodeURIComponent("" + accountSearch) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDeductibilityInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDeductibilityInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDeductibilityForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDeductibilityForm>;
        }));
    }

    protected processAccountDeductibilityInit(response: HttpResponseBase): Observable<AccountDeductibilityForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountDeductibilityForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDeductibilityForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accountDeductibilityList(body: AccountDeductibilityForm | undefined): Observable<AccountDeductibilityForm> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountDeductibilityList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDeductibilityList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDeductibilityList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDeductibilityForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDeductibilityForm>;
        }));
    }

    protected processAccountDeductibilityList(response: HttpResponseBase): Observable<AccountDeductibilityForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountDeductibilityForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDeductibilityForm>(null as any);
    }

    /**
     * @param propertyId (optional) 
     * @param body (optional) 
     * @return Success
     */
    accountDeductibilityEditInit(propertyId: number | undefined, body: AccountDeductibilityForm | undefined): Observable<AccountDeductibilityForm> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountDeductibilityEditInit?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDeductibilityEditInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDeductibilityEditInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDeductibilityForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDeductibilityForm>;
        }));
    }

    protected processAccountDeductibilityEditInit(response: HttpResponseBase): Observable<AccountDeductibilityForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountDeductibilityForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDeductibilityForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accountDeductibilityEditSave(body: AccountDeductibilityForm | undefined): Observable<AccountDeductibilityForm> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountDeductibilityEditSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDeductibilityEditSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDeductibilityEditSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDeductibilityForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDeductibilityForm>;
        }));
    }

    protected processAccountDeductibilityEditSave(response: HttpResponseBase): Observable<AccountDeductibilityForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountDeductibilityForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDeductibilityForm>(null as any);
    }

    /**
     * @param propertyId (optional) 
     * @param body (optional) 
     * @return Success
     */
    accountDeductibilityDelete(propertyId: number | undefined, body: AccountDeductibilityForm | undefined): Observable<AccountDeductibilityForm> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountDeductibilityDelete?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDeductibilityDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDeductibilityDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDeductibilityForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDeductibilityForm>;
        }));
    }

    protected processAccountDeductibilityDelete(response: HttpResponseBase): Observable<AccountDeductibilityForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountDeductibilityForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDeductibilityForm>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    accountListNeded(search: string | null | undefined): Observable<AccountListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountListNeded?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountListNeded(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountListNeded(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListDDDto[]>;
        }));
    }

    protected processAccountListNeded(response: HttpResponseBase): Observable<AccountListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDDDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAnalythicsForRegistruInventar(): Observable<AccountListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Account/GetAnalythicsForRegistruInventar";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnalythicsForRegistruInventar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnalythicsForRegistruInventar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListDDDto[]>;
        }));
    }

    protected processGetAnalythicsForRegistruInventar(response: HttpResponseBase): Observable<AccountListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDDDto[]>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    getAccountsList(search: string | null | undefined): Observable<AccountListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Account/GetAccountsList?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListDDDto[]>;
        }));
    }

    protected processGetAccountsList(response: HttpResponseBase): Observable<AccountListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDDDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAccountsRegInvExceptEliminare(): Observable<AccountListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Account/GetAccountsRegInvExceptEliminare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountsRegInvExceptEliminare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsRegInvExceptEliminare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListDDDto[]>;
        }));
    }

    protected processGetAccountsRegInvExceptEliminare(response: HttpResponseBase): Observable<AccountListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDDDto[]>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    getAccountsExceptEliminareList(search: string | null | undefined): Observable<AccountListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Account/GetAccountsExceptEliminareList?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountsExceptEliminareList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsExceptEliminareList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListDDDto[]>;
        }));
    }

    protected processGetAccountsExceptEliminareList(response: HttpResponseBase): Observable<AccountListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDDDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAccountNivelRandMax(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/GetAccountNivelRandMax";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountNivelRandMax(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountNivelRandMax(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetAccountNivelRandMax(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @return Success
     */
    accountHistoryList(accountId: number | undefined): Observable<AccountHistoryListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Account/AccountHistoryList?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountHistoryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountHistoryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountHistoryListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountHistoryListDto[]>;
        }));
    }

    protected processAccountHistoryList(response: HttpResponseBase): Observable<AccountHistoryListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountHistoryListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountHistoryListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(null as any);
    }
}

@Injectable()
export class AccountConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    accountConfigList(): Observable<AccountConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AccountConfig/AccountConfigList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountConfigList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountConfigList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountConfigDto[]>;
        }));
    }

    protected processAccountConfigList(response: HttpResponseBase): Observable<AccountConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountConfigDto[]>(null as any);
    }

    /**
     * @param searchDate (optional) 
     * @return Success
     */
    accountConfigListByDate(searchDate: moment.Moment | undefined): Observable<AccountConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AccountConfig/AccountConfigListByDate?";
        if (searchDate === null)
            throw new Error("The parameter 'searchDate' cannot be null.");
        else if (searchDate !== undefined)
            url_ += "searchDate=" + encodeURIComponent(searchDate ? "" + searchDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountConfigListByDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountConfigListByDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountConfigDto[]>;
        }));
    }

    protected processAccountConfigListByDate(response: HttpResponseBase): Observable<AccountConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountConfigDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAccountConfigById(id: number | undefined): Observable<AccountConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountConfig/GetAccountConfigById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountConfigById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountConfigById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountConfigDto>;
        }));
    }

    protected processGetAccountConfigById(response: HttpResponseBase): Observable<AccountConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountConfigDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAccountConfig(body: AccountConfigDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountConfig/SaveAccountConfig";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAccountConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAccountConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAccountConfig(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAccountConfig(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountConfig/DeleteAccountConfig?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAccountConfig(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AccountDivConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    accountDivConfigList(): Observable<AccountDivConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AccountDivConfig/AccountDivConfigList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDivConfigList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDivConfigList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDivConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDivConfigDto[]>;
        }));
    }

    protected processAccountDivConfigList(response: HttpResponseBase): Observable<AccountDivConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountDivConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDivConfigDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDivAccountById(id: number | undefined): Observable<AccountDivConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountDivConfig/GetDivAccountById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDivAccountById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDivAccountById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDivConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDivConfigDto>;
        }));
    }

    protected processGetDivAccountById(response: HttpResponseBase): Observable<AccountDivConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountDivConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDivConfigDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDivAccount(body: AccountDivConfigDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountDivConfig/SaveDivAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDivAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDivAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDivAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDivAccount(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountDivConfig/DeleteDivAccount?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDivAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDivAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDivAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AccountRelationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    accountRelationList(): Observable<AccountRelationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AccountRelation/AccountRelationList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountRelationList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountRelationList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountRelationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountRelationDto[]>;
        }));
    }

    protected processAccountRelationList(response: HttpResponseBase): Observable<AccountRelationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountRelationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountRelationDto[]>(null as any);
    }

    /**
     * @param relationId (optional) 
     * @return Success
     */
    accountRelationEditInit(relationId: number | undefined): Observable<AccountRelationDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountRelation/AccountRelationEditInit?";
        if (relationId === null)
            throw new Error("The parameter 'relationId' cannot be null.");
        else if (relationId !== undefined)
            url_ += "relationId=" + encodeURIComponent("" + relationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountRelationEditInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountRelationEditInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountRelationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountRelationDto>;
        }));
    }

    protected processAccountRelationEditInit(response: HttpResponseBase): Observable<AccountRelationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountRelationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountRelationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAccountRelation(body: AccountRelationDto | undefined): Observable<AccountRelationDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountRelation/SaveAccountRelation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAccountRelation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAccountRelation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountRelationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountRelationDto>;
        }));
    }

    protected processSaveAccountRelation(response: HttpResponseBase): Observable<AccountRelationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountRelationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountRelationDto>(null as any);
    }

    /**
     * @param accountRelationId (optional) 
     * @return Success
     */
    deleteAccountRelation(accountRelationId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountRelation/DeleteAccountRelation?";
        if (accountRelationId === null)
            throw new Error("The parameter 'accountRelationId' cannot be null.");
        else if (accountRelationId !== undefined)
            url_ += "accountRelationId=" + encodeURIComponent("" + accountRelationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountRelation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountRelation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAccountRelation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ActivityTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param activityTypeId (optional) 
     * @return Success
     */
    activityTypeEditInit(activityTypeId: number | undefined): Observable<ActivityTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityType/ActivityTypeEditInit?";
        if (activityTypeId === null)
            throw new Error("The parameter 'activityTypeId' cannot be null.");
        else if (activityTypeId !== undefined)
            url_ += "activityTypeId=" + encodeURIComponent("" + activityTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivityTypeEditInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivityTypeEditInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityTypeDto>;
        }));
    }

    protected processActivityTypeEditInit(response: HttpResponseBase): Observable<ActivityTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityTypeDto>(null as any);
    }

    /**
     * @return Success
     */
    activityTypeList(): Observable<ActivityTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ActivityType/ActivityTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivityTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivityTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityTypeDto[]>;
        }));
    }

    protected processActivityTypeList(response: HttpResponseBase): Observable<ActivityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ActivityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityTypeDto[]>(null as any);
    }

    /**
     * @param activityTypeId (optional) 
     * @return Success
     */
    deleteActivityType(activityTypeId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityType/DeleteActivityType?";
        if (activityTypeId === null)
            throw new Error("The parameter 'activityTypeId' cannot be null.");
        else if (activityTypeId !== undefined)
            url_ += "activityTypeId=" + encodeURIComponent("" + activityTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteActivityType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteActivityType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteActivityType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveActivityType(body: ActivityTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityType/SaveActivityType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveActivityType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveActivityType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveActivityType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AutomatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tokenId (optional) 
     * @return Success
     */
    getToken(tokenId: string | null | undefined): Observable<Tokens> {
        let url_ = this.baseUrl + "/api/services/app/Automat/GetToken?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Tokens>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Tokens>;
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<Tokens> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Tokens.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tokens>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @return Success
     */
    validateToken(tokenId: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Automat/ValidateToken?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processValidateToken(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param partialSymbol (optional) 
     * @param externalCode (optional) 
     * @param accountFuncType (optional) 
     * @param exactAccount (optional) 
     * @return Success
     */
    findAccount(tokenId: string | null | undefined, partialSymbol: string | null | undefined, externalCode: string | null | undefined, accountFuncType: string | null | undefined, exactAccount: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Automat/FindAccount?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (partialSymbol !== undefined && partialSymbol !== null)
            url_ += "partialSymbol=" + encodeURIComponent("" + partialSymbol) + "&";
        if (externalCode !== undefined && externalCode !== null)
            url_ += "externalCode=" + encodeURIComponent("" + externalCode) + "&";
        if (accountFuncType !== undefined && accountFuncType !== null)
            url_ += "accountFuncType=" + encodeURIComponent("" + accountFuncType) + "&";
        if (exactAccount === null)
            throw new Error("The parameter 'exactAccount' cannot be null.");
        else if (exactAccount !== undefined)
            url_ += "exactAccount=" + encodeURIComponent("" + exactAccount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processFindAccount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param partialSymbol (optional) 
     * @param externalCode (optional) 
     * @param accountFuncType (optional) 
     * @param exactAccount (optional) 
     * @return Success
     */
    getAccount(tokenId: string | null | undefined, partialSymbol: string | null | undefined, externalCode: string | null | undefined, accountFuncType: string | null | undefined, exactAccount: number | undefined): Observable<GetAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Automat/GetAccount?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (partialSymbol !== undefined && partialSymbol !== null)
            url_ += "partialSymbol=" + encodeURIComponent("" + partialSymbol) + "&";
        if (externalCode !== undefined && externalCode !== null)
            url_ += "externalCode=" + encodeURIComponent("" + externalCode) + "&";
        if (accountFuncType !== undefined && accountFuncType !== null)
            url_ += "accountFuncType=" + encodeURIComponent("" + accountFuncType) + "&";
        if (exactAccount === null)
            throw new Error("The parameter 'exactAccount' cannot be null.");
        else if (exactAccount !== undefined)
            url_ += "exactAccount=" + encodeURIComponent("" + exactAccount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountDto[]>;
        }));
    }

    protected processGetAccount(response: HttpResponseBase): Observable<GetAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GetAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountDto[]>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param partialSymbol (optional) 
     * @param accountName (optional) 
     * @param externalCode (optional) 
     * @param accountFuncType (optional) 
     * @param nrOfFigures (optional) 
     * @return Success
     */
    getNewAccount(tokenId: string | null | undefined, partialSymbol: string | null | undefined, accountName: string | null | undefined, externalCode: string | null | undefined, accountFuncType: number | undefined, nrOfFigures: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/GetNewAccount?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (partialSymbol !== undefined && partialSymbol !== null)
            url_ += "partialSymbol=" + encodeURIComponent("" + partialSymbol) + "&";
        if (accountName !== undefined && accountName !== null)
            url_ += "accountName=" + encodeURIComponent("" + accountName) + "&";
        if (externalCode !== undefined && externalCode !== null)
            url_ += "externalCode=" + encodeURIComponent("" + externalCode) + "&";
        if (accountFuncType === null)
            throw new Error("The parameter 'accountFuncType' cannot be null.");
        else if (accountFuncType !== undefined)
            url_ += "accountFuncType=" + encodeURIComponent("" + accountFuncType) + "&";
        if (nrOfFigures === null)
            throw new Error("The parameter 'nrOfFigures' cannot be null.");
        else if (nrOfFigures !== undefined)
            url_ += "nrOfFigures=" + encodeURIComponent("" + nrOfFigures) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetNewAccount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param symbol (optional) 
     * @param synthetic (optional) 
     * @param accountName (optional) 
     * @param externalCode (optional) 
     * @param thirdPartyCif (optional) 
     * @param currency (optional) 
     * @param accountFuncType (optional) 
     * @return Success
     */
    saveNewAccount(tokenId: string | null | undefined, symbol: string | null | undefined, synthetic: string | null | undefined, accountName: string | null | undefined, externalCode: string | null | undefined, thirdPartyCif: string | null | undefined, currency: string | null | undefined, accountFuncType: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/SaveNewAccount?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (symbol !== undefined && symbol !== null)
            url_ += "symbol=" + encodeURIComponent("" + symbol) + "&";
        if (synthetic !== undefined && synthetic !== null)
            url_ += "synthetic=" + encodeURIComponent("" + synthetic) + "&";
        if (accountName !== undefined && accountName !== null)
            url_ += "accountName=" + encodeURIComponent("" + accountName) + "&";
        if (externalCode !== undefined && externalCode !== null)
            url_ += "externalCode=" + encodeURIComponent("" + externalCode) + "&";
        if (thirdPartyCif !== undefined && thirdPartyCif !== null)
            url_ += "thirdPartyCif=" + encodeURIComponent("" + thirdPartyCif) + "&";
        if (currency !== undefined && currency !== null)
            url_ += "currency=" + encodeURIComponent("" + currency) + "&";
        if (accountFuncType === null)
            throw new Error("The parameter 'accountFuncType' cannot be null.");
        else if (accountFuncType !== undefined)
            url_ += "accountFuncType=" + encodeURIComponent("" + accountFuncType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveNewAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveNewAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSaveNewAccount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param operationDate (optional) 
     * @return Success
     */
    verifyClosedMonth(tokenId: string | null | undefined, operationDate: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/VerifyClosedMonth?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (operationDate !== undefined && operationDate !== null)
            url_ += "operationDate=" + encodeURIComponent("" + operationDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyClosedMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyClosedMonth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processVerifyClosedMonth(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param operationDate (optional) 
     * @param documentNr (optional) 
     * @param documentDate (optional) 
     * @param closingMonth (optional) 
     * @param operationStatus (optional) 
     * @param currency (optional) 
     * @param documentType (optional) 
     * @return Success
     */
    addOperation(tokenId: string | null | undefined, operationDate: string | null | undefined, documentNr: string | null | undefined, documentDate: string | null | undefined, closingMonth: number | undefined, operationStatus: number | undefined, currency: string | null | undefined, documentType: string | null | undefined): Observable<ResultMessageIdDto> {
        let url_ = this.baseUrl + "/api/services/app/Automat/AddOperation?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (operationDate !== undefined && operationDate !== null)
            url_ += "operationDate=" + encodeURIComponent("" + operationDate) + "&";
        if (documentNr !== undefined && documentNr !== null)
            url_ += "documentNr=" + encodeURIComponent("" + documentNr) + "&";
        if (documentDate !== undefined && documentDate !== null)
            url_ += "documentDate=" + encodeURIComponent("" + documentDate) + "&";
        if (closingMonth === null)
            throw new Error("The parameter 'closingMonth' cannot be null.");
        else if (closingMonth !== undefined)
            url_ += "closingMonth=" + encodeURIComponent("" + closingMonth) + "&";
        if (operationStatus === null)
            throw new Error("The parameter 'operationStatus' cannot be null.");
        else if (operationStatus !== undefined)
            url_ += "operationStatus=" + encodeURIComponent("" + operationStatus) + "&";
        if (currency !== undefined && currency !== null)
            url_ += "currency=" + encodeURIComponent("" + currency) + "&";
        if (documentType !== undefined && documentType !== null)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultMessageIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultMessageIdDto>;
        }));
    }

    protected processAddOperation(response: HttpResponseBase): Observable<ResultMessageIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultMessageIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultMessageIdDto>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param operationId (optional) 
     * @param debitSymbol (optional) 
     * @param creditSymbol (optional) 
     * @param value (optional) 
     * @param valueCurrency (optional) 
     * @param details (optional) 
     * @return Success
     */
    addOperationDetail(tokenId: string | null | undefined, operationId: number | undefined, debitSymbol: string | null | undefined, creditSymbol: string | null | undefined, value: number | undefined, valueCurrency: number | undefined, details: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/AddOperationDetail?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (operationId === null)
            throw new Error("The parameter 'operationId' cannot be null.");
        else if (operationId !== undefined)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        if (debitSymbol !== undefined && debitSymbol !== null)
            url_ += "debitSymbol=" + encodeURIComponent("" + debitSymbol) + "&";
        if (creditSymbol !== undefined && creditSymbol !== null)
            url_ += "creditSymbol=" + encodeURIComponent("" + creditSymbol) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        if (valueCurrency === null)
            throw new Error("The parameter 'valueCurrency' cannot be null.");
        else if (valueCurrency !== undefined)
            url_ += "valueCurrency=" + encodeURIComponent("" + valueCurrency) + "&";
        if (details !== undefined && details !== null)
            url_ += "details=" + encodeURIComponent("" + details) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOperationDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOperationDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAddOperationDetail(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param idOperation (optional) 
     * @return Success
     */
    deleteOperation(tokenId: string | null | undefined, idOperation: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/DeleteOperation?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (idOperation === null)
            throw new Error("The parameter 'idOperation' cannot be null.");
        else if (idOperation !== undefined)
            url_ += "idOperation=" + encodeURIComponent("" + idOperation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDeleteOperation(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param synthetic (optional) 
     * @param includeSynthetic (optional) 
     * @return Success
     */
    getAccounts(tokenId: string | null | undefined, synthetic: string | null | undefined, includeSynthetic: string | null | undefined): Observable<GetAccountListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Automat/GetAccounts?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (synthetic !== undefined && synthetic !== null)
            url_ += "synthetic=" + encodeURIComponent("" + synthetic) + "&";
        if (includeSynthetic !== undefined && includeSynthetic !== null)
            url_ += "includeSynthetic=" + encodeURIComponent("" + includeSynthetic) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountListDto[]>;
        }));
    }

    protected processGetAccounts(response: HttpResponseBase): Observable<GetAccountListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GetAccountListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountListDto[]>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param account (optional) 
     * @param date (optional) 
     * @param sold (optional) 
     * @return Success
     */
    getSoldAccount(tokenId: string | null | undefined, account: string | null | undefined, date: moment.Moment | undefined, sold: Decimal | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/GetSoldAccount?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (account !== undefined && account !== null)
            url_ += "account=" + encodeURIComponent("" + account) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (sold === null)
            throw new Error("The parameter 'sold' cannot be null.");
        else if (sold !== undefined)
            url_ += "sold=" + encodeURIComponent("" + sold) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoldAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoldAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSoldAccount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param currencyCode (optional) 
     * @param exchangeDate (optional) 
     * @param value (optional) 
     * @return Success
     */
    exchangeRatesAddModify(currencyCode: string | null | undefined, exchangeDate: moment.Moment | undefined, value: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/ExchangeRatesAddModify?";
        if (currencyCode !== undefined && currencyCode !== null)
            url_ += "currencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        if (exchangeDate === null)
            throw new Error("The parameter 'exchangeDate' cannot be null.");
        else if (exchangeDate !== undefined)
            url_ += "exchangeDate=" + encodeURIComponent(exchangeDate ? "" + exchangeDate.toISOString() : "") + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeRatesAddModify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeRatesAddModify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processExchangeRatesAddModify(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param personType (optional) 
     * @param id1 (optional) 
     * @param id2 (optional) 
     * @param name (optional) 
     * @param lastName (optional) 
     * @param address (optional) 
     * @param countryCode (optional) 
     * @param regionCode (optional) 
     * @param locality (optional) 
     * @return Success
     */
    addModifyThirdParty(tokenId: string | null | undefined, personType: string | null | undefined, id1: string | null | undefined, id2: string | null | undefined, name: string | null | undefined, lastName: string | null | undefined, address: string | null | undefined, countryCode: string | null | undefined, regionCode: string | null | undefined, locality: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/AddModifyThirdParty?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (personType !== undefined && personType !== null)
            url_ += "personType=" + encodeURIComponent("" + personType) + "&";
        if (id1 !== undefined && id1 !== null)
            url_ += "id1=" + encodeURIComponent("" + id1) + "&";
        if (id2 !== undefined && id2 !== null)
            url_ += "id2=" + encodeURIComponent("" + id2) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "lastName=" + encodeURIComponent("" + lastName) + "&";
        if (address !== undefined && address !== null)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (regionCode !== undefined && regionCode !== null)
            url_ += "regionCode=" + encodeURIComponent("" + regionCode) + "&";
        if (locality !== undefined && locality !== null)
            url_ += "locality=" + encodeURIComponent("" + locality) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddModifyThirdParty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddModifyThirdParty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAddModifyThirdParty(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param personType (optional) 
     * @param id1 (optional) 
     * @param id2 (optional) 
     * @param name (optional) 
     * @param lastName (optional) 
     * @param address (optional) 
     * @param countryCode (optional) 
     * @param regionCode (optional) 
     * @param locality (optional) 
     * @param bic (optional) 
     * @param radIban (optional) 
     * @return Success
     */
    addModifyBank(tokenId: string | null | undefined, personType: string | null | undefined, id1: string | null | undefined, id2: string | null | undefined, name: string | null | undefined, lastName: string | null | undefined, address: string | null | undefined, countryCode: string | null | undefined, regionCode: string | null | undefined, locality: string | null | undefined, bic: string | null | undefined, radIban: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/AddModifyBank?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (personType !== undefined && personType !== null)
            url_ += "personType=" + encodeURIComponent("" + personType) + "&";
        if (id1 !== undefined && id1 !== null)
            url_ += "id1=" + encodeURIComponent("" + id1) + "&";
        if (id2 !== undefined && id2 !== null)
            url_ += "id2=" + encodeURIComponent("" + id2) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "lastName=" + encodeURIComponent("" + lastName) + "&";
        if (address !== undefined && address !== null)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (regionCode !== undefined && regionCode !== null)
            url_ += "regionCode=" + encodeURIComponent("" + regionCode) + "&";
        if (locality !== undefined && locality !== null)
            url_ += "locality=" + encodeURIComponent("" + locality) + "&";
        if (bic !== undefined && bic !== null)
            url_ += "bic=" + encodeURIComponent("" + bic) + "&";
        if (radIban !== undefined && radIban !== null)
            url_ += "radIban=" + encodeURIComponent("" + radIban) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddModifyBank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddModifyBank(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAddModifyBank(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param tokenId (optional) 
     * @param thirdParty (optional) 
     * @param bank (optional) 
     * @param currency (optional) 
     * @param iban (optional) 
     * @return Success
     */
    addModifyBankAccount(tokenId: string | null | undefined, thirdParty: string | null | undefined, bank: string | null | undefined, currency: string | null | undefined, iban: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/AddModifyBankAccount?";
        if (tokenId !== undefined && tokenId !== null)
            url_ += "tokenId=" + encodeURIComponent("" + tokenId) + "&";
        if (thirdParty !== undefined && thirdParty !== null)
            url_ += "thirdParty=" + encodeURIComponent("" + thirdParty) + "&";
        if (bank !== undefined && bank !== null)
            url_ += "bank=" + encodeURIComponent("" + bank) + "&";
        if (currency !== undefined && currency !== null)
            url_ += "currency=" + encodeURIComponent("" + currency) + "&";
        if (iban !== undefined && iban !== null)
            url_ += "iban=" + encodeURIComponent("" + iban) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddModifyBankAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddModifyBankAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAddModifyBankAccount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param currency (optional) 
     * @param exchangeDate (optional) 
     * @param tipRet (optional) 
     * @return Success
     */
    getExchangeRate(currency: string | null | undefined, exchangeDate: string | null | undefined, tipRet: string | null | undefined): Observable<ResultMessageValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Automat/GetExchangeRate?";
        if (currency !== undefined && currency !== null)
            url_ += "currency=" + encodeURIComponent("" + currency) + "&";
        if (exchangeDate !== undefined && exchangeDate !== null)
            url_ += "exchangeDate=" + encodeURIComponent("" + exchangeDate) + "&";
        if (tipRet !== undefined && tipRet !== null)
            url_ += "tipRet=" + encodeURIComponent("" + tipRet) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExchangeRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExchangeRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultMessageValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultMessageValueDto>;
        }));
    }

    protected processGetExchangeRate(response: HttpResponseBase): Observable<ResultMessageValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultMessageValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultMessageValueDto>(null as any);
    }

    /**
     * @param currency (optional) 
     * @param exchangeDate (optional) 
     * @param tipRet (optional) 
     * @param exchangeRate (optional) 
     * @return Success
     */
    getExchangeRateCtl(currency: string | null | undefined, exchangeDate: string | null | undefined, tipRet: string | null | undefined, exchangeRate: Decimal | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/GetExchangeRateCtl?";
        if (currency !== undefined && currency !== null)
            url_ += "currency=" + encodeURIComponent("" + currency) + "&";
        if (exchangeDate !== undefined && exchangeDate !== null)
            url_ += "exchangeDate=" + encodeURIComponent("" + exchangeDate) + "&";
        if (tipRet !== undefined && tipRet !== null)
            url_ += "tipRet=" + encodeURIComponent("" + tipRet) + "&";
        if (exchangeRate === null)
            throw new Error("The parameter 'exchangeRate' cannot be null.");
        else if (exchangeRate !== undefined)
            url_ += "exchangeRate=" + encodeURIComponent("" + exchangeRate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExchangeRateCtl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExchangeRateCtl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetExchangeRateCtl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param operationDate (optional) 
     * @param documentNr (optional) 
     * @param documentDate (optional) 
     * @param currency (optional) 
     * @param activityType (optional) 
     * @param operType (optional) 
     * @param operationType (optional) 
     * @return Success
     */
    contaOperationSaveCtl(operationDate: string | null | undefined, documentNr: string | null | undefined, documentDate: string | null | undefined, currency: string | null | undefined, activityType: string | null | undefined, operType: number | undefined, operationType: number | undefined): Observable<ResultMessageIdDto> {
        let url_ = this.baseUrl + "/api/services/app/Automat/ContaOperationSaveCtl?";
        if (operationDate !== undefined && operationDate !== null)
            url_ += "operationDate=" + encodeURIComponent("" + operationDate) + "&";
        if (documentNr !== undefined && documentNr !== null)
            url_ += "documentNr=" + encodeURIComponent("" + documentNr) + "&";
        if (documentDate !== undefined && documentDate !== null)
            url_ += "documentDate=" + encodeURIComponent("" + documentDate) + "&";
        if (currency !== undefined && currency !== null)
            url_ += "currency=" + encodeURIComponent("" + currency) + "&";
        if (activityType !== undefined && activityType !== null)
            url_ += "activityType=" + encodeURIComponent("" + activityType) + "&";
        if (operType === null)
            throw new Error("The parameter 'operType' cannot be null.");
        else if (operType !== undefined)
            url_ += "operType=" + encodeURIComponent("" + operType) + "&";
        if (operationType === null)
            throw new Error("The parameter 'operationType' cannot be null.");
        else if (operationType !== undefined)
            url_ += "operationType=" + encodeURIComponent("" + operationType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContaOperationSaveCtl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContaOperationSaveCtl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultMessageIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultMessageIdDto>;
        }));
    }

    protected processContaOperationSaveCtl(response: HttpResponseBase): Observable<ResultMessageIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultMessageIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultMessageIdDto>(null as any);
    }

    /**
     * @param idOperation (optional) 
     * @param activityType (optional) 
     * @param operType (optional) 
     * @param operationType (optional) 
     * @param valueType (optional) 
     * @param value (optional) 
     * @param bankAccount (optional) 
     * @param explicatii (optional) 
     * @return Success
     */
    contaOperationDetailSaveCtl(idOperation: number | undefined, activityType: string | null | undefined, operType: number | undefined, operationType: number | undefined, valueType: number | undefined, value: number | undefined, bankAccount: string | null | undefined, explicatii: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/ContaOperationDetailSaveCtl?";
        if (idOperation === null)
            throw new Error("The parameter 'idOperation' cannot be null.");
        else if (idOperation !== undefined)
            url_ += "idOperation=" + encodeURIComponent("" + idOperation) + "&";
        if (activityType !== undefined && activityType !== null)
            url_ += "activityType=" + encodeURIComponent("" + activityType) + "&";
        if (operType === null)
            throw new Error("The parameter 'operType' cannot be null.");
        else if (operType !== undefined)
            url_ += "operType=" + encodeURIComponent("" + operType) + "&";
        if (operationType === null)
            throw new Error("The parameter 'operationType' cannot be null.");
        else if (operationType !== undefined)
            url_ += "operationType=" + encodeURIComponent("" + operationType) + "&";
        if (valueType === null)
            throw new Error("The parameter 'valueType' cannot be null.");
        else if (valueType !== undefined)
            url_ += "valueType=" + encodeURIComponent("" + valueType) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        if (bankAccount !== undefined && bankAccount !== null)
            url_ += "bankAccount=" + encodeURIComponent("" + bankAccount) + "&";
        if (explicatii !== undefined && explicatii !== null)
            url_ += "explicatii=" + encodeURIComponent("" + explicatii) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContaOperationDetailSaveCtl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContaOperationDetailSaveCtl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processContaOperationDetailSaveCtl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param idOperation (optional) 
     * @return Success
     */
    contaOperationDelete(idOperation: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/ContaOperationDelete?";
        if (idOperation === null)
            throw new Error("The parameter 'idOperation' cannot be null.");
        else if (idOperation !== undefined)
            url_ += "idOperation=" + encodeURIComponent("" + idOperation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContaOperationDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContaOperationDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processContaOperationDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param idOperation (optional) 
     * @return Success
     */
    contaOperationEndSave(idOperation: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/ContaOperationEndSave?";
        if (idOperation === null)
            throw new Error("The parameter 'idOperation' cannot be null.");
        else if (idOperation !== undefined)
            url_ += "idOperation=" + encodeURIComponent("" + idOperation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContaOperationEndSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContaOperationEndSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processContaOperationEndSave(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    contaOperationSaveDirect(body: OperationAutoDirectDto | undefined): Observable<ResultMessageIdDto> {
        let url_ = this.baseUrl + "/api/services/app/Automat/ContaOperationSaveDirect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContaOperationSaveDirect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContaOperationSaveDirect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultMessageIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultMessageIdDto>;
        }));
    }

    protected processContaOperationSaveDirect(response: HttpResponseBase): Observable<ResultMessageIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultMessageIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultMessageIdDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    contaOperationSave(body: OperationAutoDto | undefined): Observable<ResultMessageIdDto> {
        let url_ = this.baseUrl + "/api/services/app/Automat/ContaOperationSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContaOperationSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContaOperationSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultMessageIdDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultMessageIdDto>;
        }));
    }

    protected processContaOperationSave(response: HttpResponseBase): Observable<ResultMessageIdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultMessageIdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultMessageIdDto>(null as any);
    }

    /**
     * @return Success
     */
    lastBalanceDay(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/LastBalanceDay";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLastBalanceDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLastBalanceDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processLastBalanceDay(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    myBankAccounts(): Observable<ResultMessageStringDto> {
        let url_ = this.baseUrl + "/api/services/app/Automat/MyBankAccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMyBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMyBankAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultMessageStringDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultMessageStringDto>;
        }));
    }

    protected processMyBankAccounts(response: HttpResponseBase): Observable<ResultMessageStringDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultMessageStringDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultMessageStringDto>(null as any);
    }

    /**
     * @param reportDate (optional) 
     * @return Success
     */
    sitResurse(reportDate: string | null | undefined): Observable<ResultSitResurseDto> {
        let url_ = this.baseUrl + "/api/services/app/Automat/SitResurse?";
        if (reportDate !== undefined && reportDate !== null)
            url_ += "reportDate=" + encodeURIComponent("" + reportDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitResurse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitResurse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultSitResurseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultSitResurseDto>;
        }));
    }

    protected processSitResurse(response: HttpResponseBase): Observable<ResultSitResurseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultSitResurseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResultSitResurseDto>(null as any);
    }

    /**
     * @return Success
     */
    testContaOperationSave(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Automat/TestContaOperationSave";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestContaOperationSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestContaOperationSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestContaOperationSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param savedBalanceDate (optional) 
     * @return Success
     */
    getSavedBalance(savedBalanceDate: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/GetSavedBalance?";
        if (savedBalanceDate !== undefined && savedBalanceDate !== null)
            url_ += "savedBalanceDate=" + encodeURIComponent("" + savedBalanceDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSavedBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSavedBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSavedBalance(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param dataRap (optional) 
     * @return Success
     */
    indicatoriReport(dataRap: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Automat/IndicatoriReport?";
        if (dataRap !== undefined && dataRap !== null)
            url_ += "dataRap=" + encodeURIComponent("" + dataRap) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndicatoriReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndicatoriReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processIndicatoriReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class AutoOperationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initForm(): Observable<AutoOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperation/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoOperationDto>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<AutoOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchAutoOper(body: AutoOperationDto | undefined): Observable<AutoOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperation/SearchAutoOper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchAutoOper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchAutoOper(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoOperationDto>;
        }));
    }

    protected processSearchAutoOper(response: HttpResponseBase): Observable<AutoOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prepareAdd(body: AutoOperationDto | undefined): Observable<AutoOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperation/PrepareAdd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoOperationDto>;
        }));
    }

    protected processPrepareAdd(response: HttpResponseBase): Observable<AutoOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    operationsAdd(body: AutoOperationDto | undefined): Observable<AutoOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperation/OperationsAdd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperationsAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperationsAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoOperationDto>;
        }));
    }

    protected processOperationsAdd(response: HttpResponseBase): Observable<AutoOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoOperationDto>(null as any);
    }

    /**
     * @param operationId (optional) 
     * @return Success
     */
    deleteOperations(operationId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperation/DeleteOperations?";
        if (operationId === null)
            throw new Error("The parameter 'operationId' cannot be null.");
        else if (operationId !== undefined)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOperations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AutoOperationConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initForm(): Observable<AutoOperationConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperationConfig/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoOperationConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoOperationConfigDto>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<AutoOperationConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoOperationConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoOperationConfigDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchConfig(body: AutoOperationConfigDto | undefined): Observable<AutoOperationConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperationConfig/SearchConfig";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoOperationConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoOperationConfigDto>;
        }));
    }

    protected processSearchConfig(response: HttpResponseBase): Observable<AutoOperationConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoOperationConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoOperationConfigDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addDetailRow(body: AutoOperationConfigDto | undefined): Observable<AutoOperationConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperationConfig/AddDetailRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDetailRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDetailRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoOperationConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoOperationConfigDto>;
        }));
    }

    protected processAddDetailRow(response: HttpResponseBase): Observable<AutoOperationConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoOperationConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoOperationConfigDto>(null as any);
    }

    /**
     * @param autoOperTypeId (optional) 
     * @return Success
     */
    getAccounts(autoOperTypeId: number | undefined): Observable<AccountConfigDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperationConfig/GetAccounts?";
        if (autoOperTypeId === null)
            throw new Error("The parameter 'autoOperTypeId' cannot be null.");
        else if (autoOperTypeId !== undefined)
            url_ += "autoOperTypeId=" + encodeURIComponent("" + autoOperTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountConfigDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountConfigDDDto[]>;
        }));
    }

    protected processGetAccounts(response: HttpResponseBase): Observable<AccountConfigDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountConfigDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountConfigDDDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveConfig(body: AutoOperationConfigDto | undefined): Observable<AutoOperationConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperationConfig/SaveConfig";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoOperationConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoOperationConfigDto>;
        }));
    }

    protected processSaveConfig(response: HttpResponseBase): Observable<AutoOperationConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoOperationConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoOperationConfigDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAutoOperSearch(body: AutoOperationConfigDto | undefined): Observable<AutoOperationConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoOperationConfig/SaveAutoOperSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAutoOperSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAutoOperSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoOperationConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoOperationConfigDto>;
        }));
    }

    protected processSaveAutoOperSearch(response: HttpResponseBase): Observable<AutoOperationConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoOperationConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoOperationConfigDto>(null as any);
    }
}

@Injectable()
export class BalanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initBalanceForm(): Observable<BalanceInitDto> {
        let url_ = this.baseUrl + "/api/services/app/Balance/InitBalanceForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitBalanceForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitBalanceForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceInitDto>;
        }));
    }

    protected processInitBalanceForm(response: HttpResponseBase): Observable<BalanceInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BalanceInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceInitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    balanceList(body: BalanceInitDto | undefined): Observable<BalanceInitDto> {
        let url_ = this.baseUrl + "/api/services/app/Balance/BalanceList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceInitDto>;
        }));
    }

    protected processBalanceList(response: HttpResponseBase): Observable<BalanceInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BalanceInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceInitDto>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @param balanceType (optional) 
     * @param body (optional) 
     * @return Success
     */
    balanceDetailsInit(balanceId: number | undefined, balanceType: string | null | undefined, body: BalanceInitDto | undefined): Observable<BalanceInitDto> {
        let url_ = this.baseUrl + "/api/services/app/Balance/BalanceDetailsInit?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        if (balanceType !== undefined && balanceType !== null)
            url_ += "balanceType=" + encodeURIComponent("" + balanceType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceDetailsInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceDetailsInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceInitDto>;
        }));
    }

    protected processBalanceDetailsInit(response: HttpResponseBase): Observable<BalanceInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BalanceInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceInitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    balanceDetails(body: BalanceInitDto | undefined): Observable<BalanceInitDto> {
        let url_ = this.baseUrl + "/api/services/app/Balance/BalanceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceInitDto>;
        }));
    }

    protected processBalanceDetails(response: HttpResponseBase): Observable<BalanceInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BalanceInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceInitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    computeBalance(body: BalanceInitDto | undefined): Observable<BalanceInitDto> {
        let url_ = this.baseUrl + "/api/services/app/Balance/ComputeBalance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComputeBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComputeBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceInitDto>;
        }));
    }

    protected processComputeBalance(response: HttpResponseBase): Observable<BalanceInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BalanceInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceInitDto>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @return Success
     */
    deleteBalance(balanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Balance/DeleteBalance?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteBalance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    balanceDDList(): Observable<BalanceDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Balance/BalanceDDList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceDDList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceDDList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceDDDto[]>;
        }));
    }

    protected processBalanceDDList(response: HttpResponseBase): Observable<BalanceDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BalanceDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceDDDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getBalanceDateNextDay(): Observable<moment.Moment> {
        let url_ = this.baseUrl + "/api/services/app/Balance/GetBalanceDateNextDay";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalanceDateNextDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalanceDateNextDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<moment.Moment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<moment.Moment>;
        }));
    }

    protected processGetBalanceDateNextDay(response: HttpResponseBase): Observable<moment.Moment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? moment(resultData200.toString()) : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<moment.Moment>(null as any);
    }

    /**
     * @param compDate (optional) 
     * @return Success
     */
    balanceSummaryList(compDate: moment.Moment | undefined): Observable<BalanceCompSummaryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Balance/BalanceSummaryList?";
        if (compDate === null)
            throw new Error("The parameter 'compDate' cannot be null.");
        else if (compDate !== undefined)
            url_ += "compDate=" + encodeURIComponent(compDate ? "" + compDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceSummaryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceSummaryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceCompSummaryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceCompSummaryDto[]>;
        }));
    }

    protected processBalanceSummaryList(response: HttpResponseBase): Observable<BalanceCompSummaryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BalanceCompSummaryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceCompSummaryDto[]>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @return Success
     */
    balanceValidList(balanceId: number | undefined): Observable<BalanceCompValidDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Balance/BalanceValidList?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceValidList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceValidList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceCompValidDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceCompValidDto[]>;
        }));
    }

    protected processBalanceValidList(response: HttpResponseBase): Observable<BalanceCompValidDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BalanceCompValidDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceCompValidDto[]>(null as any);
    }
}

@Injectable()
export class BNR_AnexaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    anexaList(): Observable<BNR_AnexaDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_Anexa/AnexaList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnexaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnexaList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_AnexaDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_AnexaDto[]>;
        }));
    }

    protected processAnexaList(response: HttpResponseBase): Observable<BNR_AnexaDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_AnexaDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_AnexaDto[]>(null as any);
    }
}

@Injectable()
export class BNR_AnexaDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    anexaBnrList(): Observable<BNR_AnexaDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_AnexaDetail/AnexaBnrList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnexaBnrList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnexaBnrList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_AnexaDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_AnexaDetailDto[]>;
        }));
    }

    protected processAnexaBnrList(response: HttpResponseBase): Observable<BNR_AnexaDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_AnexaDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_AnexaDetailDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    anexaBnrId(id: number | undefined): Observable<AnexaBnrEditDto> {
        let url_ = this.baseUrl + "/api/services/app/BNR_AnexaDetail/AnexaBnrId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnexaBnrId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnexaBnrId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnexaBnrEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnexaBnrEditDto>;
        }));
    }

    protected processAnexaBnrId(response: HttpResponseBase): Observable<AnexaBnrEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnexaBnrEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnexaBnrEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAnexaBnr(body: BNR_AnexaDetailDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BNR_AnexaDetail/UpdateAnexaBnr";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAnexaBnr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAnexaBnr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAnexaBnr(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BNR_RaportareServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param savedBalanceId (optional) 
     * @return Success
     */
    computeRaportare(savedBalanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BNR_Raportare/ComputeRaportare?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComputeRaportare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComputeRaportare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processComputeRaportare(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @return Success
     */
    deleteRaportare(savedBalanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BNR_Raportare/DeleteRaportare?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRaportare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRaportare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRaportare(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    raportareList(): Observable<BNR_RaportareDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_Raportare/RaportareList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRaportareList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRaportareList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_RaportareDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_RaportareDto[]>;
        }));
    }

    protected processRaportareList(response: HttpResponseBase): Observable<BNR_RaportareDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_RaportareDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_RaportareDto[]>(null as any);
    }

    /**
     * @param raportareRandId (optional) 
     * @return Success
     */
    raportareRowDetails(raportareRandId: number | undefined): Observable<BNR_RaportareRowDetailsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_Raportare/RaportareRowDetails?";
        if (raportareRandId === null)
            throw new Error("The parameter 'raportareRandId' cannot be null.");
        else if (raportareRandId !== undefined)
            url_ += "raportareRandId=" + encodeURIComponent("" + raportareRandId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRaportareRowDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRaportareRowDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_RaportareRowDetailsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_RaportareRowDetailsDto[]>;
        }));
    }

    protected processRaportareRowDetails(response: HttpResponseBase): Observable<BNR_RaportareRowDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_RaportareRowDetailsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_RaportareRowDetailsDto[]>(null as any);
    }

    /**
     * @param saveBalanceId (optional) 
     * @param anexaId (optional) 
     * @return Success
     */
    raportareDetailsList(saveBalanceId: number | undefined, anexaId: number | undefined): Observable<BNR_Detalii[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_Raportare/RaportareDetailsList?";
        if (saveBalanceId === null)
            throw new Error("The parameter 'saveBalanceId' cannot be null.");
        else if (saveBalanceId !== undefined)
            url_ += "saveBalanceId=" + encodeURIComponent("" + saveBalanceId) + "&";
        if (anexaId === null)
            throw new Error("The parameter 'anexaId' cannot be null.");
        else if (anexaId !== undefined)
            url_ += "anexaId=" + encodeURIComponent("" + anexaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRaportareDetailsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRaportareDetailsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_Detalii[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_Detalii[]>;
        }));
    }

    protected processRaportareDetailsList(response: HttpResponseBase): Observable<BNR_Detalii[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_Detalii.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_Detalii[]>(null as any);
    }

    /**
     * @param saveBalanceId (optional) 
     * @param anexaId (optional) 
     * @return Success
     */
    raportareRows(saveBalanceId: number | undefined, anexaId: number | undefined): Observable<BNR_RaportareRowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_Raportare/RaportareRows?";
        if (saveBalanceId === null)
            throw new Error("The parameter 'saveBalanceId' cannot be null.");
        else if (saveBalanceId !== undefined)
            url_ += "saveBalanceId=" + encodeURIComponent("" + saveBalanceId) + "&";
        if (anexaId === null)
            throw new Error("The parameter 'anexaId' cannot be null.");
        else if (anexaId !== undefined)
            url_ += "anexaId=" + encodeURIComponent("" + anexaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRaportareRows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRaportareRows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_RaportareRowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_RaportareRowDto[]>;
        }));
    }

    protected processRaportareRows(response: HttpResponseBase): Observable<BNR_RaportareRowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_RaportareRowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_RaportareRowDto[]>(null as any);
    }
}

@Injectable()
export class BNR_SectorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getBNRSectorList(): Observable<BNR_SectorListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_Sector/GetBNRSectorList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBNRSectorList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBNRSectorList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_SectorListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_SectorListDto[]>;
        }));
    }

    protected processGetBNRSectorList(response: HttpResponseBase): Observable<BNR_SectorListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_SectorListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_SectorListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: BNR_SectorEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BNR_Sector/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BNR_SectorCalcServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param balanceId (optional) 
     * @return Success
     */
    bNR_SectorConturiCalc(balanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BNR_SectorCalc/BNR_SectorConturiCalc?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBNR_SectorConturiCalc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBNR_SectorConturiCalc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBNR_SectorConturiCalc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getSectorBalanceList(): Observable<BNR_SectorCalculatListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_SectorCalc/GetSectorBalanceList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSectorBalanceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSectorBalanceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_SectorCalculatListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_SectorCalculatListDto[]>;
        }));
    }

    protected processGetSectorBalanceList(response: HttpResponseBase): Observable<BNR_SectorCalculatListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_SectorCalculatListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_SectorCalculatListDto[]>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @return Success
     */
    sectorBnrDetailList(balanceId: number | undefined): Observable<BNR_SectorRowCalcListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_SectorCalc/SectorBnrDetailList?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSectorBnrDetailList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSectorBnrDetailList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_SectorRowCalcListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_SectorRowCalcListDto[]>;
        }));
    }

    protected processSectorBnrDetailList(response: HttpResponseBase): Observable<BNR_SectorRowCalcListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_SectorRowCalcListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_SectorRowCalcListDto[]>(null as any);
    }

    /**
     * @param anexaDetailId (optional) 
     * @param sectorId (optional) 
     * @param savedBalanceId (optional) 
     * @return Success
     */
    getBNRConturiList(anexaDetailId: number | undefined, sectorId: number | null | undefined, savedBalanceId: number | undefined): Observable<BNR_SectorDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_SectorCalc/GetBNRConturiList?";
        if (anexaDetailId === null)
            throw new Error("The parameter 'anexaDetailId' cannot be null.");
        else if (anexaDetailId !== undefined)
            url_ += "anexaDetailId=" + encodeURIComponent("" + anexaDetailId) + "&";
        if (sectorId !== undefined && sectorId !== null)
            url_ += "sectorId=" + encodeURIComponent("" + sectorId) + "&";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBNRConturiList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBNRConturiList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_SectorDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_SectorDetailDto[]>;
        }));
    }

    protected processGetBNRConturiList(response: HttpResponseBase): Observable<BNR_SectorDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_SectorDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_SectorDetailDto[]>(null as any);
    }

    /**
     * @param anexaDetailId (optional) 
     * @param savedBalanceId (optional) 
     * @param anexaId (optional) 
     * @return Success
     */
    getSectorRowDetail(anexaDetailId: number | undefined, savedBalanceId: number | undefined, anexaId: number | undefined): Observable<BNR_SectorRowCalValDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BNR_SectorCalc/GetSectorRowDetail?";
        if (anexaDetailId === null)
            throw new Error("The parameter 'anexaDetailId' cannot be null.");
        else if (anexaDetailId !== undefined)
            url_ += "anexaDetailId=" + encodeURIComponent("" + anexaDetailId) + "&";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        if (anexaId === null)
            throw new Error("The parameter 'anexaId' cannot be null.");
        else if (anexaId !== undefined)
            url_ += "anexaId=" + encodeURIComponent("" + anexaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSectorRowDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSectorRowDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_SectorRowCalValDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_SectorRowCalValDto[]>;
        }));
    }

    protected processGetSectorRowDetail(response: HttpResponseBase): Observable<BNR_SectorRowCalValDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_SectorRowCalValDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_SectorRowCalValDto[]>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveBNRConturi(savedBalanceId: number | undefined, body: BNR_SectorDetailDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BNR_SectorCalc/SaveBNRConturi?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveBNRConturi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveBNRConturi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveBNRConturi(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @return Success
     */
    deleteCalculBNR(balanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BNR_SectorCalc/DeleteCalculBNR?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCalculBNR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCalculBNR(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCalculBNR(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BugetCheltuieliServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cheltuieliDisponobileList(body: BugetCheltuieliEditDto | undefined): Observable<BugetFormRandDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetCheltuieli/CheltuieliDisponobileList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheltuieliDisponobileList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheltuieliDisponobileList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetFormRandDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetFormRandDto[]>;
        }));
    }

    protected processCheltuieliDisponobileList(response: HttpResponseBase): Observable<BugetFormRandDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetFormRandDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetFormRandDto[]>(null as any);
    }

    /**
     * @param contribId (optional) 
     * @return Success
     */
    deleteCheltuiala(contribId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetCheltuieli/DeleteCheltuiala?";
        if (contribId === null)
            throw new Error("The parameter 'contribId' cannot be null.");
        else if (contribId !== undefined)
            url_ += "contribId=" + encodeURIComponent("" + contribId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCheltuiala(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCheltuiala(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCheltuiala(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param cheltId (optional) 
     * @return Success
     */
    getCheltuieliById(cheltId: number | null | undefined): Observable<BugetCheltuieliEditDto> {
        let url_ = this.baseUrl + "/api/services/app/BugetCheltuieli/GetCheltuieliById?";
        if (cheltId !== undefined && cheltId !== null)
            url_ += "cheltId=" + encodeURIComponent("" + cheltId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheltuieliById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheltuieliById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetCheltuieliEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetCheltuieliEditDto>;
        }));
    }

    protected processGetCheltuieliById(response: HttpResponseBase): Observable<BugetCheltuieliEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetCheltuieliEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetCheltuieliEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getCheltuieliList(): Observable<BugetCheltuieliDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetCheltuieli/GetCheltuieliList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheltuieliList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheltuieliList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetCheltuieliDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetCheltuieliDto[]>;
        }));
    }

    protected processGetCheltuieliList(response: HttpResponseBase): Observable<BugetCheltuieliDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetCheltuieliDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetCheltuieliDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCheltuieli(body: BugetCheltuieliEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetCheltuieli/SaveCheltuieli";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCheltuieli(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCheltuieli(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCheltuieli(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BugetConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    bugetConfigList(): Observable<BugetConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/BugetConfigList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetConfigList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetConfigList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetConfigDto[]>;
        }));
    }

    protected processBugetConfigList(response: HttpResponseBase): Observable<BugetConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetConfigDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBugetConfigId(id: number | undefined): Observable<BugetConfigEditDto> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/GetBugetConfigId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBugetConfigId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBugetConfigId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetConfigEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetConfigEditDto>;
        }));
    }

    protected processGetBugetConfigId(response: HttpResponseBase): Observable<BugetConfigEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetConfigEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetConfigEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveBugetConfig(body: BugetConfigEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/SaveBugetConfig";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveBugetConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveBugetConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveBugetConfig(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBugetConfig(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/DeleteBugetConfig?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBugetConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBugetConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteBugetConfig(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param formularId (optional) 
     * @return Success
     */
    bugetRandInit(formularId: number | undefined): Observable<BugetForm> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/BugetRandInit?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "FormularId=" + encodeURIComponent("" + formularId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRandInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRandInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetForm>;
        }));
    }

    protected processBugetRandInit(response: HttpResponseBase): Observable<BugetForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bugetRandList(body: BugetForm | undefined): Observable<BugetForm> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/BugetRandList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRandList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRandList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetForm>;
        }));
    }

    protected processBugetRandList(response: HttpResponseBase): Observable<BugetForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bugetAddRow(body: BugetForm | undefined): Observable<BugetForm> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/BugetAddRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetAddRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetAddRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetForm>;
        }));
    }

    protected processBugetAddRow(response: HttpResponseBase): Observable<BugetForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bugetOrderRow(body: BugetForm | undefined): Observable<BugetForm> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/BugetOrderRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetOrderRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetOrderRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetForm>;
        }));
    }

    protected processBugetOrderRow(response: HttpResponseBase): Observable<BugetForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bugetRandSave(body: BugetForm | undefined): Observable<BugetForm> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/BugetRandSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRandSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRandSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetForm>;
        }));
    }

    protected processBugetRandSave(response: HttpResponseBase): Observable<BugetForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bugetRandSave2(body: BugetForm | undefined): Observable<BugetForm> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/BugetRandSave2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRandSave2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRandSave2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetForm>;
        }));
    }

    protected processBugetRandSave2(response: HttpResponseBase): Observable<BugetForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetForm>(null as any);
    }

    /**
     * @param formularId (optional) 
     * @param an (optional) 
     * @return Success
     */
    bugetClonare(formularId: number | undefined, an: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetConfig/BugetClonare?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        if (an === null)
            throw new Error("The parameter 'an' cannot be null.");
        else if (an !== undefined)
            url_ += "an=" + encodeURIComponent("" + an) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetClonare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetClonare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBugetClonare(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BugetPrevServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param anBugetId (optional) 
     * @return Success
     */
    searchBugetPrev(anBugetId: number | null | undefined): Observable<BugetPrevListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/SearchBugetPrev?";
        if (anBugetId !== undefined && anBugetId !== null)
            url_ += "anBugetId=" + encodeURIComponent("" + anBugetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchBugetPrev(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchBugetPrev(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevListDto[]>;
        }));
    }

    protected processSearchBugetPrev(response: HttpResponseBase): Observable<BugetPrevListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPrevListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bugetPrevList(): Observable<BugetPrevListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/BugetPrevList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetPrevList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetPrevList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevListDto[]>;
        }));
    }

    protected processBugetPrevList(response: HttpResponseBase): Observable<BugetPrevListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPrevListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bVC_PrevGenerateInit(): Observable<BugetPrevGenerateDto> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/BVC_PrevGenerateInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_PrevGenerateInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_PrevGenerateInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevGenerateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevGenerateDto>;
        }));
    }

    protected processBVC_PrevGenerateInit(response: HttpResponseBase): Observable<BugetPrevGenerateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetPrevGenerateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevGenerateDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateBugetPrevV2(body: BugetPrevGenerateDto | undefined): Observable<BugetPrevGenerateDto> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/GenerateBugetPrevV2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateBugetPrevV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateBugetPrevV2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevGenerateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevGenerateDto>;
        }));
    }

    protected processGenerateBugetPrevV2(response: HttpResponseBase): Observable<BugetPrevGenerateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetPrevGenerateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevGenerateDto>(null as any);
    }

    /**
     * @param departamentId (optional) 
     * @param bugetPrevId (optional) 
     * @param month (optional) 
     * @param values0 (optional) 
     * @return Success
     */
    getBugetPrevDetailsV2(departamentId: number | null | undefined, bugetPrevId: number | undefined, month: string | null | undefined, values0: boolean | undefined): Observable<BugetPrevItemDto> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/GetBugetPrevDetailsV2?";
        if (departamentId !== undefined && departamentId !== null)
            url_ += "departamentId=" + encodeURIComponent("" + departamentId) + "&";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        if (month !== undefined && month !== null)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        if (values0 === null)
            throw new Error("The parameter 'values0' cannot be null.");
        else if (values0 !== undefined)
            url_ += "values0=" + encodeURIComponent("" + values0) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBugetPrevDetailsV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBugetPrevDetailsV2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevItemDto>;
        }));
    }

    protected processGetBugetPrevDetailsV2(response: HttpResponseBase): Observable<BugetPrevItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetPrevItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevItemDto>(null as any);
    }

    /**
     * @param bugetPrevId (optional) 
     * @return Success
     */
    getBugetPrevDataLunaList(bugetPrevId: number | undefined): Observable<BugetPrevMonthsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/GetBugetPrevDataLunaList?";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBugetPrevDataLunaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBugetPrevDataLunaList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevMonthsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevMonthsDto[]>;
        }));
    }

    protected processGetBugetPrevDataLunaList(response: HttpResponseBase): Observable<BugetPrevMonthsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPrevMonthsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevMonthsDto[]>(null as any);
    }

    /**
     * @param bugetPrevId (optional) 
     * @return Success
     */
    delete(bugetPrevId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/Delete?";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bugetPrevId (optional) 
     * @param departamentId (optional) 
     * @param month (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(bugetPrevId: number | undefined, departamentId: number | undefined, month: string | null | undefined, body: BugetPrevByDepartmentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/Save?";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        if (departamentId === null)
            throw new Error("The parameter 'departamentId' cannot be null.");
        else if (departamentId !== undefined)
            url_ += "departamentId=" + encodeURIComponent("" + departamentId) + "&";
        if (month !== undefined && month !== null)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bugetPrevId (optional) 
     * @return Success
     */
    validateAll(bugetPrevId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/ValidateAll?";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bugetPrevId (optional) 
     * @param departamentId (optional) 
     * @return Success
     */
    validateByDepartament(bugetPrevId: number | undefined, departamentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/ValidateByDepartament?";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        if (departamentId === null)
            throw new Error("The parameter 'departamentId' cannot be null.");
        else if (departamentId !== undefined)
            url_ += "departamentId=" + encodeURIComponent("" + departamentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateByDepartament(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateByDepartament(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidateByDepartament(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bugetPrevId (optional) 
     * @return Success
     */
    cancelAll(bugetPrevId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/CancelAll?";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bugetPrevId (optional) 
     * @param departamentId (optional) 
     * @return Success
     */
    cancelByDepartament(bugetPrevId: number | undefined, departamentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/CancelByDepartament?";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        if (departamentId === null)
            throw new Error("The parameter 'departamentId' cannot be null.");
        else if (departamentId !== undefined)
            url_ += "departamentId=" + encodeURIComponent("" + departamentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelByDepartament(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelByDepartament(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelByDepartament(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeBugetPrevState(body: BugetPrevStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/ChangeBugetPrevState";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeBugetPrevState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeBugetPrevState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeBugetPrevState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bugetPrevId (optional) 
     * @param dataBuget (optional) 
     * @param descriere (optional) 
     * @return Success
     */
    duplicateBugetPrev(bugetPrevId: number | undefined, dataBuget: moment.Moment | undefined, descriere: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/DuplicateBugetPrev?";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        if (dataBuget === null)
            throw new Error("The parameter 'dataBuget' cannot be null.");
        else if (dataBuget !== undefined)
            url_ += "dataBuget=" + encodeURIComponent(dataBuget ? "" + dataBuget.toISOString() : "") + "&";
        if (descriere !== undefined && descriere !== null)
            url_ += "descriere=" + encodeURIComponent("" + descriere) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDuplicateBugetPrev(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDuplicateBugetPrev(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDuplicateBugetPrev(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param formularId (optional) 
     * @param bvcTip (optional) 
     * @return Success
     */
    bugetPrevDDList(formularId: number | undefined, bvcTip: number | undefined): Observable<BugetPrevDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/BugetPrevDDList?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        if (bvcTip === null)
            throw new Error("The parameter 'bvcTip' cannot be null.");
        else if (bvcTip !== undefined)
            url_ += "bvcTip=" + encodeURIComponent("" + bvcTip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetPrevDDList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetPrevDDList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevDDDto[]>;
        }));
    }

    protected processBugetPrevDDList(response: HttpResponseBase): Observable<BugetPrevDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPrevDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevDDDto[]>(null as any);
    }

    /**
     * @param bugetPrevId (optional) 
     * @return Success
     */
    bugetPrevStatCalcList(bugetPrevId: number | undefined): Observable<BugetPrevStatCalculDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/BugetPrevStatCalcList?";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetPrevStatCalcList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetPrevStatCalcList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevStatCalculDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevStatCalculDto[]>;
        }));
    }

    protected processBugetPrevStatCalcList(response: HttpResponseBase): Observable<BugetPrevStatCalculDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPrevStatCalculDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevStatCalculDto[]>(null as any);
    }

    /**
     * @param formularId (optional) 
     * @return Success
     */
    bugetPreliminatLastYear(formularId: number | undefined): Observable<BugetPrevDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/BugetPreliminatLastYear?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetPreliminatLastYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetPreliminatLastYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevDDDto[]>;
        }));
    }

    protected processBugetPreliminatLastYear(response: HttpResponseBase): Observable<BugetPrevDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPrevDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevDDDto[]>(null as any);
    }

    /**
     * @param formularId (optional) 
     * @return Success
     */
    bugetPreliminatCFLastYear(formularId: number | undefined): Observable<BugetPrevDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/BugetPreliminatCFLastYear?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetPreliminatCFLastYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetPreliminatCFLastYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevDDDto[]>;
        }));
    }

    protected processBugetPreliminatCFLastYear(response: HttpResponseBase): Observable<BugetPrevDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPrevDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevDDDto[]>(null as any);
    }

    /**
     * @param bugetPrevId (optional) 
     * @param cashFlowId (optional) 
     * @param formularId (optional) 
     * @param tipBVC (optional) 
     * @return Success
     */
    calculResurse(bugetPrevId: number | undefined, cashFlowId: number | undefined, formularId: number | undefined, tipBVC: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrev/CalculResurse?";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        if (cashFlowId === null)
            throw new Error("The parameter 'cashFlowId' cannot be null.");
        else if (cashFlowId !== undefined)
            url_ += "cashFlowId=" + encodeURIComponent("" + cashFlowId) + "&";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        if (tipBVC === null)
            throw new Error("The parameter 'tipBVC' cannot be null.");
        else if (tipBVC !== undefined)
            url_ += "tipBVC=" + encodeURIComponent("" + tipBVC) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculResurse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculResurse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCalculResurse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BugetPrevAutoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    bugetPrevAutoList(): Observable<BugetPrevAutoValueListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevAuto/BugetPrevAutoList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetPrevAutoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetPrevAutoList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevAutoValueListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevAutoValueListDto[]>;
        }));
    }

    protected processBugetPrevAutoList(response: HttpResponseBase): Observable<BugetPrevAutoValueListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPrevAutoValueListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevAutoValueListDto[]>(null as any);
    }

    /**
     * @param bugetPrevAutoId (optional) 
     * @return Success
     */
    deleteBugetPrevAuto(bugetPrevAutoId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevAuto/DeleteBugetPrevAuto?";
        if (bugetPrevAutoId === null)
            throw new Error("The parameter 'bugetPrevAutoId' cannot be null.");
        else if (bugetPrevAutoId !== undefined)
            url_ += "bugetPrevAutoId=" + encodeURIComponent("" + bugetPrevAutoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBugetPrevAuto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBugetPrevAuto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteBugetPrevAuto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bugetPrevAutoId (optional) 
     * @return Success
     */
    editBugetPrevAuto(bugetPrevAutoId: number | undefined): Observable<BugetPrevAutoValueAddDto> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevAuto/EditBugetPrevAuto?";
        if (bugetPrevAutoId === null)
            throw new Error("The parameter 'bugetPrevAutoId' cannot be null.");
        else if (bugetPrevAutoId !== undefined)
            url_ += "bugetPrevAutoId=" + encodeURIComponent("" + bugetPrevAutoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditBugetPrevAuto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditBugetPrevAuto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevAutoValueAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevAutoValueAddDto>;
        }));
    }

    protected processEditBugetPrevAuto(response: HttpResponseBase): Observable<BugetPrevAutoValueAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetPrevAutoValueAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevAutoValueAddDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveBugetPrevAuto(body: BugetPrevAutoValueAddDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevAuto/SaveBugetPrevAuto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveBugetPrevAuto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveBugetPrevAuto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveBugetPrevAuto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BugetPrevContribServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contribId (optional) 
     * @return Success
     */
    deleteContrib(contribId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevContrib/DeleteContrib?";
        if (contribId === null)
            throw new Error("The parameter 'contribId' cannot be null.");
        else if (contribId !== undefined)
            url_ += "contribId=" + encodeURIComponent("" + contribId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContrib(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContrib(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContrib(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param contribId (optional) 
     * @return Success
     */
    getContribById(contribId: number | null | undefined): Observable<BugetPrevContribAddDto> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevContrib/GetContribById?";
        if (contribId !== undefined && contribId !== null)
            url_ += "contribId=" + encodeURIComponent("" + contribId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContribById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContribById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevContribAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevContribAddDto>;
        }));
    }

    protected processGetContribById(response: HttpResponseBase): Observable<BugetPrevContribAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetPrevContribAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevContribAddDto>(null as any);
    }

    /**
     * @return Success
     */
    getContribList(): Observable<BugetPrevContribListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevContrib/GetContribList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContribList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContribList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevContribListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevContribListDto[]>;
        }));
    }

    protected processGetContribList(response: HttpResponseBase): Observable<BugetPrevContribListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPrevContribListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevContribListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveContrib(body: BugetPrevContribAddDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevContrib/SaveContrib";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveContrib(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveContrib(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveContrib(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BugetPrevDobandaRefServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dobandaRefId (optional) 
     * @return Success
     */
    deleteDobandaRef(dobandaRefId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevDobandaRef/DeleteDobandaRef?";
        if (dobandaRefId === null)
            throw new Error("The parameter 'dobandaRefId' cannot be null.");
        else if (dobandaRefId !== undefined)
            url_ += "dobandaRefId=" + encodeURIComponent("" + dobandaRefId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDobandaRef(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDobandaRef(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDobandaRef(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param dobandaRefId (optional) 
     * @return Success
     */
    getDobandaRefById(dobandaRefId: number | undefined): Observable<BugetPrevDobandaReferintaEditDto> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevDobandaRef/GetDobandaRefById?";
        if (dobandaRefId === null)
            throw new Error("The parameter 'dobandaRefId' cannot be null.");
        else if (dobandaRefId !== undefined)
            url_ += "dobandaRefId=" + encodeURIComponent("" + dobandaRefId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDobandaRefById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDobandaRefById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevDobandaReferintaEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevDobandaReferintaEditDto>;
        }));
    }

    protected processGetDobandaRefById(response: HttpResponseBase): Observable<BugetPrevDobandaReferintaEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetPrevDobandaReferintaEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevDobandaReferintaEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getDobandaRefList(): Observable<BugetPrevDobandaReferintaListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevDobandaRef/GetDobandaRefList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDobandaRefList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDobandaRefList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevDobandaReferintaListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevDobandaReferintaListDto[]>;
        }));
    }

    protected processGetDobandaRefList(response: HttpResponseBase): Observable<BugetPrevDobandaReferintaListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPrevDobandaReferintaListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevDobandaReferintaListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDobandaRef(body: BugetPrevDobandaReferintaEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetPrevDobandaRef/SaveDobandaRef";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDobandaRef(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDobandaRef(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDobandaRef(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BugetRealizatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param formularId (optional) 
     * @param bvcTip (optional) 
     * @return Success
     */
    bugetRealizatList(formularId: number | undefined, bvcTip: number | null | undefined): Observable<BugetRealizatDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/BugetRealizatList?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        if (bvcTip !== undefined && bvcTip !== null)
            url_ += "bvcTip=" + encodeURIComponent("" + bvcTip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRealizatList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRealizatList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetRealizatDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetRealizatDto[]>;
        }));
    }

    protected processBugetRealizatList(response: HttpResponseBase): Observable<BugetRealizatDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetRealizatDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetRealizatDto[]>(null as any);
    }

    /**
     * @return Success
     */
    realizatAddDisponibil(): Observable<RealizatAddDispoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/RealizatAddDisponibil";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRealizatAddDisponibil(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRealizatAddDisponibil(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RealizatAddDispoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RealizatAddDispoDto[]>;
        }));
    }

    protected processRealizatAddDisponibil(response: HttpResponseBase): Observable<RealizatAddDispoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RealizatAddDispoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RealizatAddDispoDto[]>(null as any);
    }

    /**
     * @param realizatId (optional) 
     * @return Success
     */
    realizatRows(realizatId: number | undefined): Observable<BugetRealizatRowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/RealizatRows?";
        if (realizatId === null)
            throw new Error("The parameter 'realizatId' cannot be null.");
        else if (realizatId !== undefined)
            url_ += "realizatId=" + encodeURIComponent("" + realizatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRealizatRows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRealizatRows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetRealizatRowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetRealizatRowDto[]>;
        }));
    }

    protected processRealizatRows(response: HttpResponseBase): Observable<BugetRealizatRowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetRealizatRowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetRealizatRowDto[]>(null as any);
    }

    /**
     * @param rowId (optional) 
     * @return Success
     */
    realizatRowDetails(rowId: number | undefined): Observable<BugetRealizatRowDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/RealizatRowDetails?";
        if (rowId === null)
            throw new Error("The parameter 'rowId' cannot be null.");
        else if (rowId !== undefined)
            url_ += "rowId=" + encodeURIComponent("" + rowId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRealizatRowDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRealizatRowDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetRealizatRowDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetRealizatRowDetailDto[]>;
        }));
    }

    protected processRealizatRowDetails(response: HttpResponseBase): Observable<BugetRealizatRowDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetRealizatRowDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetRealizatRowDetailDto[]>(null as any);
    }

    /**
     * @param balRealizatId (optional) 
     * @return Success
     */
    balRealizatRows(balRealizatId: number | undefined): Observable<BugetBalRealizatRowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/BalRealizatRows?";
        if (balRealizatId === null)
            throw new Error("The parameter 'balRealizatId' cannot be null.");
        else if (balRealizatId !== undefined)
            url_ += "balRealizatId=" + encodeURIComponent("" + balRealizatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalRealizatRows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalRealizatRows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetBalRealizatRowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetBalRealizatRowDto[]>;
        }));
    }

    protected processBalRealizatRows(response: HttpResponseBase): Observable<BugetBalRealizatRowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetBalRealizatRowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetBalRealizatRowDto[]>(null as any);
    }

    /**
     * @param rowId (optional) 
     * @return Success
     */
    balRealizatRowDetails(rowId: number | undefined): Observable<BugetBalRealizatRowDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/BalRealizatRowDetails?";
        if (rowId === null)
            throw new Error("The parameter 'rowId' cannot be null.");
        else if (rowId !== undefined)
            url_ += "rowId=" + encodeURIComponent("" + rowId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalRealizatRowDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalRealizatRowDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetBalRealizatRowDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetBalRealizatRowDetailDto[]>;
        }));
    }

    protected processBalRealizatRowDetails(response: HttpResponseBase): Observable<BugetBalRealizatRowDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetBalRealizatRowDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetBalRealizatRowDetailDto[]>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @return Success
     */
    bugetRealizatCalcul(savedBalanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/BugetRealizatCalcul?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRealizatCalcul(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRealizatCalcul(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBugetRealizatCalcul(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param realizatId (optional) 
     * @param bugetBalRealizatId (optional) 
     * @return Success
     */
    bugetRealizatDelete(realizatId: number | undefined, bugetBalRealizatId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/BugetRealizatDelete?";
        if (realizatId === null)
            throw new Error("The parameter 'realizatId' cannot be null.");
        else if (realizatId !== undefined)
            url_ += "realizatId=" + encodeURIComponent("" + realizatId) + "&";
        if (bugetBalRealizatId !== undefined && bugetBalRealizatId !== null)
            url_ += "bugetBalRealizatId=" + encodeURIComponent("" + bugetBalRealizatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRealizatDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRealizatDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBugetRealizatDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @param bvcTip (optional) 
     * @return Success
     */
    bugetRealizatCalculTip(savedBalanceId: number | undefined, bvcTip: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/BugetRealizatCalculTip?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        if (bvcTip === null)
            throw new Error("The parameter 'bvcTip' cannot be null.");
        else if (bvcTip !== undefined)
            url_ += "bvcTip=" + encodeURIComponent("" + bvcTip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRealizatCalculTip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRealizatCalculTip(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBugetRealizatCalculTip(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param formularId (optional) 
     * @param bvcTip (optional) 
     * @return Success
     */
    bugetBalRealizatSavedBalanceDateList(formularId: number | undefined, bvcTip: number | undefined): Observable<BugetBalRealizatSavedBalanceDateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/BugetBalRealizatSavedBalanceDateList?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        if (bvcTip === null)
            throw new Error("The parameter 'bvcTip' cannot be null.");
        else if (bvcTip !== undefined)
            url_ += "bvcTip=" + encodeURIComponent("" + bvcTip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetBalRealizatSavedBalanceDateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetBalRealizatSavedBalanceDateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetBalRealizatSavedBalanceDateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetBalRealizatSavedBalanceDateDto[]>;
        }));
    }

    protected processBugetBalRealizatSavedBalanceDateList(response: HttpResponseBase): Observable<BugetBalRealizatSavedBalanceDateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetBalRealizatSavedBalanceDateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetBalRealizatSavedBalanceDateDto[]>(null as any);
    }

    /**
     * @param formularId (optional) 
     * @param bvcTip (optional) 
     * @return Success
     */
    bugetRealizatSavedBalanceDateList(formularId: number | undefined, bvcTip: number | undefined): Observable<BugetRealizatSavedBalanceDateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRealizat/BugetRealizatSavedBalanceDateList?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        if (bvcTip === null)
            throw new Error("The parameter 'bvcTip' cannot be null.");
        else if (bvcTip !== undefined)
            url_ += "bvcTip=" + encodeURIComponent("" + bvcTip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRealizatSavedBalanceDateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRealizatSavedBalanceDateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetRealizatSavedBalanceDateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetRealizatSavedBalanceDateDto[]>;
        }));
    }

    protected processBugetRealizatSavedBalanceDateList(response: HttpResponseBase): Observable<BugetRealizatSavedBalanceDateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetRealizatSavedBalanceDateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetRealizatSavedBalanceDateDto[]>(null as any);
    }
}

@Injectable()
export class BugetRepartizatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    bugetPreliminatList(): Observable<BugetPreliminatListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRepartizat/BugetPreliminatList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetPreliminatList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetPreliminatList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPreliminatListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPreliminatListDto[]>;
        }));
    }

    protected processBugetPreliminatList(response: HttpResponseBase): Observable<BugetPreliminatListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetPreliminatListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPreliminatListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bugetPreliminatNewList(): Observable<BugetFormularListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRepartizat/BugetPreliminatNewList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetPreliminatNewList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetPreliminatNewList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetFormularListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetFormularListDto[]>;
        }));
    }

    protected processBugetPreliminatNewList(response: HttpResponseBase): Observable<BugetFormularListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetFormularListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetFormularListDto[]>(null as any);
    }

    /**
     * @param formularId (optional) 
     * @return Success
     */
    bugetRepartizatAddManual(formularId: number | undefined): Observable<BugetRepartizatDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRepartizat/BugetRepartizatAddManual?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRepartizatAddManual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRepartizatAddManual(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetRepartizatDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetRepartizatDto[]>;
        }));
    }

    protected processBugetRepartizatAddManual(response: HttpResponseBase): Observable<BugetRepartizatDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetRepartizatDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetRepartizatDto[]>(null as any);
    }

    /**
     * @param preliminatId (optional) 
     * @param formularId (optional) 
     * @return Success
     */
    bugetRepartizatManualDetails(preliminatId: number | undefined, formularId: number | undefined): Observable<BugetRepartizatDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRepartizat/BugetRepartizatManualDetails?";
        if (preliminatId === null)
            throw new Error("The parameter 'preliminatId' cannot be null.");
        else if (preliminatId !== undefined)
            url_ += "preliminatId=" + encodeURIComponent("" + preliminatId) + "&";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRepartizatManualDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRepartizatManualDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetRepartizatDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetRepartizatDto[]>;
        }));
    }

    protected processBugetRepartizatManualDetails(response: HttpResponseBase): Observable<BugetRepartizatDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetRepartizatDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetRepartizatDto[]>(null as any);
    }

    /**
     * @param preliminatId (optional) 
     * @param formularId (optional) 
     * @param body (optional) 
     * @return Success
     */
    bugetRepartizatAddManualSave(preliminatId: number | undefined, formularId: number | undefined, body: BugetRepartizatDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetRepartizat/BugetRepartizatAddManualSave?";
        if (preliminatId === null)
            throw new Error("The parameter 'preliminatId' cannot be null.");
        else if (preliminatId !== undefined)
            url_ += "preliminatId=" + encodeURIComponent("" + preliminatId) + "&";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRepartizatAddManualSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRepartizatAddManualSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBugetRepartizatAddManualSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param preliminatId (optional) 
     * @return Success
     */
    bugetRepartizatDelete(preliminatId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetRepartizat/BugetRepartizatDelete?";
        if (preliminatId === null)
            throw new Error("The parameter 'preliminatId' cannot be null.");
        else if (preliminatId !== undefined)
            url_ += "preliminatId=" + encodeURIComponent("" + preliminatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRepartizatDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRepartizatDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBugetRepartizatDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param formularId (optional) 
     * @return Success
     */
    bugetRepartizatAddBalanta(formularId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/BugetRepartizat/BugetRepartizatAddBalanta?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRepartizatAddBalanta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRepartizatAddBalanta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processBugetRepartizatAddBalanta(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param preliminatId (optional) 
     * @param formularId (optional) 
     * @return Success
     */
    bugetRepartizatBalantaDetails(preliminatId: number | undefined, formularId: number | undefined): Observable<BugetRepartizatDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetRepartizat/BugetRepartizatBalantaDetails?";
        if (preliminatId === null)
            throw new Error("The parameter 'preliminatId' cannot be null.");
        else if (preliminatId !== undefined)
            url_ += "preliminatId=" + encodeURIComponent("" + preliminatId) + "&";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRepartizatBalantaDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRepartizatBalantaDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetRepartizatDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetRepartizatDto[]>;
        }));
    }

    protected processBugetRepartizatBalantaDetails(response: HttpResponseBase): Observable<BugetRepartizatDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetRepartizatDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetRepartizatDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bugetRepartizatAddBalantaSave(body: BugetRepartizatDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetRepartizat/BugetRepartizatAddBalantaSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRepartizatAddBalantaSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRepartizatAddBalantaSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBugetRepartizatAddBalantaSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param formularId (optional) 
     * @param bugetPrevId (optional) 
     * @return Success
     */
    bugetRepartizatAddPrelimVenit(formularId: number | undefined, bugetPrevId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/BugetRepartizat/BugetRepartizatAddPrelimVenit?";
        if (formularId === null)
            throw new Error("The parameter 'formularId' cannot be null.");
        else if (formularId !== undefined)
            url_ += "formularId=" + encodeURIComponent("" + formularId) + "&";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetRepartizatAddPrelimVenit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetRepartizatAddPrelimVenit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processBugetRepartizatAddPrelimVenit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class BugetVenituriServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param formularBVCId (optional) 
     * @param monthStart (optional) 
     * @param monthEnd (optional) 
     * @param bugetPreliminatId (optional) 
     * @return Success
     */
    addTitluri(formularBVCId: number | undefined, monthStart: number | undefined, monthEnd: number | undefined, bugetPreliminatId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/AddTitluri?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        if (monthStart === null)
            throw new Error("The parameter 'monthStart' cannot be null.");
        else if (monthStart !== undefined)
            url_ += "monthStart=" + encodeURIComponent("" + monthStart) + "&";
        if (monthEnd === null)
            throw new Error("The parameter 'monthEnd' cannot be null.");
        else if (monthEnd !== undefined)
            url_ += "monthEnd=" + encodeURIComponent("" + monthEnd) + "&";
        if (bugetPreliminatId !== undefined && bugetPreliminatId !== null)
            url_ += "bugetPreliminatId=" + encodeURIComponent("" + bugetPreliminatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTitluri(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTitluri(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddTitluri(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @return Success
     */
    deleteTitluri(formularBVCId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/DeleteTitluri?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTitluri(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTitluri(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTitluri(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    dispoTitluriAdd(): Observable<BugetTitluriDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/DispoTitluriAdd";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDispoTitluriAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDispoTitluriAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetTitluriDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetTitluriDDDto[]>;
        }));
    }

    protected processDispoTitluriAdd(response: HttpResponseBase): Observable<BugetTitluriDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetTitluriDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetTitluriDDDto[]>(null as any);
    }

    /**
     * @return Success
     */
    titluriAnList(): Observable<BugetTitluriDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/TitluriAnList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitluriAnList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitluriAnList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetTitluriDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetTitluriDDDto[]>;
        }));
    }

    protected processTitluriAnList(response: HttpResponseBase): Observable<BugetTitluriDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetTitluriDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetTitluriDDDto[]>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @return Success
     */
    titluriViewList(formularBVCId: number | undefined): Observable<BugetTitluriViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/TitluriViewList?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitluriViewList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitluriViewList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetTitluriViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetTitluriViewDto[]>;
        }));
    }

    protected processTitluriViewList(response: HttpResponseBase): Observable<BugetTitluriViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetTitluriViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetTitluriViewDto[]>(null as any);
    }

    /**
     * @param venitTitluId (optional) 
     * @return Success
     */
    titluriViewBVCList(venitTitluId: number | undefined): Observable<BugetTitluriBVCViewList[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/TitluriViewBVCList?";
        if (venitTitluId === null)
            throw new Error("The parameter 'venitTitluId' cannot be null.");
        else if (venitTitluId !== undefined)
            url_ += "venitTitluId=" + encodeURIComponent("" + venitTitluId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitluriViewBVCList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitluriViewBVCList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetTitluriBVCViewList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetTitluriBVCViewList[]>;
        }));
    }

    protected processTitluriViewBVCList(response: HttpResponseBase): Observable<BugetTitluriBVCViewList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetTitluriBVCViewList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetTitluriBVCViewList[]>(null as any);
    }

    /**
     * @param venitTitluId (optional) 
     * @return Success
     */
    titluriViewCFList(venitTitluId: number | undefined): Observable<BugetTitluriCFViewList[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/TitluriViewCFList?";
        if (venitTitluId === null)
            throw new Error("The parameter 'venitTitluId' cannot be null.");
        else if (venitTitluId !== undefined)
            url_ += "venitTitluId=" + encodeURIComponent("" + venitTitluId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitluriViewCFList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitluriViewCFList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetTitluriCFViewList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetTitluriCFViewList[]>;
        }));
    }

    protected processTitluriViewCFList(response: HttpResponseBase): Observable<BugetTitluriCFViewList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetTitluriCFViewList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetTitluriCFViewList[]>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @return Success
     */
    bugetReinvestStart(formularBVCId: number | undefined): Observable<BugetReinvest> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/BugetReinvestStart?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetReinvestStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetReinvestStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetReinvest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetReinvest>;
        }));
    }

    protected processBugetReinvestStart(response: HttpResponseBase): Observable<BugetReinvest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetReinvest.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetReinvest>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    reinvestIncas(formularBVCId: number | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<BugetReinvestIncasari[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/ReinvestIncas?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReinvestIncas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReinvestIncas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetReinvestIncasari[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetReinvestIncasari[]>;
        }));
    }

    protected processReinvestIncas(response: HttpResponseBase): Observable<BugetReinvestIncasari[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetReinvestIncasari.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetReinvestIncasari[]>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    tableDate(formularBVCId: number | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<TabelIncasari[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/TableDate?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTableDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTableDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TabelIncasari[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TabelIncasari[]>;
        }));
    }

    protected processTableDate(response: HttpResponseBase): Observable<TabelIncasari[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TabelIncasari.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TabelIncasari[]>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    reinvestPlati(formularBVCId: number | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<BugetReinvestPlati[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/ReinvestPlati?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReinvestPlati(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReinvestPlati(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetReinvestPlati[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetReinvestPlati[]>;
        }));
    }

    protected processReinvestPlati(response: HttpResponseBase): Observable<BugetReinvestPlati[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetReinvestPlati.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetReinvestPlati[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reinvestSave(body: BugetReinvestIncasari[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/ReinvestSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReinvestSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReinvestSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReinvestSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @param monthStart (optional) 
     * @param monthEnd (optional) 
     * @return Success
     */
    alocaCheltuieli(formularBVCId: number | undefined, monthStart: number | undefined, monthEnd: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/AlocaCheltuieli?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        if (monthStart === null)
            throw new Error("The parameter 'monthStart' cannot be null.");
        else if (monthStart !== undefined)
            url_ += "monthStart=" + encodeURIComponent("" + monthStart) + "&";
        if (monthEnd === null)
            throw new Error("The parameter 'monthEnd' cannot be null.");
        else if (monthEnd !== undefined)
            url_ += "monthEnd=" + encodeURIComponent("" + monthEnd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlocaCheltuieli(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlocaCheltuieli(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAlocaCheltuieli(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bugetPrevBVCId (optional) 
     * @param bugetPrevCFId (optional) 
     * @return Success
     */
    aplicaBVCsiCashFlow(bugetPrevBVCId: number | undefined, bugetPrevCFId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/AplicaBVCsiCashFlow?";
        if (bugetPrevBVCId === null)
            throw new Error("The parameter 'bugetPrevBVCId' cannot be null.");
        else if (bugetPrevBVCId !== undefined)
            url_ += "bugetPrevBVCId=" + encodeURIComponent("" + bugetPrevBVCId) + "&";
        if (bugetPrevCFId === null)
            throw new Error("The parameter 'bugetPrevCFId' cannot be null.");
        else if (bugetPrevCFId !== undefined)
            url_ += "bugetPrevCFId=" + encodeURIComponent("" + bugetPrevCFId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAplicaBVCsiCashFlow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAplicaBVCsiCashFlow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAplicaBVCsiCashFlow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @return Success
     */
    reinvestireVenituriTitluCF(formularBVCId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/ReinvestireVenituriTitluCF?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReinvestireVenituriTitluCF(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReinvestireVenituriTitluCF(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReinvestireVenituriTitluCF(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateVenituriTitluCF(formularBVCId: number | undefined, body: BugetTitluriViewDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/UpdateVenituriTitluCF?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVenituriTitluCF(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVenituriTitluCF(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateVenituriTitluCF(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeSumReinvest(formularBVCId: number | undefined, body: BVC_VenitTitluCFReinvDto | undefined): Observable<BVC_VenitTitluCFReinvDto> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/ChangeSumReinvest?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeSumReinvest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeSumReinvest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BVC_VenitTitluCFReinvDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BVC_VenitTitluCFReinvDto>;
        }));
    }

    protected processChangeSumReinvest(response: HttpResponseBase): Observable<BVC_VenitTitluCFReinvDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BVC_VenitTitluCFReinvDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BVC_VenitTitluCFReinvDto>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @param body (optional) 
     * @return Success
     */
    exchangeForecastByCurrency(formularBVCId: number | undefined, body: BVC_VenitTitluCFReinvDto | undefined): Observable<BVC_VenitTitluCFReinvDto> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/ExchangeForecastByCurrency?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeForecastByCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeForecastByCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BVC_VenitTitluCFReinvDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BVC_VenitTitluCFReinvDto>;
        }));
    }

    protected processExchangeForecastByCurrency(response: HttpResponseBase): Observable<BVC_VenitTitluCFReinvDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BVC_VenitTitluCFReinvDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BVC_VenitTitluCFReinvDto>(null as any);
    }

    /**
     * @param formularBVCId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    titluriViewCurrencyList(formularBVCId: number | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<BugetTitluriCFViewCurrenciesList[]> {
        let url_ = this.baseUrl + "/api/services/app/BugetVenituri/TitluriViewCurrencyList?";
        if (formularBVCId === null)
            throw new Error("The parameter 'formularBVCId' cannot be null.");
        else if (formularBVCId !== undefined)
            url_ += "formularBVCId=" + encodeURIComponent("" + formularBVCId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitluriViewCurrencyList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitluriViewCurrencyList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetTitluriCFViewCurrenciesList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetTitluriCFViewCurrenciesList[]>;
        }));
    }

    protected processTitluriViewCurrencyList(response: HttpResponseBase): Observable<BugetTitluriCFViewCurrenciesList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BugetTitluriCFViewCurrenciesList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetTitluriCFViewCurrenciesList[]>(null as any);
    }
}

@Injectable()
export class ComisioaneServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    comisionListId(imprumutId: number | undefined): Observable<ComisionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/ComisionListId?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComisionListId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComisionListId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComisionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComisionDto[]>;
        }));
    }

    protected processComisionListId(response: HttpResponseBase): Observable<ComisionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ComisionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComisionDto[]>(null as any);
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    comisionV2ListId(imprumutId: number | undefined): Observable<ComisionV2Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/ComisionV2ListId?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComisionV2ListId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComisionV2ListId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComisionV2Dto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComisionV2Dto[]>;
        }));
    }

    protected processComisionV2ListId(response: HttpResponseBase): Observable<ComisionV2Dto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ComisionV2Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComisionV2Dto[]>(null as any);
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    comisionEditNeutilizatId(imprumutId: number | undefined): Observable<ComisionEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/ComisionEditNeutilizatId?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComisionEditNeutilizatId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComisionEditNeutilizatId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComisionEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComisionEditDto>;
        }));
    }

    protected processComisionEditNeutilizatId(response: HttpResponseBase): Observable<ComisionEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComisionEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComisionEditDto>(null as any);
    }

    /**
     * @return Success
     */
    comisionList(): Observable<ComisionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/ComisionList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComisionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComisionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComisionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComisionDto[]>;
        }));
    }

    protected processComisionList(response: HttpResponseBase): Observable<ComisionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ComisionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComisionDto[]>(null as any);
    }

    /**
     * @return Success
     */
    comisionV2List(): Observable<ComisionV2Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/ComisionV2List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComisionV2List(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComisionV2List(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComisionV2Dto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComisionV2Dto[]>;
        }));
    }

    protected processComisionV2List(response: HttpResponseBase): Observable<ComisionV2Dto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ComisionV2Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComisionV2Dto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    comisionId(id: number | undefined): Observable<ComisionDto> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/ComisionId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComisionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComisionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComisionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComisionDto>;
        }));
    }

    protected processComisionId(response: HttpResponseBase): Observable<ComisionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComisionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComisionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getComisionId(id: number | undefined): Observable<ComisionEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/GetComisionId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComisionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComisionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComisionEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComisionEditDto>;
        }));
    }

    protected processGetComisionId(response: HttpResponseBase): Observable<ComisionEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComisionEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComisionEditDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getComisionV2Id(id: number | undefined): Observable<ComisionV2EditDto> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/GetComisionV2Id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComisionV2Id(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComisionV2Id(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComisionV2EditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComisionV2EditDto>;
        }));
    }

    protected processGetComisionV2Id(response: HttpResponseBase): Observable<ComisionV2EditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComisionV2EditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComisionV2EditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveComision(body: ComisionEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/SaveComision";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveComision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveComision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveComision(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveComisionV2(body: ComisionV2EditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/SaveComisionV2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveComisionV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveComisionV2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveComisionV2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveComisionLinieDeCredit(body: ComisionEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/SaveComisionLinieDeCredit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveComisionLinieDeCredit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveComisionLinieDeCredit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveComisionLinieDeCredit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDataComisionNeutilizare(body: DataComisionEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/SaveDataComisionNeutilizare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDataComisionNeutilizare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDataComisionNeutilizare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDataComisionNeutilizare(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateDateComisionPeriodic(body: Comision | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/GenerateDateComisionPeriodic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDateComisionPeriodic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDateComisionPeriodic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateDateComisionPeriodic(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateDateComisionLaAcordare(body: Comision | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/GenerateDateComisionLaAcordare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDateComisionLaAcordare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDateComisionLaAcordare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateDateComisionLaAcordare(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteComision(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/DeleteComision?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteComision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteComision(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteComisionV2(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comisioane/DeleteComisionV2?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteComisionV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComisionV2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteComisionV2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContractsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContract(id: number | undefined): Observable<ContractDto> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/GetContract?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContract(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContract(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractDto>;
        }));
    }

    protected processGetContract(response: HttpResponseBase): Observable<ContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDto>(null as any);
    }

    /**
     * @param thirdPartyId (optional) 
     * @return Success
     */
    getContractsForThirdParty(thirdPartyId: number | undefined): Observable<ContractDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/GetContractsForThirdParty?";
        if (thirdPartyId === null)
            throw new Error("The parameter 'thirdPartyId' cannot be null.");
        else if (thirdPartyId !== undefined)
            url_ += "thirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractsForThirdParty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractsForThirdParty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractDto[]>;
        }));
    }

    protected processGetContractsForThirdParty(response: HttpResponseBase): Observable<ContractDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ContractDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getContracts(): Observable<ContractDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/GetContracts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContracts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContracts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractDto[]>;
        }));
    }

    protected processGetContracts(response: HttpResponseBase): Observable<ContractDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ContractDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveContract(body: ContractDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/SaveContract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveContract(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveContract(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveContract(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContractStateListById(id: number | undefined): Observable<ContractStateListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/GetContractStateListById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractStateListById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractStateListById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractStateListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractStateListDto[]>;
        }));
    }

    protected processGetContractStateListById(response: HttpResponseBase): Observable<ContractStateListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ContractStateListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractStateListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeContractsState(body: ChangeContractStateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/ChangeContractsState";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeContractsState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeContractsState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeContractsState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    initSearch(): Observable<ContractSearchParametersDTO> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/InitSearch";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractSearchParametersDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractSearchParametersDTO>;
        }));
    }

    protected processInitSearch(response: HttpResponseBase): Observable<ContractSearchParametersDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractSearchParametersDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractSearchParametersDTO>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body: ContractSearchParametersDTO | undefined): Observable<ContractDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractDto[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ContractDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ContractDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDto[]>(null as any);
    }

    /**
     * @return Success
     */
    categoryList(): Observable<ContractCategoryListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/CategoryList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractCategoryListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractCategoryListDto[]>;
        }));
    }

    protected processCategoryList(response: HttpResponseBase): Observable<ContractCategoryListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ContractCategoryListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractCategoryListDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContractCategory(id: number | undefined): Observable<ContractCategoryEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/GetContractCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractCategoryEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractCategoryEditDto>;
        }));
    }

    protected processGetContractCategory(response: HttpResponseBase): Observable<ContractCategoryEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractCategoryEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractCategoryEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveContractCategory(body: ContractCategoryEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/SaveContractCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveContractCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveContractCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveContractCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteContractCategory(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/DeleteContractCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContractCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContractCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContractCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteContract(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/DeleteContract?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContract(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContract(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContract(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param currentDate (optional) 
     * @return Success
     */
    extendContractPeriod(currentDate: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/ExtendContractPeriod?";
        if (currentDate === null)
            throw new Error("The parameter 'currentDate' cannot be null.");
        else if (currentDate !== undefined)
            url_ += "currentDate=" + encodeURIComponent(currentDate ? "" + currentDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendContractPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendContractPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExtendContractPeriod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param thirdPartyId (optional) 
     * @return Success
     */
    getContractsForInvoiceThirdParty(thirdPartyId: number | undefined): Observable<ContractDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Contracts/GetContractsForInvoiceThirdParty?";
        if (thirdPartyId === null)
            throw new Error("The parameter 'thirdPartyId' cannot be null.");
        else if (thirdPartyId !== undefined)
            url_ += "thirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractsForInvoiceThirdParty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractsForInvoiceThirdParty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractDto[]>;
        }));
    }

    protected processGetContractsForInvoiceThirdParty(response: HttpResponseBase): Observable<ContractDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ContractDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDto[]>(null as any);
    }
}

@Injectable()
export class CotaTVAServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param cotaId (optional) 
     * @return Success
     */
    deleteCotaTVA(cotaId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CotaTVA/DeleteCotaTVA?";
        if (cotaId === null)
            throw new Error("The parameter 'cotaId' cannot be null.");
        else if (cotaId !== undefined)
            url_ += "cotaId=" + encodeURIComponent("" + cotaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCotaTVA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCotaTVA(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCotaTVA(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param cotaId (optional) 
     * @return Success
     */
    getTVAById(cotaId: number | undefined): Observable<CotaTVAEditDto> {
        let url_ = this.baseUrl + "/api/services/app/CotaTVA/GetTVAById?";
        if (cotaId === null)
            throw new Error("The parameter 'cotaId' cannot be null.");
        else if (cotaId !== undefined)
            url_ += "cotaId=" + encodeURIComponent("" + cotaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTVAById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTVAById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CotaTVAEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CotaTVAEditDto>;
        }));
    }

    protected processGetTVAById(response: HttpResponseBase): Observable<CotaTVAEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CotaTVAEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CotaTVAEditDto>(null as any);
    }

    /**
     * @return Success
     */
    getTVAList(): Observable<CotaTVAListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CotaTVA/GetTVAList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTVAList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTVAList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CotaTVAListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CotaTVAListDto[]>;
        }));
    }

    protected processGetTVAList(response: HttpResponseBase): Observable<CotaTVAListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CotaTVAListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CotaTVAListDto[]>(null as any);
    }

    /**
     * @param time (optional) 
     * @return Success
     */
    getTVAListByYear(time: moment.Moment | undefined): Observable<CotaTVAListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CotaTVA/GetTVAListByYear?";
        if (time === null)
            throw new Error("The parameter 'time' cannot be null.");
        else if (time !== undefined)
            url_ += "time=" + encodeURIComponent(time ? "" + time.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTVAListByYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTVAListByYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CotaTVAListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CotaTVAListDto[]>;
        }));
    }

    protected processGetTVAListByYear(response: HttpResponseBase): Observable<CotaTVAListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CotaTVAListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CotaTVAListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tvaListsPaapList(body: PaapDto[] | null | undefined): Observable<{ [key: string]: CotaTVAListDto[]; }> {
        let url_ = this.baseUrl + "/api/services/app/CotaTVA/TvaListsPaapList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTvaListsPaapList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTvaListsPaapList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: CotaTVAListDto[]; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: CotaTVAListDto[]; }>;
        }));
    }

    protected processTvaListsPaapList(response: HttpResponseBase): Observable<{ [key: string]: CotaTVAListDto[]; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)[key] = resultData200[key] ? resultData200[key].map((i: any) => CotaTVAListDto.fromJS(i)) : [];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: CotaTVAListDto[]; }>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCotaTVA(body: CotaTVAEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CotaTVA/SaveCotaTVA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCotaTVA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCotaTVA(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCotaTVA(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCoteTVAForPaap(body: PaapDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CotaTVA/SaveCoteTVAForPaap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCoteTVAForPaap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCoteTVAForPaap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCoteTVAForPaap(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @param cotaTVAId (optional) 
     * @return Success
     */
    calculateValueByTVA(paapId: number | undefined, cotaTVAId: number | undefined): Observable<PaapDto> {
        let url_ = this.baseUrl + "/api/services/app/CotaTVA/CalculateValueByTVA?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        if (cotaTVAId === null)
            throw new Error("The parameter 'cotaTVAId' cannot be null.");
        else if (cotaTVAId !== undefined)
            url_ += "cotaTVAId=" + encodeURIComponent("" + cotaTVAId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateValueByTVA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateValueByTVA(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapDto>;
        }));
    }

    protected processCalculateValueByTVA(response: HttpResponseBase): Observable<PaapDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaapDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapDto>(null as any);
    }
}

@Injectable()
export class CupiuriServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param index (optional) 
     * @param body (optional) 
     * @return Success
     */
    addDetailsRow(index: number | undefined, body: CupiuriForm | undefined): Observable<CupiuriForm> {
        let url_ = this.baseUrl + "/api/services/app/Cupiuri/AddDetailsRow?";
        if (index === null)
            throw new Error("The parameter 'index' cannot be null.");
        else if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDetailsRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDetailsRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CupiuriForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CupiuriForm>;
        }));
    }

    protected processAddDetailsRow(response: HttpResponseBase): Observable<CupiuriForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CupiuriForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CupiuriForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRow(body: CupiuriForm | undefined): Observable<CupiuriForm> {
        let url_ = this.baseUrl + "/api/services/app/Cupiuri/AddRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CupiuriForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CupiuriForm>;
        }));
    }

    protected processAddRow(response: HttpResponseBase): Observable<CupiuriForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CupiuriForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CupiuriForm>(null as any);
    }

    /**
     * @param cupiuriId (optional) 
     * @return Success
     */
    delete(cupiuriId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cupiuri/Delete?";
        if (cupiuriId === null)
            throw new Error("The parameter 'cupiuriId' cannot be null.");
        else if (cupiuriId !== undefined)
            url_ += "cupiuriId=" + encodeURIComponent("" + cupiuriId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param cupiuriId (optional) 
     * @return Success
     */
    cupiuriFormInit(cupiuriId: number | undefined): Observable<CupiuriForm> {
        let url_ = this.baseUrl + "/api/services/app/Cupiuri/CupiuriFormInit?";
        if (cupiuriId === null)
            throw new Error("The parameter 'cupiuriId' cannot be null.");
        else if (cupiuriId !== undefined)
            url_ += "cupiuriId=" + encodeURIComponent("" + cupiuriId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCupiuriFormInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCupiuriFormInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CupiuriForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CupiuriForm>;
        }));
    }

    protected processCupiuriFormInit(response: HttpResponseBase): Observable<CupiuriForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CupiuriForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CupiuriForm>(null as any);
    }

    /**
     * @return Success
     */
    initList(): Observable<CupiuriListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Cupiuri/InitList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CupiuriListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CupiuriListDto[]>;
        }));
    }

    protected processInitList(response: HttpResponseBase): Observable<CupiuriListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CupiuriListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CupiuriListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: CupiuriForm | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cupiuri/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param operationDate (optional) 
     * @return Success
     */
    searchCupiuri(operationDate: moment.Moment | undefined): Observable<CupiuriListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Cupiuri/SearchCupiuri?";
        if (operationDate === null)
            throw new Error("The parameter 'operationDate' cannot be null.");
        else if (operationDate !== undefined)
            url_ += "operationDate=" + encodeURIComponent(operationDate ? "" + operationDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchCupiuri(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchCupiuri(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CupiuriListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CupiuriListDto[]>;
        }));
    }

    protected processSearchCupiuri(response: HttpResponseBase): Observable<CupiuriListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CupiuriListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CupiuriListDto[]>(null as any);
    }

    /**
     * @param rowIndex (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateTotal(rowIndex: number | undefined, body: CupiuriForm | undefined): Observable<CupiuriForm> {
        let url_ = this.baseUrl + "/api/services/app/Cupiuri/UpdateTotal?";
        if (rowIndex === null)
            throw new Error("The parameter 'rowIndex' cannot be null.");
        else if (rowIndex !== undefined)
            url_ += "rowIndex=" + encodeURIComponent("" + rowIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTotal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTotal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CupiuriForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CupiuriForm>;
        }));
    }

    protected processUpdateTotal(response: HttpResponseBase): Observable<CupiuriForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CupiuriForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CupiuriForm>(null as any);
    }

    /**
     * @param currencyId (optional) 
     * @param operationDate (optional) 
     * @return Success
     */
    soldForCurrencyId(currencyId: number | undefined, operationDate: moment.Moment | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Cupiuri/SoldForCurrencyId?";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (operationDate === null)
            throw new Error("The parameter 'operationDate' cannot be null.");
        else if (operationDate !== undefined)
            url_ += "operationDate=" + encodeURIComponent(operationDate ? "" + operationDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSoldForCurrencyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSoldForCurrencyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSoldForCurrencyId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class CurrencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    currencyDDList(): Observable<CurrencyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Currency/CurrencyDDList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrencyDDList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrencyDDList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto[]>;
        }));
    }

    protected processCurrencyDDList(response: HttpResponseBase): Observable<CurrencyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CurrencyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getLocalCurrencyId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Currency/GetLocalCurrencyId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalCurrencyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalCurrencyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLocalCurrencyId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param exchangeDate (optional) 
     * @param fromCurrencyId (optional) 
     * @return Success
     */
    getLocalExchangeRate(exchangeDate: moment.Moment | undefined, fromCurrencyId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Currency/GetLocalExchangeRate?";
        if (exchangeDate === null)
            throw new Error("The parameter 'exchangeDate' cannot be null.");
        else if (exchangeDate !== undefined)
            url_ += "exchangeDate=" + encodeURIComponent(exchangeDate ? "" + exchangeDate.toISOString() : "") + "&";
        if (fromCurrencyId === null)
            throw new Error("The parameter 'fromCurrencyId' cannot be null.");
        else if (fromCurrencyId !== undefined)
            url_ += "fromCurrencyId=" + encodeURIComponent("" + fromCurrencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalExchangeRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalExchangeRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLocalExchangeRate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param exchangeDate (optional) 
     * @param fromCurrencyId (optional) 
     * @return Success
     */
    getLocalExchangeRateForOper(exchangeDate: moment.Moment | undefined, fromCurrencyId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Currency/GetLocalExchangeRateForOper?";
        if (exchangeDate === null)
            throw new Error("The parameter 'exchangeDate' cannot be null.");
        else if (exchangeDate !== undefined)
            url_ += "exchangeDate=" + encodeURIComponent(exchangeDate ? "" + exchangeDate.toISOString() : "") + "&";
        if (fromCurrencyId === null)
            throw new Error("The parameter 'fromCurrencyId' cannot be null.");
        else if (fromCurrencyId !== undefined)
            url_ += "fromCurrencyId=" + encodeURIComponent("" + fromCurrencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalExchangeRateForOper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalExchangeRateForOper(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLocalExchangeRateForOper(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param exchangeDate (optional) 
     * @param fromCurrencyId (optional) 
     * @param toCurrencyId (optional) 
     * @return Success
     */
    getExchangeRate(exchangeDate: moment.Moment | undefined, fromCurrencyId: number | undefined, toCurrencyId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Currency/GetExchangeRate?";
        if (exchangeDate === null)
            throw new Error("The parameter 'exchangeDate' cannot be null.");
        else if (exchangeDate !== undefined)
            url_ += "exchangeDate=" + encodeURIComponent(exchangeDate ? "" + exchangeDate.toISOString() : "") + "&";
        if (fromCurrencyId === null)
            throw new Error("The parameter 'fromCurrencyId' cannot be null.");
        else if (fromCurrencyId !== undefined)
            url_ += "fromCurrencyId=" + encodeURIComponent("" + fromCurrencyId) + "&";
        if (toCurrencyId === null)
            throw new Error("The parameter 'toCurrencyId' cannot be null.");
        else if (toCurrencyId !== undefined)
            url_ += "toCurrencyId=" + encodeURIComponent("" + toCurrencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExchangeRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExchangeRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetExchangeRate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class DataComisionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    dataComisionList(): Observable<DataComisionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DataComision/DataComisionList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataComisionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataComisionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataComisionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataComisionDto[]>;
        }));
    }

    protected processDataComisionList(response: HttpResponseBase): Observable<DataComisionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataComisionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataComisionDto[]>(null as any);
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    dataComisionListImprumutId(imprumutId: number | undefined): Observable<DataComisionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DataComision/DataComisionListImprumutId?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataComisionListImprumutId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataComisionListImprumutId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataComisionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataComisionDto[]>;
        }));
    }

    protected processDataComisionListImprumutId(response: HttpResponseBase): Observable<DataComisionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataComisionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataComisionDto[]>(null as any);
    }

    /**
     * @param comisionId (optional) 
     * @return Success
     */
    dataComisionListId(comisionId: number | undefined): Observable<DataComisionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DataComision/DataComisionListId?";
        if (comisionId === null)
            throw new Error("The parameter 'comisionId' cannot be null.");
        else if (comisionId !== undefined)
            url_ += "comisionId=" + encodeURIComponent("" + comisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataComisionListId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataComisionListId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataComisionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataComisionDto[]>;
        }));
    }

    protected processDataComisionListId(response: HttpResponseBase): Observable<DataComisionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataComisionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataComisionDto[]>(null as any);
    }

    /**
     * @param comisionId (optional) 
     * @return Success
     */
    dataComisionEditListId(comisionId: number | undefined): Observable<DataComisionEditDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DataComision/DataComisionEditListId?";
        if (comisionId === null)
            throw new Error("The parameter 'comisionId' cannot be null.");
        else if (comisionId !== undefined)
            url_ += "comisionId=" + encodeURIComponent("" + comisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataComisionEditListId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataComisionEditListId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataComisionEditDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataComisionEditDto[]>;
        }));
    }

    protected processDataComisionEditListId(response: HttpResponseBase): Observable<DataComisionEditDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataComisionEditDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataComisionEditDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDataComisionId(id: number | undefined): Observable<DataComisionEditDto> {
        let url_ = this.baseUrl + "/api/services/app/DataComision/GetDataComisionId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataComisionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataComisionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataComisionEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataComisionEditDto>;
        }));
    }

    protected processGetDataComisionId(response: HttpResponseBase): Observable<DataComisionEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataComisionEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataComisionEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDataComision(body: DataComisionEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataComision/SaveDataComision";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDataComision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDataComision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDataComision(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDataComision(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataComision/DeleteDataComision?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDataComision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDataComision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDataComision(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class DateDobanziReferintaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dobanziReferintaId (optional) 
     * @return Success
     */
    dateDobanziReferintaListId(dobanziReferintaId: number | undefined): Observable<DateDobanziReferintaDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DateDobanziReferinta/DateDobanziReferintaListId?";
        if (dobanziReferintaId === null)
            throw new Error("The parameter 'dobanziReferintaId' cannot be null.");
        else if (dobanziReferintaId !== undefined)
            url_ += "dobanziReferintaId=" + encodeURIComponent("" + dobanziReferintaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDateDobanziReferintaListId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDateDobanziReferintaListId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateDobanziReferintaDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateDobanziReferintaDto[]>;
        }));
    }

    protected processDateDobanziReferintaListId(response: HttpResponseBase): Observable<DateDobanziReferintaDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DateDobanziReferintaDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateDobanziReferintaDto[]>(null as any);
    }

    /**
     * @return Success
     */
    dateDobanziReferintaList(): Observable<DateDobanziReferintaDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DateDobanziReferinta/DateDobanziReferintaList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDateDobanziReferintaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDateDobanziReferintaList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateDobanziReferintaDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateDobanziReferintaDto[]>;
        }));
    }

    protected processDateDobanziReferintaList(response: HttpResponseBase): Observable<DateDobanziReferintaDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DateDobanziReferintaDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateDobanziReferintaDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDateDobanziReferintaId(id: number | undefined): Observable<DateDobanziReferintaEditDto> {
        let url_ = this.baseUrl + "/api/services/app/DateDobanziReferinta/GetDateDobanziReferintaId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDateDobanziReferintaId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDateDobanziReferintaId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateDobanziReferintaEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateDobanziReferintaEditDto>;
        }));
    }

    protected processGetDateDobanziReferintaId(response: HttpResponseBase): Observable<DateDobanziReferintaEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateDobanziReferintaEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateDobanziReferintaEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDateDobanziReferinta(body: DateDobanziReferintaEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DateDobanziReferinta/SaveDateDobanziReferinta";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDateDobanziReferinta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDateDobanziReferinta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDateDobanziReferinta(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDateDobanziReferinta(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DateDobanziReferinta/DeleteDateDobanziReferinta?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDateDobanziReferinta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDateDobanziReferinta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDateDobanziReferinta(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class DecontServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initForm(): Observable<DecontInitForm> {
        let url_ = this.baseUrl + "/api/services/app/Decont/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DecontInitForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DecontInitForm>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<DecontInitForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DecontInitForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DecontInitForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchDecont(body: DecontInitForm | undefined): Observable<DecontListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Decont/SearchDecont";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchDecont(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchDecont(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DecontListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DecontListDto[]>;
        }));
    }

    protected processSearchDecont(response: HttpResponseBase): Observable<DecontListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DecontListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DecontListDto[]>(null as any);
    }

    /**
     * @param decontId (optional) 
     * @return Success
     */
    getDecont(decontId: number | undefined): Observable<DecontEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Decont/GetDecont?";
        if (decontId === null)
            throw new Error("The parameter 'decontId' cannot be null.");
        else if (decontId !== undefined)
            url_ += "decontId=" + encodeURIComponent("" + decontId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDecont(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDecont(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DecontEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DecontEditDto>;
        }));
    }

    protected processGetDecont(response: HttpResponseBase): Observable<DecontEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DecontEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DecontEditDto>(null as any);
    }

    /**
     * @param documentTypeNameShort (optional) 
     * @return Success
     */
    getNextDecontNumber(documentTypeNameShort: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Decont/GetNextDecontNumber?";
        if (documentTypeNameShort !== undefined && documentTypeNameShort !== null)
            url_ += "documentTypeNameShort=" + encodeURIComponent("" + documentTypeNameShort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextDecontNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextDecontNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetNextDecontNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDecont(body: DecontEditDto | undefined): Observable<DecontEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Decont/SaveDecont";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDecont(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDecont(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DecontEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DecontEditDto>;
        }));
    }

    protected processSaveDecont(response: HttpResponseBase): Observable<DecontEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DecontEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DecontEditDto>(null as any);
    }

    /**
     * @param decontId (optional) 
     * @return Success
     */
    deleteDecont(decontId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Decont/DeleteDecont?";
        if (decontId === null)
            throw new Error("The parameter 'decontId' cannot be null.");
        else if (decontId !== undefined)
            url_ += "decontId=" + encodeURIComponent("" + decontId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDecont(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDecont(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDecont(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDecontToConta(body: DecontEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Decont/SaveDecontToConta";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDecontToConta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDecontToConta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDecontToConta(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param diurnaLegalaId (optional) 
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    computeDiurnaAcordataForDecont(diurnaLegalaId: number | undefined, dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined): Observable<DecontEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Decont/ComputeDiurnaAcordataForDecont?";
        if (diurnaLegalaId === null)
            throw new Error("The parameter 'diurnaLegalaId' cannot be null.");
        else if (diurnaLegalaId !== undefined)
            url_ += "diurnaLegalaId=" + encodeURIComponent("" + diurnaLegalaId) + "&";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComputeDiurnaAcordataForDecont(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComputeDiurnaAcordataForDecont(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DecontEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DecontEditDto>;
        }));
    }

    protected processComputeDiurnaAcordataForDecont(response: HttpResponseBase): Observable<DecontEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DecontEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DecontEditDto>(null as any);
    }
}

@Injectable()
export class DepartamentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDepartamentList(): Observable<DepartamentListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Departament/GetDepartamentList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartamentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartamentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartamentListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartamentListDto[]>;
        }));
    }

    protected processGetDepartamentList(response: HttpResponseBase): Observable<DepartamentListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DepartamentListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartamentListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getSalariatDepartamentList(): Observable<DepartamentListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Departament/GetSalariatDepartamentList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalariatDepartamentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalariatDepartamentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartamentListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartamentListDto[]>;
        }));
    }

    protected processGetSalariatDepartamentList(response: HttpResponseBase): Observable<DepartamentListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DepartamentListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartamentListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getDepartamentNumeList(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Departament/GetDepartamentNumeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartamentNumeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartamentNumeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetDepartamentNumeList(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }
}

@Injectable()
export class DepositServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param depositId (optional) 
     * @return Success
     */
    deleteDeposit(depositId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/DeleteDeposit?";
        if (depositId === null)
            throw new Error("The parameter 'depositId' cannot be null.");
        else if (depositId !== undefined)
            url_ += "depositId=" + encodeURIComponent("" + depositId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDeposit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param depositId (optional) 
     * @return Success
     */
    getDeposit(depositId: number | undefined): Observable<DepositEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/GetDeposit?";
        if (depositId === null)
            throw new Error("The parameter 'depositId' cannot be null.");
        else if (depositId !== undefined)
            url_ += "depositId=" + encodeURIComponent("" + depositId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositEditDto>;
        }));
    }

    protected processGetDeposit(response: HttpResponseBase): Observable<DepositEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepositEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepositEditDto>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @param operationType (optional) 
     * @return Success
     */
    getDepositList(dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined, operationType: number | null | undefined): Observable<DepositListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/GetDepositList?";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        if (operationType !== undefined && operationType !== null)
            url_ += "operationType=" + encodeURIComponent("" + operationType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepositList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepositList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositListDto[]>;
        }));
    }

    protected processGetDepositList(response: HttpResponseBase): Observable<DepositListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DepositListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepositListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDeposit(body: DepositEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/SaveDeposit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDeposit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bankId (optional) 
     * @return Success
     */
    getBankAccountsByBankId(bankId: number | undefined): Observable<ThirdPartyAccListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Deposit/GetBankAccountsByBankId?";
        if (bankId === null)
            throw new Error("The parameter 'bankId' cannot be null.");
        else if (bankId !== undefined)
            url_ += "bankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccountsByBankId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccountsByBankId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThirdPartyAccListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThirdPartyAccListDto[]>;
        }));
    }

    protected processGetBankAccountsByBankId(response: HttpResponseBase): Observable<ThirdPartyAccListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ThirdPartyAccListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThirdPartyAccListDto[]>(null as any);
    }
}

@Injectable()
export class DispositionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dispositionId (optional) 
     * @return Success
     */
    deleteDisposition(dispositionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Disposition/DeleteDisposition?";
        if (dispositionId === null)
            throw new Error("The parameter 'dispositionId' cannot be null.");
        else if (dispositionId !== undefined)
            url_ += "dispositionId=" + encodeURIComponent("" + dispositionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDisposition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDisposition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDisposition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @param dispositionState (optional) 
     * @return Success
     */
    dispositionList(dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined, dispositionState: number | null | undefined): Observable<DispositionListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Disposition/DispositionList?";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        if (dispositionState !== undefined && dispositionState !== null)
            url_ += "dispositionState=" + encodeURIComponent("" + dispositionState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDispositionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDispositionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DispositionListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DispositionListDto[]>;
        }));
    }

    protected processDispositionList(response: HttpResponseBase): Observable<DispositionListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DispositionListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DispositionListDto[]>(null as any);
    }

    /**
     * @param dispositionId (optional) 
     * @return Success
     */
    getDisposition(dispositionId: number | undefined): Observable<DispositionEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Disposition/GetDisposition?";
        if (dispositionId === null)
            throw new Error("The parameter 'dispositionId' cannot be null.");
        else if (dispositionId !== undefined)
            url_ += "dispositionId=" + encodeURIComponent("" + dispositionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDisposition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDisposition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DispositionEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DispositionEditDto>;
        }));
    }

    protected processGetDisposition(response: HttpResponseBase): Observable<DispositionEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DispositionEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DispositionEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDisposition(body: DispositionEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Disposition/SaveDisposition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDisposition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDisposition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDisposition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    getNextNumber(date: moment.Moment | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Disposition/GetNextNumber?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetNextNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param currentDate (optional) 
     * @return Success
     */
    getNextNumberForChitanta(currentDate: moment.Moment | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Disposition/GetNextNumberForChitanta?";
        if (currentDate === null)
            throw new Error("The parameter 'currentDate' cannot be null.");
        else if (currentDate !== undefined)
            url_ += "currentDate=" + encodeURIComponent(currentDate ? "" + currentDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextNumberForChitanta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextNumberForChitanta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetNextNumberForChitanta(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class DiurnaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param diurnaId (optional) 
     * @return Success
     */
    deleteDiurnaLegala(diurnaId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/DeleteDiurnaLegala?";
        if (diurnaId === null)
            throw new Error("The parameter 'diurnaId' cannot be null.");
        else if (diurnaId !== undefined)
            url_ += "diurnaId=" + encodeURIComponent("" + diurnaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDiurnaLegala(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDiurnaLegala(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDiurnaLegala(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param diurnaId (optional) 
     * @return Success
     */
    deleteDiurnaZi(diurnaId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/DeleteDiurnaZi?";
        if (diurnaId === null)
            throw new Error("The parameter 'diurnaId' cannot be null.");
        else if (diurnaId !== undefined)
            url_ += "diurnaId=" + encodeURIComponent("" + diurnaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDiurnaZi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDiurnaZi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDiurnaZi(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    diurnaLegalaList(): Observable<DiurnaListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/DiurnaLegalaList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiurnaLegalaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiurnaLegalaList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiurnaListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiurnaListDto[]>;
        }));
    }

    protected processDiurnaLegalaList(response: HttpResponseBase): Observable<DiurnaListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DiurnaListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiurnaListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    diurnaZiList(): Observable<DiurnaListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/DiurnaZiList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiurnaZiList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiurnaZiList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiurnaListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiurnaListDto[]>;
        }));
    }

    protected processDiurnaZiList(response: HttpResponseBase): Observable<DiurnaListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DiurnaListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiurnaListDto[]>(null as any);
    }

    /**
     * @param diurnaId (optional) 
     * @return Success
     */
    getDiurnaLegalaById(diurnaId: number | undefined): Observable<DiurnaEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/GetDiurnaLegalaById?";
        if (diurnaId === null)
            throw new Error("The parameter 'diurnaId' cannot be null.");
        else if (diurnaId !== undefined)
            url_ += "diurnaId=" + encodeURIComponent("" + diurnaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiurnaLegalaById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiurnaLegalaById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiurnaEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiurnaEditDto>;
        }));
    }

    protected processGetDiurnaLegalaById(response: HttpResponseBase): Observable<DiurnaEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiurnaEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiurnaEditDto>(null as any);
    }

    /**
     * @param diurnaId (optional) 
     * @return Success
     */
    getDiurnaZiById(diurnaId: number | undefined): Observable<DiurnaEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/GetDiurnaZiById?";
        if (diurnaId === null)
            throw new Error("The parameter 'diurnaId' cannot be null.");
        else if (diurnaId !== undefined)
            url_ += "diurnaId=" + encodeURIComponent("" + diurnaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiurnaZiById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiurnaZiById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiurnaEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiurnaEditDto>;
        }));
    }

    protected processGetDiurnaZiById(response: HttpResponseBase): Observable<DiurnaEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiurnaEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiurnaEditDto>(null as any);
    }

    /**
     * @param diurnaId (optional) 
     * @return Success
     */
    getDiurnaLegalaValue(diurnaId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/GetDiurnaLegalaValue?";
        if (diurnaId === null)
            throw new Error("The parameter 'diurnaId' cannot be null.");
        else if (diurnaId !== undefined)
            url_ += "diurnaId=" + encodeURIComponent("" + diurnaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiurnaLegalaValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiurnaLegalaValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetDiurnaLegalaValue(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param diurnaId (optional) 
     * @return Success
     */
    getDiurnaZiValue(diurnaId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/GetDiurnaZiValue?";
        if (diurnaId === null)
            throw new Error("The parameter 'diurnaId' cannot be null.");
        else if (diurnaId !== undefined)
            url_ += "diurnaId=" + encodeURIComponent("" + diurnaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiurnaZiValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiurnaZiValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetDiurnaZiValue(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDiurnaLegala(body: DiurnaEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/SaveDiurnaLegala";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDiurnaLegala(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDiurnaLegala(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDiurnaLegala(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDiurnaZi(body: DiurnaEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/SaveDiurnaZi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDiurnaZi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDiurnaZi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDiurnaZi(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param diurnaId (optional) 
     * @return Success
     */
    isDiurnaExterna(diurnaId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Diurna/IsDiurnaExterna?";
        if (diurnaId === null)
            throw new Error("The parameter 'diurnaId' cannot be null.");
        else if (diurnaId !== undefined)
            url_ += "diurnaId=" + encodeURIComponent("" + diurnaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsDiurnaExterna(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsDiurnaExterna(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsDiurnaExterna(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class DobanziReferintaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    dobanziReferintaList(): Observable<DobanziReferintaDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DobanziReferinta/DobanziReferintaList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDobanziReferintaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDobanziReferintaList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DobanziReferintaDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DobanziReferintaDto[]>;
        }));
    }

    protected processDobanziReferintaList(response: HttpResponseBase): Observable<DobanziReferintaDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DobanziReferintaDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DobanziReferintaDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDobandaReferintaId(id: number | undefined): Observable<DobanziReferintaEditDto> {
        let url_ = this.baseUrl + "/api/services/app/DobanziReferinta/GetDobandaReferintaId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDobandaReferintaId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDobandaReferintaId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DobanziReferintaEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DobanziReferintaEditDto>;
        }));
    }

    protected processGetDobandaReferintaId(response: HttpResponseBase): Observable<DobanziReferintaEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DobanziReferintaEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DobanziReferintaEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDobandaReferinta(body: DobanziReferintaDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DobanziReferinta/SaveDobandaReferinta";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDobandaReferinta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDobandaReferinta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDobandaReferinta(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDobandaReferinta(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DobanziReferinta/DeleteDobandaReferinta?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDobandaReferinta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDobandaReferinta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDobandaReferinta(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class DocumentTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    documentTypeList(): Observable<GetDocumentTypeOutput> {
        let url_ = this.baseUrl + "/api/services/app/DocumentType/DocumentTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDocumentTypeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDocumentTypeOutput>;
        }));
    }

    protected processDocumentTypeList(response: HttpResponseBase): Observable<GetDocumentTypeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDocumentTypeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentTypeOutput>(null as any);
    }

    /**
     * @param documentName (optional) 
     * @return Success
     */
    documentTypeListByStr(documentName: string | null | undefined): Observable<GetDocumentTypeOutput> {
        let url_ = this.baseUrl + "/api/services/app/DocumentType/DocumentTypeListByStr?";
        if (documentName !== undefined && documentName !== null)
            url_ += "documentName=" + encodeURIComponent("" + documentName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentTypeListByStr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentTypeListByStr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDocumentTypeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDocumentTypeOutput>;
        }));
    }

    protected processDocumentTypeListByStr(response: HttpResponseBase): Observable<GetDocumentTypeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDocumentTypeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDocumentTypeOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocTypeById(id: number | undefined): Observable<DocumentTypeEditDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentType/GetDocTypeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentTypeEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentTypeEditDto>;
        }));
    }

    protected processGetDocTypeById(response: HttpResponseBase): Observable<DocumentTypeEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentTypeEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDocumentType(body: DocumentTypeEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentType/SaveDocumentType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDocumentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDocumentType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveDocumentType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param idDoc (optional) 
     * @return Success
     */
    deleteDocumentType(idDoc: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentType/DeleteDocumentType?";
        if (idDoc === null)
            throw new Error("The parameter 'idDoc' cannot be null.");
        else if (idDoc !== undefined)
            url_ += "idDoc=" + encodeURIComponent("" + idDoc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDocumentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDocumentType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDocumentType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param documentShortName (optional) 
     * @return Success
     */
    getDocumentTypeId(documentShortName: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DocumentType/GetDocumentTypeId?";
        if (documentShortName !== undefined && documentShortName !== null)
            url_ += "documentShortName=" + encodeURIComponent("" + documentShortName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetDocumentTypeId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param operationDate (optional) 
     * @param body (optional) 
     * @return Success
     */
    nextDocumentNumber(operationDate: moment.Moment | undefined, body: DocumentTypeEditDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DocumentType/NextDocumentNumber?";
        if (operationDate === null)
            throw new Error("The parameter 'operationDate' cannot be null.");
        else if (operationDate !== undefined)
            url_ += "operationDate=" + encodeURIComponent(operationDate ? "" + operationDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNextDocumentNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNextDocumentNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processNextDocumentNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class EnumServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    imoAssetOperTypeList(): Observable<GetImoAssetOperTypeOutput> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ImoAssetOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImoAssetOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImoAssetOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetImoAssetOperTypeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetImoAssetOperTypeOutput>;
        }));
    }

    protected processImoAssetOperTypeList(response: HttpResponseBase): Observable<GetImoAssetOperTypeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetImoAssetOperTypeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetImoAssetOperTypeOutput>(null as any);
    }

    /**
     * @return Success
     */
    invOperationTypeList(): Observable<GetInvOperationTypeOutput> {
        let url_ = this.baseUrl + "/api/services/app/Enum/InvOperationTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvOperationTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvOperationTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInvOperationTypeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInvOperationTypeOutput>;
        }));
    }

    protected processInvOperationTypeList(response: HttpResponseBase): Observable<GetInvOperationTypeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvOperationTypeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvOperationTypeOutput>(null as any);
    }

    /**
     * @return Success
     */
    prepaymentsOperationTypeList(): Observable<PrepaymentOperationTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/PrepaymentsOperationTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepaymentsOperationTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepaymentsOperationTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentOperationTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentOperationTypeDto[]>;
        }));
    }

    protected processPrepaymentsOperationTypeList(response: HttpResponseBase): Observable<PrepaymentOperationTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PrepaymentOperationTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentOperationTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    taxProfitOperationTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/TaxProfitOperationTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaxProfitOperationTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaxProfitOperationTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processTaxProfitOperationTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    accountTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/AccountTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processAccountTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    accountFuncTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/AccountFuncTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountFuncTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountFuncTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processAccountFuncTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    autoOperationTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/AutoOperationTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoOperationTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoOperationTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processAutoOperationTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    autoOperationTypeListConfig(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/AutoOperationTypeListConfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoOperationTypeListConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoOperationTypeListConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processAutoOperationTypeListConfig(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    imoAssetStockElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ImoAssetStockElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImoAssetStockElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImoAssetStockElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processImoAssetStockElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    invObjectStockElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/InvObjectStockElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvObjectStockElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvObjectStockElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processInvObjectStockElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    prepaymentStockElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/PrepaymentStockElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepaymentStockElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepaymentStockElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processPrepaymentStockElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    taxProfitElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/TaxProfitElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaxProfitElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaxProfitElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processTaxProfitElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    valueSignList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ValueSignList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValueSignList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValueSignList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processValueSignList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    invoiceElementsTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/InvoiceElementsTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceElementsTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceElementsTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processInvoiceElementsTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    accountDivConfigPersTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/AccountDivConfigPersTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDivConfigPersTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDivConfigPersTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processAccountDivConfigPersTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    accountDivConfigResidenceTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/AccountDivConfigResidenceTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDivConfigResidenceTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDivConfigResidenceTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processAccountDivConfigResidenceTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    accountDivConfigTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/AccountDivConfigTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDivConfigTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDivConfigTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processAccountDivConfigTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    prepaymentsOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/PrepaymentsOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepaymentsOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepaymentsOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processPrepaymentsOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    taxProfitPropertyElemList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/TaxProfitPropertyElemList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaxProfitPropertyElemList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaxProfitPropertyElemList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processTaxProfitPropertyElemList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    taxProfitPickConditionList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/TaxProfitPickConditionList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaxProfitPickConditionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaxProfitPickConditionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processTaxProfitPickConditionList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    taxProfitConfigSourceList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/TaxProfitConfigSourceList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaxProfitConfigSourceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaxProfitConfigSourceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processTaxProfitConfigSourceList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    accountTaxStatusList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/AccountTaxStatusList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountTaxStatusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountTaxStatusList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processAccountTaxStatusList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    prepaymentDurationCalcList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/PrepaymentDurationCalcList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepaymentDurationCalcList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepaymentDurationCalcList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processPrepaymentDurationCalcList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    imoAssetTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ImoAssetTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImoAssetTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImoAssetTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processImoAssetTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    issuerTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/IssuerTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIssuerTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIssuerTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processIssuerTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    taxProfitDeducType(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/TaxProfitDeducType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaxProfitDeducType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaxProfitDeducType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processTaxProfitDeducType(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    decontTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/DecontTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDecontTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDecontTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processDecontTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    categoryTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/CategoryTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processCategoryTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    diurnaTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/DiurnaTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiurnaTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiurnaTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processDiurnaTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    dictionaryTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/DictionaryTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDictionaryTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDictionaryTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processDictionaryTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    scopeDeplasareList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ScopeDeplasareList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScopeDeplasareList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScopeDeplasareList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processScopeDeplasareList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    imprumuturiTipDurataList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ImprumuturiTipDurataList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumuturiTipDurataList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumuturiTipDurataList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processImprumuturiTipDurataList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    titluriDePlasamentOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/TitluriDePlasamentOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitluriDePlasamentOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitluriDePlasamentOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processTitluriDePlasamentOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    titluriDePlasamentElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/TitluriDePlasamentElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitluriDePlasamentElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitluriDePlasamentElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processTitluriDePlasamentElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    depoziteBancareOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/DepoziteBancareOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDepoziteBancareOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDepoziteBancareOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processDepoziteBancareOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    depoziteBancareElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/DepoziteBancareElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDepoziteBancareElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDepoziteBancareElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processDepoziteBancareElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    repoDepoDateInPensiuneLivrataOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/RepoDepoDateInPensiuneLivrataOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoDepoDateInPensiuneLivrataOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoDepoDateInPensiuneLivrataOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processRepoDepoDateInPensiuneLivrataOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    repoDepoDateInPensiuneLivrataElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/RepoDepoDateInPensiuneLivrataElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoDepoDateInPensiuneLivrataElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoDepoDateInPensiuneLivrataElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processRepoDepoDateInPensiuneLivrataElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    repoDepoPrimiteInPensiuneLivrataOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/RepoDepoPrimiteInPensiuneLivrataOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoDepoPrimiteInPensiuneLivrataOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoDepoPrimiteInPensiuneLivrataOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processRepoDepoPrimiteInPensiuneLivrataOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    repoDepoPrimiteInPensiuneLivrataElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/RepoDepoPrimiteInPensiuneLivrataElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoDepoPrimiteInPensiuneLivrataElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoDepoPrimiteInPensiuneLivrataElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processRepoDepoPrimiteInPensiuneLivrataElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    certificateDepozitOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/CertificateDepozitOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCertificateDepozitOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCertificateDepozitOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processCertificateDepozitOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    certificateDepozitElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/CertificateDepozitElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCertificateDepozitElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCertificateDepozitElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processCertificateDepozitElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    contributiiOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ContributiiOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContributiiOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContributiiOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processContributiiOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    contributiiElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ContributiiElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContributiiElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContributiiElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processContributiiElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    ajustariDeprecierePlasamenteOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/AjustariDeprecierePlasamenteOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAjustariDeprecierePlasamenteOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAjustariDeprecierePlasamenteOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processAjustariDeprecierePlasamenteOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    ajustariDeprecierePlasamenteElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/AjustariDeprecierePlasamenteElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAjustariDeprecierePlasamenteElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAjustariDeprecierePlasamenteElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processAjustariDeprecierePlasamenteElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    reclasificariOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ReclasificariOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReclasificariOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReclasificariOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processReclasificariOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    reclasificariElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ReclasificariElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReclasificariElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReclasificariElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processReclasificariElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    imprumuturiOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ImprumuturiOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumuturiOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumuturiOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processImprumuturiOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    imprumuturiElementList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ImprumuturiElementList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumuturiElementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumuturiElementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processImprumuturiElementList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    exchangeOperTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ExchangeOperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processExchangeOperTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    exchangeTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ExchangeTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processExchangeTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    sursaFinantareList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/SursaFinantareList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSursaFinantareList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSursaFinantareList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processSursaFinantareList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    modalitateDerulareList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ModalitateDerulareList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModalitateDerulareList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModalitateDerulareList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processModalitateDerulareList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    obiecteTranzactieList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ObiecteTranzactieList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObiecteTranzactieList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObiecteTranzactieList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processObiecteTranzactieList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    contractsStatusList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ContractsStatusList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractsStatusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractsStatusList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processContractsStatusList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    tipPerioadaSoldList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/TipPerioadaSoldList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTipPerioadaSoldList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTipPerioadaSoldList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processTipPerioadaSoldList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bvcTipList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/BvcTipList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBvcTipList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBvcTipList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processBvcTipList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bVC_RowTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/BVC_RowTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_RowTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_RowTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processBVC_RowTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bVC_RowTypeIncome(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/BVC_RowTypeIncome";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_RowTypeIncome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_RowTypeIncome(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processBVC_RowTypeIncome(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bVC_StatusList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/BVC_StatusList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_StatusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_StatusList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processBVC_StatusList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bVC_PlasamentTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/BVC_PlasamentTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_PlasamentTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_PlasamentTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processBVC_PlasamentTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bVC_RowTypeList2(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/BVC_RowTypeList2";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_RowTypeList2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_RowTypeList2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processBVC_RowTypeList2(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bVC_RowTypeSalarizare(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/BVC_RowTypeSalarizare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_RowTypeSalarizare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_RowTypeSalarizare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processBVC_RowTypeSalarizare(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    preliminatCalculTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/PreliminatCalculTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreliminatCalculTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreliminatCalculTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processPreliminatCalculTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    sitFinanRowModCalc(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/SitFinanRowModCalc";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanRowModCalc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanRowModCalc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processSitFinanRowModCalc(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bVC_BugetPrevContributieTipIncasare(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/BVC_BugetPrevContributieTipIncasare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_BugetPrevContributieTipIncasare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_BugetPrevContributieTipIncasare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processBVC_BugetPrevContributieTipIncasare(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    tipTragere(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/TipTragere";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTipTragere(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTipTragere(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processTipTragere(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    imprumuturiStare(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ImprumuturiStare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumuturiStare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumuturiStare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processImprumuturiStare(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    lichidCalcTypeList(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/LichidCalcTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLichidCalcTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLichidCalcTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processLichidCalcTypeList(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    imprumutTipDetaliuDescriere(): Observable<EnumImprumutTipDetaliuDescriereDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/ImprumutTipDetaliuDescriere";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumutTipDetaliuDescriere(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumutTipDetaliuDescriere(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumImprumutTipDetaliuDescriereDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumImprumutTipDetaliuDescriereDto[]>;
        }));
    }

    protected processImprumutTipDetaliuDescriere(response: HttpResponseBase): Observable<EnumImprumutTipDetaliuDescriereDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumImprumutTipDetaliuDescriereDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumImprumutTipDetaliuDescriereDto[]>(null as any);
    }

    /**
     * @return Success
     */
    garantieTipPrimitaData(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/GarantieTipPrimitaData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGarantieTipPrimitaData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGarantieTipPrimitaData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processGarantieTipPrimitaData(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    operatieGarantieTipEnum(): Observable<EnumTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Enum/OperatieGarantieTipEnum";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperatieGarantieTipEnum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperatieGarantieTipEnum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumTypeDto[]>;
        }));
    }

    protected processOperatieGarantieTipEnum(response: HttpResponseBase): Observable<EnumTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumTypeDto[]>(null as any);
    }
}

@Injectable()
export class ExchangeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param value (optional) 
     * @param exchangeRate (optional) 
     * @param operType (optional) 
     * @return Success
     */
    calculateExchangeValue(value: number | undefined, exchangeRate: number | null | undefined, operType: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Exchange/CalculateExchangeValue?";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        if (exchangeRate !== undefined && exchangeRate !== null)
            url_ += "exchangeRate=" + encodeURIComponent("" + exchangeRate) + "&";
        if (operType === null)
            throw new Error("The parameter 'operType' cannot be null.");
        else if (operType !== undefined)
            url_ += "operType=" + encodeURIComponent("" + operType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateExchangeValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateExchangeValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCalculateExchangeValue(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param exchangeId (optional) 
     * @return Success
     */
    deleteExchange(exchangeId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exchange/DeleteExchange?";
        if (exchangeId === null)
            throw new Error("The parameter 'exchangeId' cannot be null.");
        else if (exchangeId !== undefined)
            url_ += "exchangeId=" + encodeURIComponent("" + exchangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteExchange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExchange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteExchange(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    exchangeInit(): Observable<ExchangeInitDto> {
        let url_ = this.baseUrl + "/api/services/app/Exchange/ExchangeInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangeInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangeInitDto>;
        }));
    }

    protected processExchangeInit(response: HttpResponseBase): Observable<ExchangeInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExchangeInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeInitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exchangeList(body: ExchangeInitDto | undefined): Observable<ExchangeInitDto> {
        let url_ = this.baseUrl + "/api/services/app/Exchange/ExchangeList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangeInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangeInitDto>;
        }));
    }

    protected processExchangeList(response: HttpResponseBase): Observable<ExchangeInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExchangeInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeInitDto>(null as any);
    }

    /**
     * @param exchangeId (optional) 
     * @return Success
     */
    getExchangeById(exchangeId: number | null | undefined): Observable<ExchangeEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Exchange/GetExchangeById?";
        if (exchangeId !== undefined && exchangeId !== null)
            url_ += "exchangeId=" + encodeURIComponent("" + exchangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExchangeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExchangeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangeEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangeEditDto>;
        }));
    }

    protected processGetExchangeById(response: HttpResponseBase): Observable<ExchangeEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExchangeEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveExchange(body: ExchangeEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Exchange/SaveExchange";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveExchange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveExchange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveExchange(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ExchangeRateForecastServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getExchangeRateYearList(): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateForecast/GetExchangeRateYearList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExchangeRateYearList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExchangeRateYearList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processGetExchangeRateYearList(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(null as any);
    }

    /**
     * @return Success
     */
    exchangeRateForecastDtoList(): Observable<ExchangeRateForecastDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateForecast/ExchangeRateForecastDtoList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeRateForecastDtoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeRateForecastDtoList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangeRateForecastDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangeRateForecastDto[]>;
        }));
    }

    protected processExchangeRateForecastDtoList(response: HttpResponseBase): Observable<ExchangeRateForecastDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExchangeRateForecastDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeRateForecastDto[]>(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    exchangeRateForecastDtoListYear(year: number | undefined): Observable<ExchangeRateForecastDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateForecast/ExchangeRateForecastDtoListYear?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeRateForecastDtoListYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeRateForecastDtoListYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangeRateForecastDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangeRateForecastDto[]>;
        }));
    }

    protected processExchangeRateForecastDtoListYear(response: HttpResponseBase): Observable<ExchangeRateForecastDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExchangeRateForecastDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeRateForecastDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getExchangeRateForecastId(id: number | undefined): Observable<ExchangeRateForecastEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateForecast/GetExchangeRateForecastId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExchangeRateForecastId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExchangeRateForecastId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangeRateForecastEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangeRateForecastEditDto>;
        }));
    }

    protected processGetExchangeRateForecastId(response: HttpResponseBase): Observable<ExchangeRateForecastEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExchangeRateForecastEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeRateForecastEditDto>(null as any);
    }

    /**
     * @param currencyId (optional) 
     * @param year (optional) 
     * @return Success
     */
    getExchangeRateForecastCurrency(currencyId: number | undefined, year: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateForecast/GetExchangeRateForecastCurrency?";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExchangeRateForecastCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExchangeRateForecastCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetExchangeRateForecastCurrency(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveExchangeRateForecast(body: ExchangeRateForecastEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateForecast/SaveExchangeRateForecast";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveExchangeRateForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveExchangeRateForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveExchangeRateForecast(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteExchangeRateForecast(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateForecast/DeleteExchangeRateForecast?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteExchangeRateForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExchangeRateForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteExchangeRateForecast(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class FileDocExternServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param documentId (optional) 
     * @return Success
     */
    getAtasamente(documentId: number | undefined): Observable<AtasamentDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/FileDocExtern/GetAtasamente?";
        if (documentId === null)
            throw new Error("The parameter 'documentId' cannot be null.");
        else if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAtasamente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAtasamente(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AtasamentDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AtasamentDTO[]>;
        }));
    }

    protected processGetAtasamente(response: HttpResponseBase): Observable<AtasamentDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AtasamentDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AtasamentDTO[]>(null as any);
    }

    /**
     * @param attachementId (optional) 
     * @return Success
     */
    getAtasamentFile(attachementId: number | undefined): Observable<AtasamentFileDTO> {
        let url_ = this.baseUrl + "/api/services/app/FileDocExtern/GetAtasamentFile?";
        if (attachementId === null)
            throw new Error("The parameter 'attachementId' cannot be null.");
        else if (attachementId !== undefined)
            url_ += "attachementId=" + encodeURIComponent("" + attachementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAtasamentFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAtasamentFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AtasamentFileDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AtasamentFileDTO>;
        }));
    }

    protected processGetAtasamentFile(response: HttpResponseBase): Observable<AtasamentFileDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtasamentFileDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AtasamentFileDTO>(null as any);
    }

    /**
     * @return Success
     */
    getFileDocViewUrl(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/FileDocExtern/GetFileDocViewUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileDocViewUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileDocViewUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetFileDocViewUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    getImportErrors(): Observable<FileDocErrorDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FileDocExtern/GetImportErrors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImportErrors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImportErrors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDocErrorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDocErrorDto[]>;
        }));
    }

    protected processGetImportErrors(response: HttpResponseBase): Observable<FileDocErrorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FileDocErrorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDocErrorDto[]>(null as any);
    }
}

@Injectable()
export class ForeignOperationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initForm(): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    operSearch(body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/OperSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processOperSearch(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveSelection(body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/SaveSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSelection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processSaveSelection(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param detailId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addAccountingRow(detailId: number | undefined, body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/AddAccountingRow?";
        if (detailId === null)
            throw new Error("The parameter 'detailId' cannot be null.");
        else if (detailId !== undefined)
            url_ += "detailId=" + encodeURIComponent("" + detailId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAccountingRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAccountingRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processAddAccountingRow(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param detailId (optional) 
     * @param index (optional) 
     * @param body (optional) 
     * @return Success
     */
    accountingRowDelete(detailId: number | undefined, index: number | undefined, body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/AccountingRowDelete?";
        if (detailId === null)
            throw new Error("The parameter 'detailId' cannot be null.");
        else if (detailId !== undefined)
            url_ += "detailId=" + encodeURIComponent("" + detailId) + "&";
        if (index === null)
            throw new Error("The parameter 'index' cannot be null.");
        else if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountingRowDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountingRowDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processAccountingRowDelete(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateConta(body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/GenerateConta";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateConta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateConta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processGenerateConta(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    initDeleteForm(body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/InitDeleteForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitDeleteForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitDeleteForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processInitDeleteForm(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    operDeleteSearch(body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/OperDeleteSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperDeleteSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperDeleteSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processOperDeleteSearch(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadFileStart(body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/UploadFileStart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFileStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFileStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processUploadFileStart(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadOperationFile(body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/UploadOperationFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadOperationFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadOperationFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processUploadOperationFile(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyOkGenerate(body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/VerifyOkGenerate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyOkGenerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyOkGenerate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processVerifyOkGenerate(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param foreignOperationId (optional) 
     * @param body (optional) 
     * @return Success
     */
    operDeleteNC(foreignOperationId: number | undefined, body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/OperDeleteNC?";
        if (foreignOperationId === null)
            throw new Error("The parameter 'foreignOperationId' cannot be null.");
        else if (foreignOperationId !== undefined)
            url_ += "foreignOperationId=" + encodeURIComponent("" + foreignOperationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperDeleteNC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperDeleteNC(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processOperDeleteNC(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param foreignOperationId (optional) 
     * @param body (optional) 
     * @return Success
     */
    operDeleteExtras(foreignOperationId: number | undefined, body: ForeignOperationDto | undefined): Observable<ForeignOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/OperDeleteExtras?";
        if (foreignOperationId === null)
            throw new Error("The parameter 'foreignOperationId' cannot be null.");
        else if (foreignOperationId !== undefined)
            url_ += "foreignOperationId=" + encodeURIComponent("" + foreignOperationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperDeleteExtras(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperDeleteExtras(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForeignOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForeignOperationDto>;
        }));
    }

    protected processOperDeleteExtras(response: HttpResponseBase): Observable<ForeignOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForeignOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForeignOperationDto>(null as any);
    }

    /**
     * @param paymentOrderId (optional) 
     * @param body (optional) 
     * @return Success
     */
    checkPaymentOrderForFgnOperDetail(paymentOrderId: number | undefined, body: ForeignOperationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperation/CheckPaymentOrderForFgnOperDetail?";
        if (paymentOrderId === null)
            throw new Error("The parameter 'paymentOrderId' cannot be null.");
        else if (paymentOrderId !== undefined)
            url_ += "paymentOrderId=" + encodeURIComponent("" + paymentOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPaymentOrderForFgnOperDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPaymentOrderForFgnOperDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckPaymentOrderForFgnOperDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ForeignOperationDictionaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param foDictionaryId (optional) 
     * @return Success
     */
    deleteFODictionary(foDictionaryId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperationDictionary/DeleteFODictionary?";
        if (foDictionaryId === null)
            throw new Error("The parameter 'foDictionaryId' cannot be null.");
        else if (foDictionaryId !== undefined)
            url_ += "foDictionaryId=" + encodeURIComponent("" + foDictionaryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFODictionary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFODictionary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFODictionary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param foDictionaryId (optional) 
     * @return Success
     */
    fODictionaryEdit(foDictionaryId: number | undefined): Observable<FODictionaryEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperationDictionary/FODictionaryEdit?";
        if (foDictionaryId === null)
            throw new Error("The parameter 'foDictionaryId' cannot be null.");
        else if (foDictionaryId !== undefined)
            url_ += "foDictionaryId=" + encodeURIComponent("" + foDictionaryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFODictionaryEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFODictionaryEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FODictionaryEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FODictionaryEditDto>;
        }));
    }

    protected processFODictionaryEdit(response: HttpResponseBase): Observable<FODictionaryEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FODictionaryEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FODictionaryEditDto>(null as any);
    }

    /**
     * @return Success
     */
    fODictionaryListInit(): Observable<FODictionaryFormDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperationDictionary/FODictionaryListInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFODictionaryListInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFODictionaryListInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FODictionaryFormDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FODictionaryFormDto>;
        }));
    }

    protected processFODictionaryListInit(response: HttpResponseBase): Observable<FODictionaryFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FODictionaryFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FODictionaryFormDto>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    fODictionarySearch(search: string | null | undefined): Observable<FODictionaryFormDto> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperationDictionary/FODictionarySearch?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFODictionarySearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFODictionarySearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FODictionaryFormDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FODictionaryFormDto>;
        }));
    }

    protected processFODictionarySearch(response: HttpResponseBase): Observable<FODictionaryFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FODictionaryFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FODictionaryFormDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveFODictionary(body: FODictionaryEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ForeignOperationDictionary/SaveFODictionary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFODictionary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFODictionary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveFODictionary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class GarantieServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    garantieListId(imprumutId: number | undefined): Observable<GarantieDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Garantie/GarantieListId?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGarantieListId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGarantieListId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GarantieDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GarantieDto[]>;
        }));
    }

    protected processGarantieListId(response: HttpResponseBase): Observable<GarantieDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GarantieDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GarantieDto[]>(null as any);
    }

    /**
     * @return Success
     */
    garantieList(): Observable<GarantieDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Garantie/GarantieList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGarantieList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGarantieList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GarantieDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GarantieDto[]>;
        }));
    }

    protected processGarantieList(response: HttpResponseBase): Observable<GarantieDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GarantieDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GarantieDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGarantieId(id: number | undefined): Observable<GarantieEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Garantie/GetGarantieId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGarantieId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGarantieId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GarantieEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GarantieEditDto>;
        }));
    }

    protected processGetGarantieId(response: HttpResponseBase): Observable<GarantieEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarantieEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GarantieEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveGarantie(body: GarantieEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Garantie/SaveGarantie";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveGarantie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveGarantie(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveGarantie(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteGarantie(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Garantie/DeleteGarantie?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGarantie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGarantie(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteGarantie(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveOperatieGarantie(body: OperatieGarantieDto | undefined): Observable<OperatieGarantieDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Garantie/SaveOperatieGarantie";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOperatieGarantie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOperatieGarantie(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperatieGarantieDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperatieGarantieDto[]>;
        }));
    }

    protected processSaveOperatieGarantie(response: HttpResponseBase): Observable<OperatieGarantieDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperatieGarantieDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperatieGarantieDto[]>(null as any);
    }

    /**
     * @param operatieGarantieId (optional) 
     * @return Success
     */
    deleteOperatieGarantie(operatieGarantieId: number | undefined): Observable<OperatieGarantieDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Garantie/DeleteOperatieGarantie?";
        if (operatieGarantieId === null)
            throw new Error("The parameter 'operatieGarantieId' cannot be null.");
        else if (operatieGarantieId !== undefined)
            url_ += "operatieGarantieId=" + encodeURIComponent("" + operatieGarantieId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperatieGarantie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperatieGarantie(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperatieGarantieDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperatieGarantieDto[]>;
        }));
    }

    protected processDeleteOperatieGarantie(response: HttpResponseBase): Observable<OperatieGarantieDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperatieGarantieDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperatieGarantieDto[]>(null as any);
    }

    /**
     * @param garantieId (optional) 
     * @return Success
     */
    getOperatieGarantieList(garantieId: number | undefined): Observable<OperatieGarantieDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Garantie/getOperatieGarantieList?";
        if (garantieId === null)
            throw new Error("The parameter 'garantieId' cannot be null.");
        else if (garantieId !== undefined)
            url_ += "garantieId=" + encodeURIComponent("" + garantieId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperatieGarantieList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperatieGarantieList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperatieGarantieDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperatieGarantieDto[]>;
        }));
    }

    protected processGetOperatieGarantieList(response: HttpResponseBase): Observable<OperatieGarantieDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperatieGarantieDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperatieGarantieDto[]>(null as any);
    }

    /**
     * @param garantieId (optional) 
     * @return Success
     */
    getSoldGarantie(garantieId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Garantie/getSoldGarantie?";
        if (garantieId === null)
            throw new Error("The parameter 'garantieId' cannot be null.");
        else if (garantieId !== undefined)
            url_ += "garantieId=" + encodeURIComponent("" + garantieId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoldGarantie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoldGarantie(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetSoldGarantie(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class GarantieCeGaranteazaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    garantieCeGaranteazaList(): Observable<GarantieCeGaranteazaDto[]> {
        let url_ = this.baseUrl + "/api/services/app/GarantieCeGaranteaza/GarantieCeGaranteazaList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGarantieCeGaranteazaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGarantieCeGaranteazaList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GarantieCeGaranteazaDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GarantieCeGaranteazaDto[]>;
        }));
    }

    protected processGarantieCeGaranteazaList(response: HttpResponseBase): Observable<GarantieCeGaranteazaDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GarantieCeGaranteazaDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GarantieCeGaranteazaDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGarantieCeGaranteazaId(id: number | undefined): Observable<GarantieCeGaranteazaEditDto> {
        let url_ = this.baseUrl + "/api/services/app/GarantieCeGaranteaza/GetGarantieCeGaranteazaId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGarantieCeGaranteazaId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGarantieCeGaranteazaId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GarantieCeGaranteazaEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GarantieCeGaranteazaEditDto>;
        }));
    }

    protected processGetGarantieCeGaranteazaId(response: HttpResponseBase): Observable<GarantieCeGaranteazaEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarantieCeGaranteazaEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GarantieCeGaranteazaEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveGarantieCeGaranteaza(body: GarantieCeGaranteazaEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GarantieCeGaranteaza/SaveGarantieCeGaranteaza";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveGarantieCeGaranteaza(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveGarantieCeGaranteaza(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveGarantieCeGaranteaza(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteGarantieCeGaranteaza(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GarantieCeGaranteaza/DeleteGarantieCeGaranteaza?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGarantieCeGaranteaza(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGarantieCeGaranteaza(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteGarantieCeGaranteaza(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class GarantieTipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    garantieTipList(): Observable<GarantieTipDto[]> {
        let url_ = this.baseUrl + "/api/services/app/GarantieTip/GarantieTipList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGarantieTipList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGarantieTipList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GarantieTipDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GarantieTipDto[]>;
        }));
    }

    protected processGarantieTipList(response: HttpResponseBase): Observable<GarantieTipDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GarantieTipDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GarantieTipDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGarantieTipId(id: number | undefined): Observable<GarantieTipEditDto> {
        let url_ = this.baseUrl + "/api/services/app/GarantieTip/GetGarantieTipId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGarantieTipId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGarantieTipId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GarantieTipEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GarantieTipEditDto>;
        }));
    }

    protected processGetGarantieTipId(response: HttpResponseBase): Observable<GarantieTipEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GarantieTipEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GarantieTipEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveGarantieTip(body: GarantieTipEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GarantieTip/SaveGarantieTip";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveGarantieTip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveGarantieTip(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveGarantieTip(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteGarantieTip(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GarantieTip/DeleteGarantieTip?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGarantieTip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGarantieTip(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteGarantieTip(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ImoAssetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    imoAssetsEntryList(dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined): Observable<GetImoAssetOutput> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/ImoAssetsEntryList?";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImoAssetsEntryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImoAssetsEntryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetImoAssetOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetImoAssetOutput>;
        }));
    }

    protected processImoAssetsEntryList(response: HttpResponseBase): Observable<GetImoAssetOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetImoAssetOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetImoAssetOutput>(null as any);
    }

    /**
     * @return Success
     */
    addFromInvoiceInit(): Observable<ImoAssetAddDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/AddFromInvoiceInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFromInvoiceInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFromInvoiceInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetAddDto>;
        }));
    }

    protected processAddFromInvoiceInit(response: HttpResponseBase): Observable<ImoAssetAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetAddDto>(null as any);
    }

    /**
     * @param formNr (optional) 
     * @param body (optional) 
     * @return Success
     */
    showForm(formNr: number | undefined, body: ImoAssetAddDto | undefined): Observable<ImoAssetAddDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/ShowForm?";
        if (formNr === null)
            throw new Error("The parameter 'formNr' cannot be null.");
        else if (formNr !== undefined)
            url_ += "formNr=" + encodeURIComponent("" + formNr) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetAddDto>;
        }));
    }

    protected processShowForm(response: HttpResponseBase): Observable<ImoAssetAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetAddDto>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param documentTypeId (optional) 
     * @param operationDate (optional) 
     * @return Success
     */
    getInvoiceDetails(invoiceId: number | null | undefined, documentTypeId: number | undefined, operationDate: moment.Moment | undefined): Observable<ImoAssetAddInvoiceDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/GetInvoiceDetails?";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' cannot be null.");
        else if (documentTypeId !== undefined)
            url_ += "documentTypeId=" + encodeURIComponent("" + documentTypeId) + "&";
        if (operationDate === null)
            throw new Error("The parameter 'operationDate' cannot be null.");
        else if (operationDate !== undefined)
            url_ += "operationDate=" + encodeURIComponent(operationDate ? "" + operationDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetAddInvoiceDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetAddInvoiceDetailDto[]>;
        }));
    }

    protected processGetInvoiceDetails(response: HttpResponseBase): Observable<ImoAssetAddInvoiceDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImoAssetAddInvoiceDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetAddInvoiceDetailDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prepareAssets(body: ImoAssetAddDto | undefined): Observable<ImoAssetAddDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/PrepareAssets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareAssets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareAssets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetAddDto>;
        }));
    }

    protected processPrepareAssets(response: HttpResponseBase): Observable<ImoAssetAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetAddDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAssets(body: ImoAssetAddDto | undefined): Observable<ImoAssetAddDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/SaveAssets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAssets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAssets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetAddDto>;
        }));
    }

    protected processSaveAssets(response: HttpResponseBase): Observable<ImoAssetAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetAddDto>(null as any);
    }

    /**
     * @param assetId (optional) 
     * @return Success
     */
    addDirectInit(assetId: number | undefined): Observable<ImoAssetAddDirectDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/AddDirectInit?";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDirectInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDirectInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetAddDirectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetAddDirectDto>;
        }));
    }

    protected processAddDirectInit(response: HttpResponseBase): Observable<ImoAssetAddDirectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetAddDirectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetAddDirectDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addDirectChangeType(body: ImoAssetAddDirectDto | undefined): Observable<ImoAssetAddDirectDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/AddDirectChangeType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDirectChangeType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDirectChangeType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetAddDirectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetAddDirectDto>;
        }));
    }

    protected processAddDirectChangeType(response: HttpResponseBase): Observable<ImoAssetAddDirectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetAddDirectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetAddDirectDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addDirectChangeDate(body: ImoAssetAddDirectDto | undefined): Observable<ImoAssetAddDirectDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/AddDirectChangeDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDirectChangeDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDirectChangeDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetAddDirectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetAddDirectDto>;
        }));
    }

    protected processAddDirectChangeDate(response: HttpResponseBase): Observable<ImoAssetAddDirectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetAddDirectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetAddDirectDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAssetDirect(body: ImoAssetAddDirectDto | undefined): Observable<ImoAssetAddDirectDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/SaveAssetDirect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAssetDirect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAssetDirect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetAddDirectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetAddDirectDto>;
        }));
    }

    protected processSaveAssetDirect(response: HttpResponseBase): Observable<ImoAssetAddDirectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetAddDirectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetAddDirectDto>(null as any);
    }

    /**
     * @param assetId (optional) 
     * @return Success
     */
    deleteAsset(assetId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/DeleteAsset?";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAsset(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAssetInUse(body: ImoAssetAddDirectDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/SaveAssetInUse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAssetInUse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAssetInUse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAssetInUse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addInUseChangeDate(body: ImoAssetAddDirectDto | undefined): Observable<ImoAssetAddDirectDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAsset/AddInUseChangeDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddInUseChangeDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddInUseChangeDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetAddDirectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetAddDirectDto>;
        }));
    }

    protected processAddInUseChangeDate(response: HttpResponseBase): Observable<ImoAssetAddDirectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetAddDirectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetAddDirectDto>(null as any);
    }
}

@Injectable()
export class ImoAssetClassCodeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    imoAssetClassCodeList(): Observable<GetImoAssetClassCodeOutput> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetClassCode/ImoAssetClassCodeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImoAssetClassCodeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImoAssetClassCodeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetImoAssetClassCodeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetImoAssetClassCodeOutput>;
        }));
    }

    protected processImoAssetClassCodeList(response: HttpResponseBase): Observable<GetImoAssetClassCodeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetImoAssetClassCodeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetImoAssetClassCodeOutput>(null as any);
    }

    /**
     * @return Success
     */
    imoAssetClassCodeListDD(): Observable<ImoAssetClassCodeListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetClassCode/ImoAssetClassCodeListDD";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImoAssetClassCodeListDD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImoAssetClassCodeListDD(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetClassCodeListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetClassCodeListDDDto[]>;
        }));
    }

    protected processImoAssetClassCodeListDD(response: HttpResponseBase): Observable<ImoAssetClassCodeListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImoAssetClassCodeListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetClassCodeListDDDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getClassCodeById(id: number | undefined): Observable<ImoAssetClassCodeEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetClassCode/GetClassCodeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassCodeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassCodeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetClassCodeEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetClassCodeEditDto>;
        }));
    }

    protected processGetClassCodeById(response: HttpResponseBase): Observable<ImoAssetClassCodeEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetClassCodeEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetClassCodeEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveClassCode(body: ImoAssetClassCodeEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetClassCode/SaveClassCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveClassCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveClassCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveClassCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteClassCode(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetClassCode/DeleteClassCode?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClassCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClassCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteClassCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ImoAssetOperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initOperList(): Observable<ImoAssetOperListDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/InitOperList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitOperList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitOperList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperListDto>;
        }));
    }

    protected processInitOperList(response: HttpResponseBase): Observable<ImoAssetOperListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    operList(body: ImoAssetOperListDto | undefined): Observable<ImoAssetOperListDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/OperList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperListDto>;
        }));
    }

    protected processOperList(response: HttpResponseBase): Observable<ImoAssetOperListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperListDto>(null as any);
    }

    /**
     * @return Success
     */
    operTypeList(): Observable<OperTypeListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/OperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperTypeListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperTypeListDto[]>;
        }));
    }

    protected processOperTypeList(response: HttpResponseBase): Observable<OperTypeListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperTypeListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperTypeListDto[]>(null as any);
    }

    /**
     * @param operTypeId (optional) 
     * @return Success
     */
    documentTypeList(operTypeId: number | null | undefined): Observable<DocumentTypeListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/DocumentTypeList?";
        if (operTypeId !== undefined && operTypeId !== null)
            url_ += "operTypeId=" + encodeURIComponent("" + operTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentTypeListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentTypeListDto[]>;
        }));
    }

    protected processDocumentTypeList(response: HttpResponseBase): Observable<DocumentTypeListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DocumentTypeListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeListDto[]>(null as any);
    }

    /**
     * @param documentTypeId (optional) 
     * @return Success
     */
    getNextDocumentNumber(documentTypeId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/GetNextDocumentNumber?";
        if (documentTypeId !== undefined && documentTypeId !== null)
            url_ += "documentTypeId=" + encodeURIComponent("" + documentTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextDocumentNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextDocumentNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetNextDocumentNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param formNr (optional) 
     * @param body (optional) 
     * @return Success
     */
    showFormOper(formNr: number | undefined, body: ImoAssetOperEditDto | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/ShowFormOper?";
        if (formNr === null)
            throw new Error("The parameter 'formNr' cannot be null.");
        else if (formNr !== undefined)
            url_ += "formNr=" + encodeURIComponent("" + formNr) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowFormOper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowFormOper(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processShowFormOper(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param operationId (optional) 
     * @return Success
     */
    initOperation(operationId: number | null | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/InitOperation?";
        if (operationId !== undefined && operationId !== null)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processInitOperation(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeOperation(body: ImoAssetOperEditDto | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/ChangeOperation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processChangeOperation(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param storageId (optional) 
     * @param body (optional) 
     * @return Success
     */
    assetsDDDList(storageId: number | null | undefined, body: ImoAssetOperEditDto | undefined): Observable<ImoAssetsDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/AssetsDDDList?";
        if (storageId !== undefined && storageId !== null)
            url_ += "storageId=" + encodeURIComponent("" + storageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetsDDDList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetsDDDList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetsDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetsDDDto[]>;
        }));
    }

    protected processAssetsDDDList(response: HttpResponseBase): Observable<ImoAssetsDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImoAssetsDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetsDDDto[]>(null as any);
    }

    /**
     * @param operationType (optional) 
     * @param body (optional) 
     * @return Success
     */
    assetsDDList(operationType: number | undefined, body: ImoAssetOperEditDto | undefined): Observable<ImoAssetsDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/AssetsDDList?";
        if (operationType === null)
            throw new Error("The parameter 'operationType' cannot be null.");
        else if (operationType !== undefined)
            url_ += "operationType=" + encodeURIComponent("" + operationType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetsDDList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetsDDList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetsDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetsDDDto[]>;
        }));
    }

    protected processAssetsDDList(response: HttpResponseBase): Observable<ImoAssetsDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImoAssetsDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetsDDDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    initDetails(body: ImoAssetOperEditDto | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/InitDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processInitDetails(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param idOrd (optional) 
     * @param body (optional) 
     * @return Success
     */
    detailChangeAsset(idOrd: number | undefined, body: ImoAssetOperEditDto | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/DetailChangeAsset?";
        if (idOrd === null)
            throw new Error("The parameter 'idOrd' cannot be null.");
        else if (idOrd !== undefined)
            url_ += "idOrd=" + encodeURIComponent("" + idOrd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailChangeAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailChangeAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processDetailChangeAsset(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRow(body: ImoAssetOperEditDto | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/AddRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processAddRow(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param idOrd (optional) 
     * @param body (optional) 
     * @return Success
     */
    operDeleteRow(idOrd: number | undefined, body: ImoAssetOperEditDto | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/OperDeleteRow?";
        if (idOrd === null)
            throw new Error("The parameter 'idOrd' cannot be null.");
        else if (idOrd !== undefined)
            url_ += "IdOrd=" + encodeURIComponent("" + idOrd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperDeleteRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperDeleteRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processOperDeleteRow(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    summary(body: ImoAssetOperEditDto | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/Summary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveOperation(body: ImoAssetOperEditDto | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/SaveOperation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processSaveOperation(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param operationId (optional) 
     * @return Success
     */
    deleteOperation(operationId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/DeleteOperation?";
        if (operationId === null)
            throw new Error("The parameter 'operationId' cannot be null.");
        else if (operationId !== undefined)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOperation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param operationId (optional) 
     * @return Success
     */
    viewOperation(operationId: number | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/ViewOperation?";
        if (operationId === null)
            throw new Error("The parameter 'operationId' cannot be null.");
        else if (operationId !== undefined)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processViewOperation(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param idOrd (optional) 
     * @param body (optional) 
     * @return Success
     */
    detailAccountAsset(idOrd: number | undefined, body: ImoAssetOperEditDto | undefined): Observable<ImoAssetOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/DetailAccountAsset?";
        if (idOrd === null)
            throw new Error("The parameter 'idOrd' cannot be null.");
        else if (idOrd !== undefined)
            url_ += "idOrd=" + encodeURIComponent("" + idOrd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailAccountAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailAccountAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperEditDto>;
        }));
    }

    protected processDetailAccountAsset(response: HttpResponseBase): Observable<ImoAssetOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    upateImoAssetAccounts(body: ImoAssetOperEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOper/UpateImoAssetAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpateImoAssetAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpateImoAssetAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpateImoAssetAccounts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ImoAssetOperDocTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    operDocTypeList(): Observable<GetImoAssetOperDocTypeOutput> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOperDocType/OperDocTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperDocTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperDocTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetImoAssetOperDocTypeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetImoAssetOperDocTypeOutput>;
        }));
    }

    protected processOperDocTypeList(response: HttpResponseBase): Observable<GetImoAssetOperDocTypeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetImoAssetOperDocTypeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetImoAssetOperDocTypeOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOperDocTypeById(id: number | undefined): Observable<ImoAssetOperDocTypeEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOperDocType/GetOperDocTypeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperDocTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperDocTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetOperDocTypeEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetOperDocTypeEditDto>;
        }));
    }

    protected processGetOperDocTypeById(response: HttpResponseBase): Observable<ImoAssetOperDocTypeEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetOperDocTypeEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetOperDocTypeEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveOperDocType(body: ImoAssetOperDocTypeEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOperDocType/SaveOperDocType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOperDocType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOperDocType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveOperDocType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOperDocType(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetOperDocType/DeleteOperDocType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperDocType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperDocType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOperDocType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ImoAssetSetupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initForm(): Observable<ImoAssetSetupDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetSetup/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetSetupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetSetupDto>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<ImoAssetSetupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetSetupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetSetupDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveSetup(body: ImoAssetSetupDto | undefined): Observable<ImoAssetSetupDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetSetup/SaveSetup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSetup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetSetupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetSetupDto>;
        }));
    }

    protected processSaveSetup(response: HttpResponseBase): Observable<ImoAssetSetupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetSetupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetSetupDto>(null as any);
    }
}

@Injectable()
export class ImoAssetStorageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    imoAssetStorageList(): Observable<GetImoAssetStorageOutput> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetStorage/ImoAssetStorageList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImoAssetStorageList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImoAssetStorageList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetImoAssetStorageOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetImoAssetStorageOutput>;
        }));
    }

    protected processImoAssetStorageList(response: HttpResponseBase): Observable<GetImoAssetStorageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetImoAssetStorageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetImoAssetStorageOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStorageById(id: number | undefined): Observable<ImoAssetStorageDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetStorage/GetStorageById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetStorageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetStorageDto>;
        }));
    }

    protected processGetStorageById(response: HttpResponseBase): Observable<ImoAssetStorageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetStorageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetStorageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveStorage(body: ImoAssetStorageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetStorage/SaveStorage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStorage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteStorage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoAssetStorage/DeleteStorage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStorage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ImoGestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initForm(): Observable<ImoGestListDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoGestListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoGestListDto>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<ImoGestListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoGestListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoGestListDto>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    assetListDD(dataStart: moment.Moment | null | undefined, dataEnd: moment.Moment | null | undefined): Observable<ImoAssetsDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/AssetListDD?";
        if (dataStart !== undefined && dataStart !== null)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd !== undefined && dataEnd !== null)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetListDD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetListDD(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetsDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetsDDDto[]>;
        }));
    }

    protected processAssetListDD(response: HttpResponseBase): Observable<ImoAssetsDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImoAssetsDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetsDDDto[]>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    storageListDD(dataStart: moment.Moment | null | undefined, dataEnd: moment.Moment | null | undefined): Observable<ImoAssetStorageDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/StorageListDD?";
        if (dataStart !== undefined && dataStart !== null)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd !== undefined && dataEnd !== null)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStorageListDD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStorageListDD(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetStorageDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetStorageDDDto[]>;
        }));
    }

    protected processStorageListDD(response: HttpResponseBase): Observable<ImoAssetStorageDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImoAssetStorageDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetStorageDDDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    serchGest(body: ImoGestListDto | undefined): Observable<ImoGestListDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/SerchGest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSerchGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSerchGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoGestListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoGestListDto>;
        }));
    }

    protected processSerchGest(response: HttpResponseBase): Observable<ImoGestListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoGestListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoGestListDto>(null as any);
    }

    /**
     * @return Success
     */
    initFormCompute(): Observable<ImoGestComputeListDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/InitFormCompute";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitFormCompute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitFormCompute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoGestComputeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoGestComputeListDto>;
        }));
    }

    protected processInitFormCompute(response: HttpResponseBase): Observable<ImoGestComputeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoGestComputeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoGestComputeListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    serchComputeOper(body: ImoGestComputeListDto | undefined): Observable<ImoGestComputeListDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/SerchComputeOper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSerchComputeOper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSerchComputeOper(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoGestComputeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoGestComputeListDto>;
        }));
    }

    protected processSerchComputeOper(response: HttpResponseBase): Observable<ImoGestComputeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoGestComputeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoGestComputeListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    computeDateGest(body: ImoGestComputeListDto | undefined): Observable<ImoGestComputeListDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/ComputeDateGest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComputeDateGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComputeDateGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoGestComputeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoGestComputeListDto>;
        }));
    }

    protected processComputeDateGest(response: HttpResponseBase): Observable<ImoGestComputeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoGestComputeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoGestComputeListDto>(null as any);
    }

    /**
     * @return Success
     */
    initFormDel(): Observable<ImoGestDelListDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/InitFormDel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitFormDel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitFormDel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoGestDelListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoGestDelListDto>;
        }));
    }

    protected processInitFormDel(response: HttpResponseBase): Observable<ImoGestDelListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoGestDelListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoGestDelListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    serchDateGest(body: ImoGestDelListDto | undefined): Observable<ImoGestDelListDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/SerchDateGest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSerchDateGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSerchDateGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoGestDelListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoGestDelListDto>;
        }));
    }

    protected processSerchDateGest(response: HttpResponseBase): Observable<ImoGestDelListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoGestDelListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoGestDelListDto>(null as any);
    }

    /**
     * @param deleteDate (optional) 
     * @return Success
     */
    deleteDateGest(deleteDate: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/DeleteDateGest?";
        if (deleteDate === null)
            throw new Error("The parameter 'deleteDate' cannot be null.");
        else if (deleteDate !== undefined)
            url_ += "deleteDate=" + encodeURIComponent(deleteDate ? "" + deleteDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDateGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDateGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDateGest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param assetId (optional) 
     * @param gestDate (optional) 
     * @return Success
     */
    getGestDetailForAsset(assetId: number | undefined, gestDate: moment.Moment | undefined): Observable<ImoGestRowDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoGest/GetGestDetailForAsset?";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&";
        if (gestDate === null)
            throw new Error("The parameter 'gestDate' cannot be null.");
        else if (gestDate !== undefined)
            url_ += "gestDate=" + encodeURIComponent(gestDate ? "" + gestDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGestDetailForAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGestDetailForAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoGestRowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoGestRowDto>;
        }));
    }

    protected processGetGestDetailForAsset(response: HttpResponseBase): Observable<ImoGestRowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoGestRowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoGestRowDto>(null as any);
    }
}

@Injectable()
export class ImoInventariereServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initForm(): Observable<ImoInventariereInitDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoInventariere/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoInventariereInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoInventariereInitDto>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<ImoInventariereInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoInventariereInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoInventariereInitDto>(null as any);
    }

    /**
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @return Success
     */
    searchImoInventariere(dateStart: moment.Moment | undefined, dateEnd: moment.Moment | undefined): Observable<ImoInventariereListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoInventariere/SearchImoInventariere?";
        if (dateStart === null)
            throw new Error("The parameter 'dateStart' cannot be null.");
        else if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toISOString() : "") + "&";
        if (dateEnd === null)
            throw new Error("The parameter 'dateEnd' cannot be null.");
        else if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchImoInventariere(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchImoInventariere(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoInventariereListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoInventariereListDto[]>;
        }));
    }

    protected processSearchImoInventariere(response: HttpResponseBase): Observable<ImoInventariereListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImoInventariereListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoInventariereListDto[]>(null as any);
    }

    /**
     * @param imoInvId (optional) 
     * @param operationDate (optional) 
     * @return Success
     */
    getImoInvDetail(imoInvId: number | undefined, operationDate: moment.Moment | undefined): Observable<ImoInventariereDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoInventariere/GetImoInvDetail?";
        if (imoInvId === null)
            throw new Error("The parameter 'imoInvId' cannot be null.");
        else if (imoInvId !== undefined)
            url_ += "imoInvId=" + encodeURIComponent("" + imoInvId) + "&";
        if (operationDate === null)
            throw new Error("The parameter 'operationDate' cannot be null.");
        else if (operationDate !== undefined)
            url_ += "operationDate=" + encodeURIComponent(operationDate ? "" + operationDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImoInvDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImoInvDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoInventariereDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoInventariereDetailDto[]>;
        }));
    }

    protected processGetImoInvDetail(response: HttpResponseBase): Observable<ImoInventariereDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImoInventariereDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoInventariereDetailDto[]>(null as any);
    }

    /**
     * @param imoInvId (optional) 
     * @return Success
     */
    getImoInventariere(imoInvId: number | null | undefined): Observable<ImoInventariereEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImoInventariere/GetImoInventariere?";
        if (imoInvId !== undefined && imoInvId !== null)
            url_ += "imoInvId=" + encodeURIComponent("" + imoInvId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImoInventariere(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImoInventariere(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoInventariereEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoInventariereEditDto>;
        }));
    }

    protected processGetImoInventariere(response: HttpResponseBase): Observable<ImoInventariereEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoInventariereEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoInventariereEditDto>(null as any);
    }

    /**
     * @param dateStart (optional) 
     * @return Success
     */
    searchComputeImoInv(dateStart: moment.Moment | undefined): Observable<ImoInventariereDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoInventariere/SearchComputeImoInv?";
        if (dateStart === null)
            throw new Error("The parameter 'dateStart' cannot be null.");
        else if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchComputeImoInv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchComputeImoInv(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoInventariereDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoInventariereDetailDto[]>;
        }));
    }

    protected processSearchComputeImoInv(response: HttpResponseBase): Observable<ImoInventariereDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImoInventariereDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoInventariereDetailDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveImoInv(body: ImoInventariereEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoInventariere/SaveImoInv";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveImoInv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveImoInv(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveImoInv(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imoInvId (optional) 
     * @return Success
     */
    deleteImoInventariere(imoInvId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImoInventariere/DeleteImoInventariere?";
        if (imoInvId === null)
            throw new Error("The parameter 'imoInvId' cannot be null.");
        else if (imoInvId !== undefined)
            url_ += "imoInvId=" + encodeURIComponent("" + imoInvId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImoInventariere(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImoInventariere(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteImoInventariere(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    imoOperDateList(): Observable<InventoryDDList[]> {
        let url_ = this.baseUrl + "/api/services/app/ImoInventariere/ImoOperDateList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImoOperDateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImoOperDateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDDList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDDList[]>;
        }));
    }

    protected processImoOperDateList(response: HttpResponseBase): Observable<InventoryDDList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InventoryDDList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryDDList[]>(null as any);
    }
}

@Injectable()
export class ImprumutServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    imprumutList(): Observable<ImprumutDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/ImprumutList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumutList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumutList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumutDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumutDto[]>;
        }));
    }

    protected processImprumutList(response: HttpResponseBase): Observable<ImprumutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImprumutDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumutDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    imprumutId(id: number | undefined): Observable<ImprumutDto> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/ImprumutId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumutId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumutId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumutDto>;
        }));
    }

    protected processImprumutId(response: HttpResponseBase): Observable<ImprumutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImprumutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumutDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getImprumutId(id: number | undefined): Observable<ImprumutEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/GetImprumutId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImprumutId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImprumutId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumutEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumutEditDto>;
        }));
    }

    protected processGetImprumutId(response: HttpResponseBase): Observable<ImprumutEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImprumutEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumutEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateRateOrientativeRataDescrescatoare(body: Imprumut | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/GenerateRateOrientativeRataDescrescatoare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateRateOrientativeRataDescrescatoare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateRateOrientativeRataDescrescatoare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateRateOrientativeRataDescrescatoare(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateRateOrientativeRataTotalaEgala(body: Imprumut | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/GenerateRateOrientativeRataTotalaEgala";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateRateOrientativeRataTotalaEgala(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateRateOrientativeRataTotalaEgala(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateRateOrientativeRataTotalaEgala(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adaugaStateInitial(body: ImprumutEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/AdaugaStateInitial";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdaugaStateInitial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdaugaStateInitial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdaugaStateInitial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveImprumut(body: ImprumutEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/SaveImprumut";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveImprumut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveImprumut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveImprumut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateTragereInitiala(body: Imprumut | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/GenerateTragereInitiala";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateTragereInitiala(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateTragereInitiala(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateTragereInitiala(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRateVariabileId(body: Imprumut | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/UpdateRateVariabileId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRateVariabileId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRateVariabileId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateRateVariabileId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    updateRateVariabile(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/UpdateRateVariabile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRateVariabile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRateVariabile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateRateVariabile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDateComisionRate(body: Imprumut | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/UpdateDateComisionRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDateComisionRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDateComisionRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDateComisionRate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    deleteDateComisionId(imprumutId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/DeleteDateComisionId?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDateComisionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDateComisionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDateComisionId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    deleteAllRateId(imprumutId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/DeleteAllRateId?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllRateId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllRateId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllRateId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    deleteAllRateOnEdit(imprumutId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/DeleteAllRateOnEdit?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllRateOnEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllRateOnEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllRateOnEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteImprumut(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/DeleteImprumut?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImprumut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImprumut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteImprumut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    imprumutStateList(imprumutId: number | undefined): Observable<ImprumutStateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/ImprumutStateList?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumutStateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumutStateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumutStateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumutStateDto[]>;
        }));
    }

    protected processImprumutStateList(response: HttpResponseBase): Observable<ImprumutStateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImprumutStateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumutStateDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveImprumutStateList(body: ImprumutStateDto | undefined): Observable<ImprumutStateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/SaveImprumutStateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveImprumutStateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveImprumutStateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumutStateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumutStateDto[]>;
        }));
    }

    protected processSaveImprumutStateList(response: HttpResponseBase): Observable<ImprumutStateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImprumutStateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumutStateDto[]>(null as any);
    }

    /**
     * @param imprumutDocumentNumber (optional) 
     * @return Success
     */
    deleteAllOperationsDocNum(imprumutDocumentNumber: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/DeleteAllOperationsDocNum?";
        if (imprumutDocumentNumber !== undefined && imprumutDocumentNumber !== null)
            url_ += "imprumutDocumentNumber=" + encodeURIComponent("" + imprumutDocumentNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllOperationsDocNum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllOperationsDocNum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllOperationsDocNum(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    deleteAllImprumutState(imprumutId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Imprumut/DeleteAllImprumutState?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllImprumutState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllImprumutState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllImprumutState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ImprumuturiTermenServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    imprumuturiTermenList(): Observable<ImprumuturiTermenDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTermen/ImprumuturiTermenList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumuturiTermenList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumuturiTermenList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumuturiTermenDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumuturiTermenDto[]>;
        }));
    }

    protected processImprumuturiTermenList(response: HttpResponseBase): Observable<ImprumuturiTermenDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImprumuturiTermenDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumuturiTermenDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTermenId(id: number | undefined): Observable<ImprumuturiTermenEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTermen/GetTermenId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTermenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTermenId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumuturiTermenEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumuturiTermenEditDto>;
        }));
    }

    protected processGetTermenId(response: HttpResponseBase): Observable<ImprumuturiTermenEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImprumuturiTermenEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumuturiTermenEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveTermen(body: ImprumuturiTermenEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTermen/SaveTermen";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTermen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTermen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveTermen(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTermen(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTermen/DeleteTermen?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTermen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTermen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTermen(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ImprumuturiTipuriServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    imprumuturiTipuriList(): Observable<ImprumuturiTipuriDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTipuri/ImprumuturiTipuriList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumuturiTipuriList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumuturiTipuriList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumuturiTipuriDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumuturiTipuriDto[]>;
        }));
    }

    protected processImprumuturiTipuriList(response: HttpResponseBase): Observable<ImprumuturiTipuriDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImprumuturiTipuriDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumuturiTipuriDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTipId(id: number | undefined): Observable<ImprumuturiTipuriEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTipuri/GetTipId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTipId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTipId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumuturiTipuriEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumuturiTipuriEditDto>;
        }));
    }

    protected processGetTipId(response: HttpResponseBase): Observable<ImprumuturiTipuriEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImprumuturiTipuriEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumuturiTipuriEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveTip(body: ImprumuturiTipuriEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTipuri/SaveTip";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTip(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveTip(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTip(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTipuri/DeleteTip?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTip(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTip(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imprumutTipId (optional) 
     * @return Success
     */
    imprumutTipDetaliiList(imprumutTipId: number | undefined): Observable<ImprumutTipDetaliuDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTipuri/ImprumutTipDetaliiList?";
        if (imprumutTipId === null)
            throw new Error("The parameter 'imprumutTipId' cannot be null.");
        else if (imprumutTipId !== undefined)
            url_ += "imprumutTipId=" + encodeURIComponent("" + imprumutTipId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImprumutTipDetaliiList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImprumutTipDetaliiList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumutTipDetaliuDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumutTipDetaliuDto[]>;
        }));
    }

    protected processImprumutTipDetaliiList(response: HttpResponseBase): Observable<ImprumutTipDetaliuDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ImprumutTipDetaliuDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumutTipDetaliuDto[]>(null as any);
    }

    /**
     * @param imprumutTipDetaliuId (optional) 
     * @return Success
     */
    deleteImprumutTipDetaliu(imprumutTipDetaliuId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTipuri/DeleteImprumutTipDetaliu?";
        if (imprumutTipDetaliuId === null)
            throw new Error("The parameter 'imprumutTipDetaliuId' cannot be null.");
        else if (imprumutTipDetaliuId !== undefined)
            url_ += "imprumutTipDetaliuId=" + encodeURIComponent("" + imprumutTipDetaliuId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImprumutTipDetaliu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImprumutTipDetaliu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteImprumutTipDetaliu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveImprumutTipDetaliu(body: ImprumutTipDetaliuEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTipuri/SaveImprumutTipDetaliu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveImprumutTipDetaliu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveImprumutTipDetaliu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveImprumutTipDetaliu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imprumutTipDetaliuId (optional) 
     * @param imprumutTipId (optional) 
     * @return Success
     */
    getImprumutTipDetaliuId(imprumutTipDetaliuId: number | undefined, imprumutTipId: number | undefined): Observable<ImprumutTipDetaliuEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ImprumuturiTipuri/GetImprumutTipDetaliuId?";
        if (imprumutTipDetaliuId === null)
            throw new Error("The parameter 'imprumutTipDetaliuId' cannot be null.");
        else if (imprumutTipDetaliuId !== undefined)
            url_ += "imprumutTipDetaliuId=" + encodeURIComponent("" + imprumutTipDetaliuId) + "&";
        if (imprumutTipId === null)
            throw new Error("The parameter 'imprumutTipId' cannot be null.");
        else if (imprumutTipId !== undefined)
            url_ += "imprumutTipId=" + encodeURIComponent("" + imprumutTipId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImprumutTipDetaliuId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImprumutTipDetaliuId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImprumutTipDetaliuEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImprumutTipDetaliuEditDto>;
        }));
    }

    protected processGetImprumutTipDetaliuId(response: HttpResponseBase): Observable<ImprumutTipDetaliuEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImprumutTipDetaliuEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImprumutTipDetaliuEditDto>(null as any);
    }
}

@Injectable()
export class InvObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    invObjectsList(dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined): Observable<GetInvObjectOutput> {
        let url_ = this.baseUrl + "/api/services/app/InvObject/InvObjectsList?";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvObjectsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvObjectsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInvObjectOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInvObjectOutput>;
        }));
    }

    protected processInvObjectsList(response: HttpResponseBase): Observable<GetInvObjectOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvObjectOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvObjectOutput>(null as any);
    }

    /**
     * @return Success
     */
    addFromInvoiceInit(): Observable<InvObjectAddDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObject/AddFromInvoiceInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFromInvoiceInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFromInvoiceInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectAddDto>;
        }));
    }

    protected processAddFromInvoiceInit(response: HttpResponseBase): Observable<InvObjectAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectAddDto>(null as any);
    }

    /**
     * @param invObjectId (optional) 
     * @return Success
     */
    addDirectInit(invObjectId: number | undefined): Observable<InvObjectAddDirectDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObject/AddDirectInit?";
        if (invObjectId === null)
            throw new Error("The parameter 'invObjectId' cannot be null.");
        else if (invObjectId !== undefined)
            url_ += "invObjectId=" + encodeURIComponent("" + invObjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDirectInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDirectInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectAddDirectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectAddDirectDto>;
        }));
    }

    protected processAddDirectInit(response: HttpResponseBase): Observable<InvObjectAddDirectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectAddDirectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectAddDirectDto>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param documentTypeId (optional) 
     * @param operationDate (optional) 
     * @return Success
     */
    getInvoiceDetails(invoiceId: number | null | undefined, documentTypeId: number | undefined, operationDate: moment.Moment | undefined): Observable<InvObjectAddInvoiceDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObject/GetInvoiceDetails?";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' cannot be null.");
        else if (documentTypeId !== undefined)
            url_ += "documentTypeId=" + encodeURIComponent("" + documentTypeId) + "&";
        if (operationDate === null)
            throw new Error("The parameter 'operationDate' cannot be null.");
        else if (operationDate !== undefined)
            url_ += "operationDate=" + encodeURIComponent(operationDate ? "" + operationDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectAddInvoiceDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectAddInvoiceDetailDto[]>;
        }));
    }

    protected processGetInvoiceDetails(response: HttpResponseBase): Observable<InvObjectAddInvoiceDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvObjectAddInvoiceDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectAddInvoiceDetailDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prepareInvObjects(body: InvObjectAddDto | undefined): Observable<InvObjectAddDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObject/PrepareInvObjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareInvObjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareInvObjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectAddDto>;
        }));
    }

    protected processPrepareInvObjects(response: HttpResponseBase): Observable<InvObjectAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectAddDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveObjectDirect(body: InvObjectAddDirectDto | undefined): Observable<InvObjectAddDirectDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObject/SaveObjectDirect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveObjectDirect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveObjectDirect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectAddDirectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectAddDirectDto>;
        }));
    }

    protected processSaveObjectDirect(response: HttpResponseBase): Observable<InvObjectAddDirectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectAddDirectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectAddDirectDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveObject(body: InvObjectAddDto | undefined): Observable<InvObjectAddDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObject/SaveObject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveObject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectAddDto>;
        }));
    }

    protected processSaveObject(response: HttpResponseBase): Observable<InvObjectAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectAddDto>(null as any);
    }

    /**
     * @param invObjectId (optional) 
     * @return Success
     */
    deleteInvObject(invObjectId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObject/DeleteInvObject?";
        if (invObjectId === null)
            throw new Error("The parameter 'invObjectId' cannot be null.");
        else if (invObjectId !== undefined)
            url_ += "invObjectId=" + encodeURIComponent("" + invObjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvObject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvObject(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class InvObjectCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    categoryList(): Observable<GetInvCategoryOutput> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectCategory/CategoryList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInvCategoryOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInvCategoryOutput>;
        }));
    }

    protected processCategoryList(response: HttpResponseBase): Observable<GetInvCategoryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvCategoryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvCategoryOutput>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @return Success
     */
    deleteCategory(categoryId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectCategory/DeleteCategory?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @return Success
     */
    getCategory(categoryId: number | undefined): Observable<InvObjectCategoryEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectCategory/GetCategory?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectCategoryEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectCategoryEditDto>;
        }));
    }

    protected processGetCategory(response: HttpResponseBase): Observable<InvObjectCategoryEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectCategoryEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectCategoryEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCategory(body: InvObjectCategoryEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectCategory/SaveCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class InvObjectGestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initForm(): Observable<InvObjectGestListDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectGest/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectGestListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectGestListDto>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<InvObjectGestListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectGestListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectGestListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchGest(body: InvObjectGestListDto | undefined): Observable<InvObjectGestListDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectGest/SearchGest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectGestListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectGestListDto>;
        }));
    }

    protected processSearchGest(response: HttpResponseBase): Observable<InvObjectGestListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectGestListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectGestListDto>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    invObjectListDD(dataStart: moment.Moment | null | undefined, dataEnd: moment.Moment | null | undefined): Observable<InvObjectListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectGest/InvObjectListDD?";
        if (dataStart !== undefined && dataStart !== null)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd !== undefined && dataEnd !== null)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvObjectListDD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvObjectListDD(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectListDto[]>;
        }));
    }

    protected processInvObjectListDD(response: HttpResponseBase): Observable<InvObjectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvObjectListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectListDto[]>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    storageListDD(dataStart: moment.Moment | null | undefined, dataEnd: moment.Moment | null | undefined): Observable<InvObjectStorageDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectGest/StorageListDD?";
        if (dataStart !== undefined && dataStart !== null)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd !== undefined && dataEnd !== null)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStorageListDD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStorageListDD(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectStorageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectStorageDto[]>;
        }));
    }

    protected processStorageListDD(response: HttpResponseBase): Observable<InvObjectStorageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvObjectStorageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectStorageDto[]>(null as any);
    }

    /**
     * @return Success
     */
    initFormCompute(): Observable<InvObjectGestComputeListDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectGest/InitFormCompute";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitFormCompute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitFormCompute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectGestComputeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectGestComputeListDto>;
        }));
    }

    protected processInitFormCompute(response: HttpResponseBase): Observable<InvObjectGestComputeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectGestComputeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectGestComputeListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCompute(body: InvObjectGestComputeListDto | undefined): Observable<InvObjectGestComputeListDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectGest/SearchCompute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchCompute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchCompute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectGestComputeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectGestComputeListDto>;
        }));
    }

    protected processSearchCompute(response: HttpResponseBase): Observable<InvObjectGestComputeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectGestComputeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectGestComputeListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    computeGest(body: InvObjectGestComputeListDto | undefined): Observable<InvObjectGestComputeListDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectGest/ComputeGest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComputeGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComputeGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectGestComputeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectGestComputeListDto>;
        }));
    }

    protected processComputeGest(response: HttpResponseBase): Observable<InvObjectGestComputeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectGestComputeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectGestComputeListDto>(null as any);
    }

    /**
     * @return Success
     */
    initFormDel(): Observable<InvObjectDelListDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectGest/InitFormDel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitFormDel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitFormDel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectDelListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectDelListDto>;
        }));
    }

    protected processInitFormDel(response: HttpResponseBase): Observable<InvObjectDelListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectDelListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectDelListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchGestDel(body: InvObjectDelListDto | undefined): Observable<InvObjectDelListDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectGest/SearchGestDel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchGestDel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchGestDel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectDelListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectDelListDto>;
        }));
    }

    protected processSearchGestDel(response: HttpResponseBase): Observable<InvObjectDelListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectDelListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectDelListDto>(null as any);
    }

    /**
     * @param deleteDate (optional) 
     * @return Success
     */
    deleteGest(deleteDate: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectGest/DeleteGest?";
        if (deleteDate === null)
            throw new Error("The parameter 'deleteDate' cannot be null.");
        else if (deleteDate !== undefined)
            url_ += "deleteDate=" + encodeURIComponent(deleteDate ? "" + deleteDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteGest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class InvObjectInventariereServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    invDateList(): Observable<InventoryDDList[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectInventariere/InvDateList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvDateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvDateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDDList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDDList[]>;
        }));
    }

    protected processInvDateList(response: HttpResponseBase): Observable<InventoryDDList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InventoryDDList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryDDList[]>(null as any);
    }

    /**
     * @param invObjectId (optional) 
     * @return Success
     */
    deleteInvObjectInventariere(invObjectId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectInventariere/DeleteInvObjectInventariere?";
        if (invObjectId === null)
            throw new Error("The parameter 'invObjectId' cannot be null.");
        else if (invObjectId !== undefined)
            url_ += "invObjectId=" + encodeURIComponent("" + invObjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvObjectInventariere(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvObjectInventariere(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvObjectInventariere(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param invObjectId (optional) 
     * @return Success
     */
    getInvObjectInvetariere(invObjectId: number | null | undefined): Observable<InvObjectInventariereEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectInventariere/GetInvObjectInvetariere?";
        if (invObjectId !== undefined && invObjectId !== null)
            url_ += "invObjectId=" + encodeURIComponent("" + invObjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvObjectInvetariere(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvObjectInvetariere(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectInventariereEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectInventariereEditDto>;
        }));
    }

    protected processGetInvObjectInvetariere(response: HttpResponseBase): Observable<InvObjectInventariereEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectInventariereEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectInventariereEditDto>(null as any);
    }

    /**
     * @return Success
     */
    initForm(): Observable<InvObjectInventariereInitDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectInventariere/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectInventariereInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectInventariereInitDto>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<InvObjectInventariereInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectInventariereInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectInventariereInitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvObjectInventariere(body: InvObjectInventariereEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectInventariere/SaveInvObjectInventariere";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvObjectInventariere(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvObjectInventariere(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveInvObjectInventariere(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param dateStart (optional) 
     * @return Success
     */
    searchComputeInvObject(dateStart: moment.Moment | undefined): Observable<InvObjectInventariereDetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectInventariere/SearchComputeInvObject?";
        if (dateStart === null)
            throw new Error("The parameter 'dateStart' cannot be null.");
        else if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchComputeInvObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchComputeInvObject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectInventariereDetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectInventariereDetDto[]>;
        }));
    }

    protected processSearchComputeInvObject(response: HttpResponseBase): Observable<InvObjectInventariereDetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvObjectInventariereDetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectInventariereDetDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchInvObjects(body: InvObjectInventariereInitDto | undefined): Observable<InvObjectInventariereInitDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectInventariere/SearchInvObjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchInvObjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchInvObjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectInventariereInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectInventariereInitDto>;
        }));
    }

    protected processSearchInvObjects(response: HttpResponseBase): Observable<InvObjectInventariereInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectInventariereInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectInventariereInitDto>(null as any);
    }
}

@Injectable()
export class InvObjectOperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    invObjectDate(): Observable<InventoryDDList[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/InvObjectDate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvObjectDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvObjectDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDDList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDDList[]>;
        }));
    }

    protected processInvObjectDate(response: HttpResponseBase): Observable<InventoryDDList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InventoryDDList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryDDList[]>(null as any);
    }

    /**
     * @return Success
     */
    initOperList(): Observable<InvObjectOperListDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/InitOperList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitOperList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitOperList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperListDto>;
        }));
    }

    protected processInitOperList(response: HttpResponseBase): Observable<InvObjectOperListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    operList(body: InvObjectOperListDto | undefined): Observable<InvObjectOperListDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/OperList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperListDto>;
        }));
    }

    protected processOperList(response: HttpResponseBase): Observable<InvObjectOperListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperListDto>(null as any);
    }

    /**
     * @param operationId (optional) 
     * @return Success
     */
    deleteOperation(operationId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/DeleteOperation?";
        if (operationId === null)
            throw new Error("The parameter 'operationId' cannot be null.");
        else if (operationId !== undefined)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOperation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    operTypeList(): Observable<OperTypeListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/OperTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperTypeListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperTypeListDto[]>;
        }));
    }

    protected processOperTypeList(response: HttpResponseBase): Observable<OperTypeListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperTypeListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperTypeListDto[]>(null as any);
    }

    /**
     * @param operTypeId (optional) 
     * @return Success
     */
    documentTypeList(operTypeId: number | null | undefined): Observable<DocumentTypeListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/DocumentTypeList?";
        if (operTypeId !== undefined && operTypeId !== null)
            url_ += "operTypeId=" + encodeURIComponent("" + operTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentTypeListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentTypeListDto[]>;
        }));
    }

    protected processDocumentTypeList(response: HttpResponseBase): Observable<DocumentTypeListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DocumentTypeListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeListDto[]>(null as any);
    }

    /**
     * @param formNr (optional) 
     * @param body (optional) 
     * @return Success
     */
    showFormOper(formNr: number | undefined, body: InvObjectOperEditDto | undefined): Observable<InvObjectOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/ShowFormOper?";
        if (formNr === null)
            throw new Error("The parameter 'formNr' cannot be null.");
        else if (formNr !== undefined)
            url_ += "formNr=" + encodeURIComponent("" + formNr) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowFormOper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowFormOper(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperEditDto>;
        }));
    }

    protected processShowFormOper(response: HttpResponseBase): Observable<InvObjectOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperEditDto>(null as any);
    }

    /**
     * @param documentTypeId (optional) 
     * @return Success
     */
    getNextDocumentNumber(documentTypeId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/GetNextDocumentNumber?";
        if (documentTypeId !== undefined && documentTypeId !== null)
            url_ += "documentTypeId=" + encodeURIComponent("" + documentTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextDocumentNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextDocumentNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetNextDocumentNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param operationId (optional) 
     * @return Success
     */
    initOperation(operationId: number | null | undefined): Observable<InvObjectOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/InitOperation?";
        if (operationId !== undefined && operationId !== null)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperEditDto>;
        }));
    }

    protected processInitOperation(response: HttpResponseBase): Observable<InvObjectOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeOperation(body: InvObjectOperEditDto | undefined): Observable<InvObjectOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/ChangeOperation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperEditDto>;
        }));
    }

    protected processChangeOperation(response: HttpResponseBase): Observable<InvObjectOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperEditDto>(null as any);
    }

    /**
     * @param storageId (optional) 
     * @param body (optional) 
     * @return Success
     */
    invObjectsList(storageId: number | null | undefined, body: InvObjectOperEditDto | undefined): Observable<InvObjectsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/InvObjectsList?";
        if (storageId !== undefined && storageId !== null)
            url_ += "storageId=" + encodeURIComponent("" + storageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvObjectsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvObjectsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectsDto[]>;
        }));
    }

    protected processInvObjectsList(response: HttpResponseBase): Observable<InvObjectsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvObjectsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectsDto[]>(null as any);
    }

    /**
     * @param operationType (optional) 
     * @param body (optional) 
     * @return Success
     */
    invObjectsDtoList(operationType: number | undefined, body: InvObjectOperEditDto | undefined): Observable<InvObjectsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/InvObjectsDtoList?";
        if (operationType === null)
            throw new Error("The parameter 'operationType' cannot be null.");
        else if (operationType !== undefined)
            url_ += "operationType=" + encodeURIComponent("" + operationType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvObjectsDtoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvObjectsDtoList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectsDto[]>;
        }));
    }

    protected processInvObjectsDtoList(response: HttpResponseBase): Observable<InvObjectsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvObjectsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectsDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    initDetails(body: InvObjectOperEditDto | undefined): Observable<InvObjectOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/InitDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperEditDto>;
        }));
    }

    protected processInitDetails(response: HttpResponseBase): Observable<InvObjectOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperEditDto>(null as any);
    }

    /**
     * @param idOrd (optional) 
     * @param body (optional) 
     * @return Success
     */
    detailChangeInvObject(idOrd: number | undefined, body: InvObjectOperEditDto | undefined): Observable<InvObjectOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/DetailChangeInvObject?";
        if (idOrd === null)
            throw new Error("The parameter 'idOrd' cannot be null.");
        else if (idOrd !== undefined)
            url_ += "idOrd=" + encodeURIComponent("" + idOrd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailChangeInvObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailChangeInvObject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperEditDto>;
        }));
    }

    protected processDetailChangeInvObject(response: HttpResponseBase): Observable<InvObjectOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRow(body: InvObjectOperEditDto | undefined): Observable<InvObjectOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/AddRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperEditDto>;
        }));
    }

    protected processAddRow(response: HttpResponseBase): Observable<InvObjectOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperEditDto>(null as any);
    }

    /**
     * @param details (optional) 
     * @param idOrd (optional) 
     * @return Success
     */
    deleteRow(details: InvObjectOperDetailEditDto[] | null | undefined, idOrd: number | undefined): Observable<InvObjectOperDetailEditDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/DeleteRow?";
        if (details !== undefined && details !== null)
            details && details.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "details[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (idOrd === null)
            throw new Error("The parameter 'idOrd' cannot be null.");
        else if (idOrd !== undefined)
            url_ += "IdOrd=" + encodeURIComponent("" + idOrd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperDetailEditDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperDetailEditDto[]>;
        }));
    }

    protected processDeleteRow(response: HttpResponseBase): Observable<InvObjectOperDetailEditDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvObjectOperDetailEditDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperDetailEditDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkForDuplicateActiva(body: InvObjectOperEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/CheckForDuplicateActiva";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckForDuplicateActiva(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckForDuplicateActiva(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckForDuplicateActiva(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    summary(body: InvObjectOperEditDto | undefined): Observable<InvObjectOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/Summary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperEditDto>;
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<InvObjectOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveOperation(body: InvObjectOperEditDto | undefined): Observable<InvObjectOperEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOper/SaveOperation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperEditDto>;
        }));
    }

    protected processSaveOperation(response: HttpResponseBase): Observable<InvObjectOperEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperEditDto>(null as any);
    }
}

@Injectable()
export class InvObjectOperDocTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param operDocTypeId (optional) 
     * @return Success
     */
    deleteInvObjOperDocType(operDocTypeId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOperDocType/DeleteInvObjOperDocType?";
        if (operDocTypeId === null)
            throw new Error("The parameter 'operDocTypeId' cannot be null.");
        else if (operDocTypeId !== undefined)
            url_ += "operDocTypeId=" + encodeURIComponent("" + operDocTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvObjOperDocType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvObjOperDocType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvObjOperDocType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param operDocTypeId (optional) 
     * @return Success
     */
    getInvObjOperDocTypeById(operDocTypeId: number | undefined): Observable<InvObjectOperDocTypeEditDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOperDocType/GetInvObjOperDocTypeById?";
        if (operDocTypeId === null)
            throw new Error("The parameter 'operDocTypeId' cannot be null.");
        else if (operDocTypeId !== undefined)
            url_ += "operDocTypeId=" + encodeURIComponent("" + operDocTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvObjOperDocTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvObjOperDocTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectOperDocTypeEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectOperDocTypeEditDto>;
        }));
    }

    protected processGetInvObjOperDocTypeById(response: HttpResponseBase): Observable<InvObjectOperDocTypeEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectOperDocTypeEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectOperDocTypeEditDto>(null as any);
    }

    /**
     * @return Success
     */
    invObjOperDocTypeList(): Observable<GetInvObjOperDocTypeOutput> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOperDocType/InvObjOperDocTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvObjOperDocTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvObjOperDocTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInvObjOperDocTypeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInvObjOperDocTypeOutput>;
        }));
    }

    protected processInvObjOperDocTypeList(response: HttpResponseBase): Observable<GetInvObjOperDocTypeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvObjOperDocTypeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvObjOperDocTypeOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvObjOperDocType(body: InvObjectOperDocTypeEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectOperDocType/SaveInvObjOperDocType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvObjOperDocType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvObjOperDocType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveInvObjOperDocType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class InvObjectStorageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    invObjectStorageList(): Observable<GetInvObjectStorageOutput> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectStorage/InvObjectStorageList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvObjectStorageList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvObjectStorageList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInvObjectStorageOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInvObjectStorageOutput>;
        }));
    }

    protected processInvObjectStorageList(response: HttpResponseBase): Observable<GetInvObjectStorageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvObjectStorageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvObjectStorageOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStorageById(id: number | undefined): Observable<InvObjectStorageDto> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectStorage/GetStorageById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectStorageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectStorageDto>;
        }));
    }

    protected processGetStorageById(response: HttpResponseBase): Observable<InvObjectStorageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectStorageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectStorageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveStorage(body: InvObjectStorageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectStorage/SaveStorage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStorage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param storageId (optional) 
     * @return Success
     */
    deleteStorage(storageId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvObjectStorage/DeleteStorage?";
        if (storageId === null)
            throw new Error("The parameter 'storageId' cannot be null.");
        else if (storageId !== undefined)
            url_ += "storageId=" + encodeURIComponent("" + storageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStorage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    getThirdParty(search: string | null | undefined): Observable<ThirdPartyListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetThirdParty?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThirdParty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThirdParty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThirdPartyListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThirdPartyListDDDto[]>;
        }));
    }

    protected processGetThirdParty(response: HttpResponseBase): Observable<ThirdPartyListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ThirdPartyListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThirdPartyListDDDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getInvoicesList(): Observable<InvoiceDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoicesList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDTO[]>;
        }));
    }

    protected processGetInvoicesList(response: HttpResponseBase): Observable<InvoiceDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDTO[]>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @param thridPartyId (optional) 
     * @param documentType (optional) 
     * @param facturiIncomplete (optional) 
     * @param suma (optional) 
     * @param dataType (optional) 
     * @return Success
     */
    getInvoices(dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined, thridPartyId: number | null | undefined, documentType: string | null | undefined, facturiIncomplete: boolean | undefined, suma: number | null | undefined, dataType: string | null | undefined): Observable<InvoiceDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoices?";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        if (thridPartyId !== undefined && thridPartyId !== null)
            url_ += "thridPartyId=" + encodeURIComponent("" + thridPartyId) + "&";
        if (documentType !== undefined && documentType !== null)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        if (facturiIncomplete === null)
            throw new Error("The parameter 'facturiIncomplete' cannot be null.");
        else if (facturiIncomplete !== undefined)
            url_ += "facturiIncomplete=" + encodeURIComponent("" + facturiIncomplete) + "&";
        if (suma !== undefined && suma !== null)
            url_ += "suma=" + encodeURIComponent("" + suma) + "&";
        if (dataType !== undefined && dataType !== null)
            url_ += "dataType=" + encodeURIComponent("" + dataType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDTO[]>;
        }));
    }

    protected processGetInvoices(response: HttpResponseBase): Observable<InvoiceDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDTO[]>(null as any);
    }

    /**
     * @return Success
     */
    getInvoiceElementsDetails(): Observable<InvoiceElementsDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceElementsDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceElementsDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceElementsDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceElementsDetailsDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceElementsDetailsDTO[]>;
        }));
    }

    protected processGetInvoiceElementsDetails(response: HttpResponseBase): Observable<InvoiceElementsDetailsDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceElementsDetailsDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceElementsDetailsDTO[]>(null as any);
    }

    /**
     * @param element (optional) 
     * @param account (optional) 
     * @param invoiceElementsDetailsCategory (optional) 
     * @return Success
     */
    searchInvoiceElementsDetails(element: string | null | undefined, account: string | null | undefined, invoiceElementsDetailsCategory: string | null | undefined): Observable<InvoiceElementsDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/SearchInvoiceElementsDetails?";
        if (element !== undefined && element !== null)
            url_ += "element=" + encodeURIComponent("" + element) + "&";
        if (account !== undefined && account !== null)
            url_ += "account=" + encodeURIComponent("" + account) + "&";
        if (invoiceElementsDetailsCategory !== undefined && invoiceElementsDetailsCategory !== null)
            url_ += "InvoiceElementsDetailsCategory=" + encodeURIComponent("" + invoiceElementsDetailsCategory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchInvoiceElementsDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchInvoiceElementsDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceElementsDetailsDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceElementsDetailsDTO[]>;
        }));
    }

    protected processSearchInvoiceElementsDetails(response: HttpResponseBase): Observable<InvoiceElementsDetailsDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceElementsDetailsDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceElementsDetailsDTO[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceElementsDetail(id: number | undefined): Observable<InvoiceElementsDetailsDTO> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceElementsDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceElementsDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceElementsDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceElementsDetailsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceElementsDetailsDTO>;
        }));
    }

    protected processGetInvoiceElementsDetail(response: HttpResponseBase): Observable<InvoiceElementsDetailsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceElementsDetailsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceElementsDetailsDTO>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvoiceElementDetail(body: InvoiceElementsDetailsDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/SaveInvoiceElementDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvoiceElementDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvoiceElementDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveInvoiceElementDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getElementAccounts(): Observable<InvoiceElementAccountsDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetElementAccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetElementAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetElementAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceElementAccountsDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceElementAccountsDTO[]>;
        }));
    }

    protected processGetElementAccounts(response: HttpResponseBase): Observable<InvoiceElementAccountsDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceElementAccountsDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceElementAccountsDTO[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getElementAccount(id: number | undefined): Observable<InvoiceElementAccountsDTO> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetElementAccount?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetElementAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetElementAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceElementAccountsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceElementAccountsDTO>;
        }));
    }

    protected processGetElementAccount(response: HttpResponseBase): Observable<InvoiceElementAccountsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceElementAccountsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceElementAccountsDTO>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveElementAccount(body: InvoiceElementAccountsDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/SaveElementAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveElementAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveElementAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveElementAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoice(id: number | undefined): Observable<InvoiceDTO> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoice?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDTO>;
        }));
    }

    protected processGetInvoice(response: HttpResponseBase): Observable<InvoiceDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDTO>(null as any);
    }

    /**
     * @param decontId (optional) 
     * @return Success
     */
    getInvoicesByDecontId(decontId: number | null | undefined): Observable<InvoiceDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoicesByDecontId?";
        if (decontId !== undefined && decontId !== null)
            url_ += "decontId=" + encodeURIComponent("" + decontId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicesByDecontId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicesByDecontId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDTO[]>;
        }));
    }

    protected processGetInvoicesByDecontId(response: HttpResponseBase): Observable<InvoiceDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDTO[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceDetails(id: number | undefined): Observable<InvoiceListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceListDto[]>;
        }));
    }

    protected processGetInvoiceDetails(response: HttpResponseBase): Observable<InvoiceListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListDto[]>(null as any);
    }

    /**
     * @param imoAssetItemId (optional) 
     * @param operationType (optional) 
     * @param operationId (optional) 
     * @param invoiceId (optional) 
     * @return Success
     */
    getInvoiceDetailsForImoAsset(imoAssetItemId: number | undefined, operationType: number | undefined, operationId: number | null | undefined, invoiceId: number | null | undefined): Observable<InvoiceListForImoAssetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceDetailsForImoAsset?";
        if (imoAssetItemId === null)
            throw new Error("The parameter 'imoAssetItemId' cannot be null.");
        else if (imoAssetItemId !== undefined)
            url_ += "imoAssetItemId=" + encodeURIComponent("" + imoAssetItemId) + "&";
        if (operationType === null)
            throw new Error("The parameter 'operationType' cannot be null.");
        else if (operationType !== undefined)
            url_ += "operationType=" + encodeURIComponent("" + operationType) + "&";
        if (operationId !== undefined && operationId !== null)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetailsForImoAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetailsForImoAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceListForImoAssetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceListForImoAssetDto[]>;
        }));
    }

    protected processGetInvoiceDetailsForImoAsset(response: HttpResponseBase): Observable<InvoiceListForImoAssetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceListForImoAssetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListForImoAssetDto[]>(null as any);
    }

    /**
     * @param invObjectItemId (optional) 
     * @param operationId (optional) 
     * @return Success
     */
    getInvoiceDetailsForInvObject(invObjectItemId: number | undefined, operationId: number | null | undefined): Observable<InvoiceListForInvObjectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceDetailsForInvObject?";
        if (invObjectItemId === null)
            throw new Error("The parameter 'invObjectItemId' cannot be null.");
        else if (invObjectItemId !== undefined)
            url_ += "invObjectItemId=" + encodeURIComponent("" + invObjectItemId) + "&";
        if (operationId !== undefined && operationId !== null)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetailsForInvObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetailsForInvObject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceListForInvObjectDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceListForInvObjectDto[]>;
        }));
    }

    protected processGetInvoiceDetailsForInvObject(response: HttpResponseBase): Observable<InvoiceListForInvObjectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceListForInvObjectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListForInvObjectDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvoice(body: InvoiceDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/SaveInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    getThridPathy(search: string | null | undefined): Observable<ThirdPartyDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetThridPathy?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThridPathy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThridPathy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThirdPartyDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThirdPartyDTO[]>;
        }));
    }

    protected processGetThridPathy(response: HttpResponseBase): Observable<ThirdPartyDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ThirdPartyDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThirdPartyDTO[]>(null as any);
    }

    /**
     * @param thirdPartyId (optional) 
     * @param paymentOrderId (optional) 
     * @return Success
     */
    unpayedInvoicesForThirdParty(thirdPartyId: number | undefined, paymentOrderId: number | undefined): Observable<InvoiceListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/UnpayedInvoicesForThirdParty?";
        if (thirdPartyId === null)
            throw new Error("The parameter 'thirdPartyId' cannot be null.");
        else if (thirdPartyId !== undefined)
            url_ += "thirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        if (paymentOrderId === null)
            throw new Error("The parameter 'paymentOrderId' cannot be null.");
        else if (paymentOrderId !== undefined)
            url_ += "paymentOrderId=" + encodeURIComponent("" + paymentOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnpayedInvoicesForThirdParty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnpayedInvoicesForThirdParty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceListDto[]>;
        }));
    }

    protected processUnpayedInvoicesForThirdParty(response: HttpResponseBase): Observable<InvoiceListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListDto[]>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    deleteInvoice(invoiceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/DeleteInvoice?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param decontId (optional) 
     * @return Success
     */
    deleteInvoiceFromDecont(invoiceId: number | undefined, decontId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/DeleteInvoiceFromDecont?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (decontId === null)
            throw new Error("The parameter 'decontId' cannot be null.");
        else if (decontId !== undefined)
            url_ += "decontId=" + encodeURIComponent("" + decontId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoiceFromDecont(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoiceFromDecont(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvoiceFromDecont(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteInvoiceElementsDetail(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/DeleteInvoiceElementsDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoiceElementsDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoiceElementsDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvoiceElementsDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    invoicesForAsset(): Observable<GetAssetOutput> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/InvoicesForAsset";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoicesForAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoicesForAsset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAssetOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAssetOutput>;
        }));
    }

    protected processInvoicesForAsset(response: HttpResponseBase): Observable<GetAssetOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetOutput>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    invoicesForAssetSale(invoiceId: number | null | undefined): Observable<GetAssetOutput> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/InvoicesForAssetSale?";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoicesForAssetSale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoicesForAssetSale(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAssetOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAssetOutput>;
        }));
    }

    protected processInvoicesForAssetSale(response: HttpResponseBase): Observable<GetAssetOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetOutput>(null as any);
    }

    /**
     * @param prepaymentType (optional) 
     * @return Success
     */
    invoicesForPrepayments(prepaymentType: number | undefined): Observable<GetAssetOutput> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/InvoicesForPrepayments?";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoicesForPrepayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoicesForPrepayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAssetOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAssetOutput>;
        }));
    }

    protected processInvoicesForPrepayments(response: HttpResponseBase): Observable<GetAssetOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetOutput>(null as any);
    }

    /**
     * @return Success
     */
    invoicesForInvObjects(): Observable<GetAssetOutput> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/InvoicesForInvObjects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoicesForInvObjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoicesForInvObjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAssetOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAssetOutput>;
        }));
    }

    protected processInvoicesForInvObjects(response: HttpResponseBase): Observable<GetAssetOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetOutput>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    invoicesForInvObject(invoiceId: number | null | undefined): Observable<GetAssetOutput> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/InvoicesForInvObject?";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoicesForInvObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoicesForInvObject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAssetOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAssetOutput>;
        }));
    }

    protected processInvoicesForInvObject(response: HttpResponseBase): Observable<GetAssetOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetOutput>(null as any);
    }

    /**
     * @return Success
     */
    getInvoiceElementsDetailsCategories(): Observable<InvoiceElementsDetailsCategoryListDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceElementsDetailsCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceElementsDetailsCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceElementsDetailsCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceElementsDetailsCategoryListDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceElementsDetailsCategoryListDTO[]>;
        }));
    }

    protected processGetInvoiceElementsDetailsCategories(response: HttpResponseBase): Observable<InvoiceElementsDetailsCategoryListDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceElementsDetailsCategoryListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceElementsDetailsCategoryListDTO[]>(null as any);
    }

    /**
     * @param thirdPartyQuality (optional) 
     * @return Success
     */
    getInvoiceElementsDetailsCategoriesforThirdPartyQuality(thirdPartyQuality: number | undefined): Observable<InvoiceElementsDetailsCategoryListDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceElementsDetailsCategoriesforThirdPartyQuality?";
        if (thirdPartyQuality === null)
            throw new Error("The parameter 'thirdPartyQuality' cannot be null.");
        else if (thirdPartyQuality !== undefined)
            url_ += "thirdPartyQuality=" + encodeURIComponent("" + thirdPartyQuality) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceElementsDetailsCategoriesforThirdPartyQuality(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceElementsDetailsCategoriesforThirdPartyQuality(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceElementsDetailsCategoryListDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceElementsDetailsCategoryListDTO[]>;
        }));
    }

    protected processGetInvoiceElementsDetailsCategoriesforThirdPartyQuality(response: HttpResponseBase): Observable<InvoiceElementsDetailsCategoryListDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceElementsDetailsCategoryListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceElementsDetailsCategoryListDTO[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceElementsDetailsCategory(id: number | undefined): Observable<InvoiceElementsDetailsCategoryEditDTO> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceElementsDetailsCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceElementsDetailsCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceElementsDetailsCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceElementsDetailsCategoryEditDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceElementsDetailsCategoryEditDTO>;
        }));
    }

    protected processGetInvoiceElementsDetailsCategory(response: HttpResponseBase): Observable<InvoiceElementsDetailsCategoryEditDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceElementsDetailsCategoryEditDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceElementsDetailsCategoryEditDTO>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvoiceCategoryElement(body: InvoiceElementsDetailsCategoryEditDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/SaveInvoiceCategoryElement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvoiceCategoryElement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvoiceCategoryElement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveInvoiceCategoryElement(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteInvoiceElementsDetailsCategory(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/DeleteInvoiceElementsDetailsCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoiceElementsDetailsCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoiceElementsDetailsCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvoiceElementsDetailsCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @return Success
     */
    getInvoiceElementsDetailsByCategoryId(categoryId: number | null | undefined): Observable<InvoiceElementsDetailsDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceElementsDetailsByCategoryId?";
        if (categoryId !== undefined && categoryId !== null)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceElementsDetailsByCategoryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceElementsDetailsByCategoryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceElementsDetailsDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceElementsDetailsDTO[]>;
        }));
    }

    protected processGetInvoiceElementsDetailsByCategoryId(response: HttpResponseBase): Observable<InvoiceElementsDetailsDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceElementsDetailsDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceElementsDetailsDTO[]>(null as any);
    }

    /**
     * @param thirdPartyId (optional) 
     * @param dispositionId (optional) 
     * @return Success
     */
    getInvoicesByThirdPartyId(thirdPartyId: number | undefined, dispositionId: number | undefined): Observable<InvoiceListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoicesByThirdPartyId?";
        if (thirdPartyId === null)
            throw new Error("The parameter 'thirdPartyId' cannot be null.");
        else if (thirdPartyId !== undefined)
            url_ += "thirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        if (dispositionId === null)
            throw new Error("The parameter 'dispositionId' cannot be null.");
        else if (dispositionId !== undefined)
            url_ += "dispositionId=" + encodeURIComponent("" + dispositionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicesByThirdPartyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicesByThirdPartyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceListDto[]>;
        }));
    }

    protected processGetInvoicesByThirdPartyId(response: HttpResponseBase): Observable<InvoiceListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListDto[]>(null as any);
    }

    /**
     * @param thirdPartyId (optional) 
     * @param dispositionId (optional) 
     * @return Success
     */
    getInvoicesForDispositionByThirdPartyId(thirdPartyId: number | undefined, dispositionId: number | undefined): Observable<InvoiceListSelectableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoicesForDispositionByThirdPartyId?";
        if (thirdPartyId === null)
            throw new Error("The parameter 'thirdPartyId' cannot be null.");
        else if (thirdPartyId !== undefined)
            url_ += "thirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        if (dispositionId === null)
            throw new Error("The parameter 'dispositionId' cannot be null.");
        else if (dispositionId !== undefined)
            url_ += "dispositionId=" + encodeURIComponent("" + dispositionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicesForDispositionByThirdPartyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicesForDispositionByThirdPartyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceListSelectableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceListSelectableDto[]>;
        }));
    }

    protected processGetInvoicesForDispositionByThirdPartyId(response: HttpResponseBase): Observable<InvoiceListSelectableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceListSelectableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListSelectableDto[]>(null as any);
    }

    /**
     * @param dispositionSum (optional) 
     * @param body (optional) 
     * @return Success
     */
    calculatePayedInvoice(dispositionSum: number | undefined, body: InvoiceListSelectableDto | undefined): Observable<InvoiceListSelectableDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CalculatePayedInvoice?";
        if (dispositionSum === null)
            throw new Error("The parameter 'dispositionSum' cannot be null.");
        else if (dispositionSum !== undefined)
            url_ += "dispositionSum=" + encodeURIComponent("" + dispositionSum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculatePayedInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculatePayedInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceListSelectableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceListSelectableDto>;
        }));
    }

    protected processCalculatePayedInvoice(response: HttpResponseBase): Observable<InvoiceListSelectableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceListSelectableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListSelectableDto>(null as any);
    }

    /**
     * @param thirdPartyId (optional) 
     * @param paymentOrderId (optional) 
     * @return Success
     */
    getInvoicesForPaymentOrderByThirdPartyId(thirdPartyId: number | undefined, paymentOrderId: number | undefined): Observable<InvoiceListSelectableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoicesForPaymentOrderByThirdPartyId?";
        if (thirdPartyId === null)
            throw new Error("The parameter 'thirdPartyId' cannot be null.");
        else if (thirdPartyId !== undefined)
            url_ += "thirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        if (paymentOrderId === null)
            throw new Error("The parameter 'paymentOrderId' cannot be null.");
        else if (paymentOrderId !== undefined)
            url_ += "paymentOrderId=" + encodeURIComponent("" + paymentOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicesForPaymentOrderByThirdPartyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicesForPaymentOrderByThirdPartyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceListSelectableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceListSelectableDto[]>;
        }));
    }

    protected processGetInvoicesForPaymentOrderByThirdPartyId(response: HttpResponseBase): Observable<InvoiceListSelectableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceListSelectableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListSelectableDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCategoryIdByInvoiceElementDetailId(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/getCategoryIdByInvoiceElementDetailId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryIdByInvoiceElementDetailId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryIdByInvoiceElementDetailId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetCategoryIdByInvoiceElementDetailId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param thirdPartyQuality (optional) 
     * @return Success
     */
    getInvoiceSeriesAndNumber(thirdPartyQuality: number | undefined): Observable<InvoiceDTO> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceSeriesAndNumber?";
        if (thirdPartyQuality === null)
            throw new Error("The parameter 'thirdPartyQuality' cannot be null.");
        else if (thirdPartyQuality !== undefined)
            url_ += "thirdPartyQuality=" + encodeURIComponent("" + thirdPartyQuality) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceSeriesAndNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceSeriesAndNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDTO>;
        }));
    }

    protected processGetInvoiceSeriesAndNumber(response: HttpResponseBase): Observable<InvoiceDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDTO>(null as any);
    }

    /**
     * @param decontId (optional) 
     * @param currencyId (optional) 
     * @return Success
     */
    getInvoicesForDecont(decontId: number | null | undefined, currencyId: number | undefined): Observable<InvoiceForDecontDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoicesForDecont?";
        if (decontId !== undefined && decontId !== null)
            url_ += "decontId=" + encodeURIComponent("" + decontId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicesForDecont(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicesForDecont(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceForDecontDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceForDecontDTO[]>;
        }));
    }

    protected processGetInvoicesForDecont(response: HttpResponseBase): Observable<InvoiceForDecontDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceForDecontDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceForDecontDTO[]>(null as any);
    }

    /**
     * @return Success
     */
    getFacturaNumberIncremented(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/getFacturaNumberIncremented";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFacturaNumberIncremented(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFacturaNumberIncremented(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetFacturaNumberIncremented(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param decontId (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveInvoicesFromDecont(decontId: number | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/SaveInvoicesFromDecont?";
        if (decontId === null)
            throw new Error("The parameter 'decontId' cannot be null.");
        else if (decontId !== undefined)
            url_ += "decontId=" + encodeURIComponent("" + decontId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvoicesFromDecont(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvoicesFromDecont(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveInvoicesFromDecont(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class InvoiceAutoOperationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    autoInvInit(): Observable<AutoInvForm> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAutoOperation/AutoInvInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoInvInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoInvInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoInvForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoInvForm>;
        }));
    }

    protected processAutoInvInit(response: HttpResponseBase): Observable<AutoInvForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoInvForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoInvForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    notProcessedList(body: AutoInvForm | undefined): Observable<AutoInvForm> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAutoOperation/NotProcessedList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotProcessedList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotProcessedList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoInvForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoInvForm>;
        }));
    }

    protected processNotProcessedList(response: HttpResponseBase): Observable<AutoInvForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoInvForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoInvForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    processedList(body: AutoInvForm | undefined): Observable<AutoInvForm> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAutoOperation/ProcessedList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessedList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessedList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoInvForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoInvForm>;
        }));
    }

    protected processProcessedList(response: HttpResponseBase): Observable<AutoInvForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoInvForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoInvForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveToConta(body: AutoInvForm | undefined): Observable<AutoInvForm> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAutoOperation/SaveToConta";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveToConta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveToConta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoInvForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoInvForm>;
        }));
    }

    protected processSaveToConta(response: HttpResponseBase): Observable<AutoInvForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoInvForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoInvForm>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    deleteList(dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined): Observable<AutoInvForm> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAutoOperation/DeleteList?";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoInvForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoInvForm>;
        }));
    }

    protected processDeleteList(response: HttpResponseBase): Observable<AutoInvForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoInvForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoInvForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    eraseOperations(body: AutoInvForm | undefined): Observable<AutoInvForm> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAutoOperation/EraseOperations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEraseOperations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEraseOperations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoInvForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoInvForm>;
        }));
    }

    protected processEraseOperations(response: HttpResponseBase): Observable<AutoInvForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoInvForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutoInvForm>(null as any);
    }
}

@Injectable()
export class IssuerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIssuerByPersonId(id: number | undefined): Observable<IssuerDto> {
        let url_ = this.baseUrl + "/api/services/app/Issuer/GetIssuerByPersonId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIssuerByPersonId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIssuerByPersonId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IssuerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IssuerDto>;
        }));
    }

    protected processGetIssuerByPersonId(response: HttpResponseBase): Observable<IssuerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssuerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IssuerDto>(null as any);
    }

    /**
     * @return Success
     */
    getIssuerList(): Observable<IssuerListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Issuer/GetIssuerList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIssuerList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIssuerList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IssuerListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IssuerListDto[]>;
        }));
    }

    protected processGetIssuerList(response: HttpResponseBase): Observable<IssuerListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IssuerListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IssuerListDto[]>(null as any);
    }

    /**
     * @param formNr (optional) 
     * @param body (optional) 
     * @return Success
     */
    showForm(formNr: number | undefined, body: PersonIssuerEditDto | undefined): Observable<PersonIssuerEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Issuer/ShowForm?";
        if (formNr === null)
            throw new Error("The parameter 'formNr' cannot be null.");
        else if (formNr !== undefined)
            url_ += "formNr=" + encodeURIComponent("" + formNr) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonIssuerEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonIssuerEditDto>;
        }));
    }

    protected processShowForm(response: HttpResponseBase): Observable<PersonIssuerEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonIssuerEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonIssuerEditDto>(null as any);
    }

    /**
     * @param issuerId (optional) 
     * @return Success
     */
    personIssuerInit(issuerId: number | null | undefined): Observable<PersonIssuerEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Issuer/PersonIssuerInit?";
        if (issuerId !== undefined && issuerId !== null)
            url_ += "issuerId=" + encodeURIComponent("" + issuerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonIssuerInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonIssuerInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonIssuerEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonIssuerEditDto>;
        }));
    }

    protected processPersonIssuerInit(response: HttpResponseBase): Observable<PersonIssuerEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonIssuerEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonIssuerEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveIssuer(body: IssuerDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Issuer/SaveIssuer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveIssuer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveIssuer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveIssuer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: PersonIssuerEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Issuer/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteIssuer(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Issuer/DeleteIssuer?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIssuer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIssuer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteIssuer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param personId (optional) 
     * @return Success
     */
    getPersonIssuerByPersonId(personId: number | undefined): Observable<PersonIssuerEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Issuer/GetPersonIssuerByPersonId?";
        if (personId === null)
            throw new Error("The parameter 'personId' cannot be null.");
        else if (personId !== undefined)
            url_ += "personId=" + encodeURIComponent("" + personId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonIssuerByPersonId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonIssuerByPersonId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonIssuerEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonIssuerEditDto>;
        }));
    }

    protected processGetPersonIssuerByPersonId(response: HttpResponseBase): Observable<PersonIssuerEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonIssuerEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonIssuerEditDto>(null as any);
    }

    /**
     * @return Success
     */
    actualizeazaIssuer(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Issuer/ActualizeazaIssuer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActualizeazaIssuer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActualizeazaIssuer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActualizeazaIssuer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class LichidCalcServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param savedBalanceId (optional) 
     * @return Success
     */
    deleteLichidCalc(savedBalanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalc/DeleteLichidCalc?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLichidCalc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLichidCalc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLichidCalc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getLichidBenziList(): Observable<LichidBenziDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalc/GetLichidBenziList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichidBenziList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichidBenziList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidBenziDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidBenziDto[]>;
        }));
    }

    protected processGetLichidBenziList(response: HttpResponseBase): Observable<LichidBenziDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LichidBenziDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidBenziDto[]>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @return Success
     */
    getLichidCalcDetList(savedBalanceId: number | undefined): Observable<LichidCalcListDetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalc/GetLichidCalcDetList?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichidCalcDetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichidCalcDetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidCalcListDetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidCalcListDetDto[]>;
        }));
    }

    protected processGetLichidCalcDetList(response: HttpResponseBase): Observable<LichidCalcListDetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LichidCalcListDetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidCalcListDetDto[]>(null as any);
    }

    /**
     * @param columnId (optional) 
     * @param savedBalanceId (optional) 
     * @param lichidCalcConfigId (optional) 
     * @return Success
     */
    getLichidCalcFormulaDet(columnId: number | undefined, savedBalanceId: number | undefined, lichidCalcConfigId: number | undefined): Observable<LichidCalcDetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalc/GetLichidCalcFormulaDet?";
        if (columnId === null)
            throw new Error("The parameter 'columnId' cannot be null.");
        else if (columnId !== undefined)
            url_ += "columnId=" + encodeURIComponent("" + columnId) + "&";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        if (lichidCalcConfigId === null)
            throw new Error("The parameter 'lichidCalcConfigId' cannot be null.");
        else if (lichidCalcConfigId !== undefined)
            url_ += "lichidCalcConfigId=" + encodeURIComponent("" + lichidCalcConfigId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichidCalcFormulaDet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichidCalcFormulaDet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidCalcDetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidCalcDetDto[]>;
        }));
    }

    protected processGetLichidCalcFormulaDet(response: HttpResponseBase): Observable<LichidCalcDetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LichidCalcDetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidCalcDetDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getLichidCalcList(): Observable<LichidCalcInitDto> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalc/GetLichidCalcList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichidCalcList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichidCalcList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidCalcInitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidCalcInitDto>;
        }));
    }

    protected processGetLichidCalcList(response: HttpResponseBase): Observable<LichidCalcInitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LichidCalcInitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidCalcInitDto>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @return Success
     */
    lichidCalc(savedBalanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalc/LichidCalc?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLichidCalc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLichidCalc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLichidCalc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @return Success
     */
    recalculLichiditate(savedBalanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalc/RecalculLichiditate?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecalculLichiditate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecalculLichiditate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRecalculLichiditate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateLichidCalc(savedBalanceId: number | undefined, body: LichidCalcListDetDto[] | null | undefined): Observable<LichidCalcListDetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalc/UpdateLichidCalc?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLichidCalc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLichidCalc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidCalcListDetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidCalcListDetDto[]>;
        }));
    }

    protected processUpdateLichidCalc(response: HttpResponseBase): Observable<LichidCalcListDetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LichidCalcListDetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidCalcListDetDto[]>(null as any);
    }
}

@Injectable()
export class LichidCalcCurrServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param columnId (optional) 
     * @param savedBalanceId (optional) 
     * @param lichidCalcConfigId (optional) 
     * @return Success
     */
    getLichidCalcCurrFormulaDet(columnId: number | undefined, savedBalanceId: number | undefined, lichidCalcConfigId: number | undefined): Observable<LichidCalcCurrDetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalcCurr/GetLichidCalcCurrFormulaDet?";
        if (columnId === null)
            throw new Error("The parameter 'columnId' cannot be null.");
        else if (columnId !== undefined)
            url_ += "columnId=" + encodeURIComponent("" + columnId) + "&";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        if (lichidCalcConfigId === null)
            throw new Error("The parameter 'lichidCalcConfigId' cannot be null.");
        else if (lichidCalcConfigId !== undefined)
            url_ += "lichidCalcConfigId=" + encodeURIComponent("" + lichidCalcConfigId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichidCalcCurrFormulaDet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichidCalcCurrFormulaDet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidCalcCurrDetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidCalcCurrDetDto[]>;
        }));
    }

    protected processGetLichidCalcCurrFormulaDet(response: HttpResponseBase): Observable<LichidCalcCurrDetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LichidCalcCurrDetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidCalcCurrDetDto[]>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @return Success
     */
    getLichidCalcCurrList(savedBalanceId: number | undefined): Observable<LichidCalcCurrListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalcCurr/GetLichidCalcCurrList?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLichidCalcCurrList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLichidCalcCurrList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidCalcCurrListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidCalcCurrListDto[]>;
        }));
    }

    protected processGetLichidCalcCurrList(response: HttpResponseBase): Observable<LichidCalcCurrListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LichidCalcCurrListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidCalcCurrListDto[]>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateLichidCalcCurr(savedBalanceId: number | undefined, body: LichidCalcCurrListDto[] | null | undefined): Observable<LichidCalcCurrListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichidCalcCurr/UpdateLichidCalcCurr?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLichidCalcCurr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLichidCalcCurr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidCalcCurrListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidCalcCurrListDto[]>;
        }));
    }

    protected processUpdateLichidCalcCurr(response: HttpResponseBase): Observable<LichidCalcCurrListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LichidCalcCurrListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidCalcCurrListDto[]>(null as any);
    }
}

@Injectable()
export class LichidConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    lichidBenziList(): Observable<LichidBenziDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichidConfig/LichidBenziList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLichidBenziList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLichidBenziList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidBenziDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidBenziDto[]>;
        }));
    }

    protected processLichidBenziList(response: HttpResponseBase): Observable<LichidBenziDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LichidBenziDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidBenziDto[]>(null as any);
    }

    /**
     * @return Success
     */
    lichidConfigList(): Observable<LichidConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LichidConfig/LichidConfigList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLichidConfigList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLichidConfigList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidConfigDto[]>;
        }));
    }

    protected processLichidConfigList(response: HttpResponseBase): Observable<LichidConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LichidConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidConfigDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveLichidConfig(body: LichidConfigDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LichidConfig/SaveLichidConfig";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveLichidConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveLichidConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveLichidConfig(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class NotificareServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getNotificareList(): Observable<NotificareDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Notificare/GetNotificareList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificareList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificareList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificareDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificareDto[]>;
        }));
    }

    protected processGetNotificareList(response: HttpResponseBase): Observable<NotificareDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NotificareDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificareDto[]>(null as any);
    }

    /**
     * @param notificareId (optional) 
     * @return Success
     */
    updateStareNotificare(notificareId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notificare/UpdateStareNotificare?";
        if (notificareId === null)
            throw new Error("The parameter 'notificareId' cannot be null.");
        else if (notificareId !== undefined)
            url_ += "notificareId=" + encodeURIComponent("" + notificareId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStareNotificare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStareNotificare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateStareNotificare(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class OperatieComisionDobandaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    operatieComisionDobandaByImprumutIdList(imprumutId: number | undefined): Observable<OperatieDobandaComisionDtoList> {
        let url_ = this.baseUrl + "/api/services/app/OperatieComisionDobanda/OperatieComisionDobandaByImprumutIdList?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "ImprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperatieComisionDobandaByImprumutIdList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperatieComisionDobandaByImprumutIdList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperatieDobandaComisionDtoList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperatieDobandaComisionDtoList>;
        }));
    }

    protected processOperatieComisionDobandaByImprumutIdList(response: HttpResponseBase): Observable<OperatieDobandaComisionDtoList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperatieDobandaComisionDtoList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperatieDobandaComisionDtoList>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    operatieComisionDobandaSave(body: OperatieDobandaComisionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperatieComisionDobanda/OperatieComisionDobandaSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperatieComisionDobandaSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperatieComisionDobandaSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOperatieComisionDobandaSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param operatieId (optional) 
     * @return Success
     */
    operatieDeleteId(operatieId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperatieComisionDobanda/OperatieDeleteId?";
        if (operatieId === null)
            throw new Error("The parameter 'operatieId' cannot be null.");
        else if (operatieId !== undefined)
            url_ += "OperatieId=" + encodeURIComponent("" + operatieId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperatieDeleteId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperatieDeleteId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOperatieDeleteId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class OperationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initSearch(): Observable<OperationSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/Operation/InitSearch";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationSearchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationSearchDto>;
        }));
    }

    protected processInitSearch(response: HttpResponseBase): Observable<OperationSearchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationSearchDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationSearchDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchOperations(body: OperationSearchDto | undefined): Observable<OperationSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/Operation/SearchOperations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchOperations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchOperations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationSearchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationSearchDto>;
        }));
    }

    protected processSearchOperations(response: HttpResponseBase): Observable<OperationSearchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationSearchDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationSearchDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveValidation(body: OperationSearchDto | undefined): Observable<OperationSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/Operation/SaveValidation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveValidation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveValidation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationSearchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationSearchDto>;
        }));
    }

    protected processSaveValidation(response: HttpResponseBase): Observable<OperationSearchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationSearchDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationSearchDto>(null as any);
    }

    /**
     * @param _operationId (optional) 
     * @return Success
     */
    deleteOperation(_operationId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Operation/DeleteOperation?";
        if (_operationId === null)
            throw new Error("The parameter '_operationId' cannot be null.");
        else if (_operationId !== undefined)
            url_ += "_operationId=" + encodeURIComponent("" + _operationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOperation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param operationId (optional) 
     * @return Success
     */
    initOperation(operationId: number | undefined): Observable<OperationEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Operation/InitOperation?";
        if (operationId === null)
            throw new Error("The parameter 'operationId' cannot be null.");
        else if (operationId !== undefined)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationEditDto>;
        }));
    }

    protected processInitOperation(response: HttpResponseBase): Observable<OperationEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOperationDetail(body: OperationEditDto | undefined): Observable<OperationEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Operation/AddOperationDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOperationDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOperationDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationEditDto>;
        }));
    }

    protected processAddOperationDetail(response: HttpResponseBase): Observable<OperationEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationEditDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param operationDate (optional) 
     * @param documentNumber (optional) 
     * @param documentDate (optional) 
     * @param closingMonth (optional) 
     * @param documentTypeId (optional) 
     * @param currencyId (optional) 
     * @param localCurrencyId (optional) 
     * @param operationTypeId (optional) 
     * @param exchangeRate (optional) 
     * @param operationDefinitionId (optional) 
     * @param operationParentId (optional) 
     * @param operationDetails (optional) 
     * @param last10 (optional) 
     * @param idOrd (optional) 
     * @return Success
     */
    deleteOperationDetail(id: number | undefined, operationDate: moment.Moment | undefined, documentNumber: string | null | undefined, documentDate: moment.Moment | undefined, closingMonth: boolean | undefined, documentTypeId: number | undefined, currencyId: number | undefined, localCurrencyId: number | undefined, operationTypeId: number | null | undefined, exchangeRate: number | undefined, operationDefinitionId: number | null | undefined, operationParentId: number | null | undefined, operationDetails: OperationEditDetailsDto[] | null | undefined, last10: OperationLast10DTO[] | null | undefined, idOrd: number | undefined): Observable<OperationEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Operation/DeleteOperationDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (operationDate === null)
            throw new Error("The parameter 'operationDate' cannot be null.");
        else if (operationDate !== undefined)
            url_ += "OperationDate=" + encodeURIComponent(operationDate ? "" + operationDate.toISOString() : "") + "&";
        if (documentNumber !== undefined && documentNumber !== null)
            url_ += "DocumentNumber=" + encodeURIComponent("" + documentNumber) + "&";
        if (documentDate === null)
            throw new Error("The parameter 'documentDate' cannot be null.");
        else if (documentDate !== undefined)
            url_ += "DocumentDate=" + encodeURIComponent(documentDate ? "" + documentDate.toISOString() : "") + "&";
        if (closingMonth === null)
            throw new Error("The parameter 'closingMonth' cannot be null.");
        else if (closingMonth !== undefined)
            url_ += "ClosingMonth=" + encodeURIComponent("" + closingMonth) + "&";
        if (documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' cannot be null.");
        else if (documentTypeId !== undefined)
            url_ += "DocumentTypeId=" + encodeURIComponent("" + documentTypeId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (localCurrencyId === null)
            throw new Error("The parameter 'localCurrencyId' cannot be null.");
        else if (localCurrencyId !== undefined)
            url_ += "LocalCurrencyId=" + encodeURIComponent("" + localCurrencyId) + "&";
        if (operationTypeId !== undefined && operationTypeId !== null)
            url_ += "OperationTypeId=" + encodeURIComponent("" + operationTypeId) + "&";
        if (exchangeRate === null)
            throw new Error("The parameter 'exchangeRate' cannot be null.");
        else if (exchangeRate !== undefined)
            url_ += "ExchangeRate=" + encodeURIComponent("" + exchangeRate) + "&";
        if (operationDefinitionId !== undefined && operationDefinitionId !== null)
            url_ += "OperationDefinitionId=" + encodeURIComponent("" + operationDefinitionId) + "&";
        if (operationParentId !== undefined && operationParentId !== null)
            url_ += "OperationParentId=" + encodeURIComponent("" + operationParentId) + "&";
        if (operationDetails !== undefined && operationDetails !== null)
            operationDetails && operationDetails.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "OperationDetails[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (last10 !== undefined && last10 !== null)
            last10 && last10.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Last10[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (idOrd === null)
            throw new Error("The parameter 'idOrd' cannot be null.");
        else if (idOrd !== undefined)
            url_ += "idOrd=" + encodeURIComponent("" + idOrd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperationDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperationDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationEditDto>;
        }));
    }

    protected processDeleteOperationDetail(response: HttpResponseBase): Observable<OperationEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    actExchangeRate(body: OperationEditDto | undefined): Observable<OperationEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Operation/ActExchangeRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActExchangeRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActExchangeRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationEditDto>;
        }));
    }

    protected processActExchangeRate(response: HttpResponseBase): Observable<OperationEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveOperation(body: OperationEditDto | undefined): Observable<OperationEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Operation/SaveOperation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationEditDto>;
        }));
    }

    protected processSaveOperation(response: HttpResponseBase): Observable<OperationEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadOperationFile(body: FileUploadDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Operation/UploadOperationFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadOperationFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadOperationFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadOperationFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    searchLast10Operations(): Observable<OperationLast10DTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Operation/SearchLast10Operations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchLast10Operations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchLast10Operations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationLast10DTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationLast10DTO[]>;
        }));
    }

    protected processSearchLast10Operations(response: HttpResponseBase): Observable<OperationLast10DTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperationLast10DTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationLast10DTO[]>(null as any);
    }

    /**
     * @param operGenerateId (optional) 
     * @return Success
     */
    searchOperationsByOperGenerateId(operGenerateId: number | undefined): Observable<OperationDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/Operation/SearchOperationsByOperGenerateId?";
        if (operGenerateId === null)
            throw new Error("The parameter 'operGenerateId' cannot be null.");
        else if (operGenerateId !== undefined)
            url_ += "operGenerateId=" + encodeURIComponent("" + operGenerateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchOperationsByOperGenerateId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchOperationsByOperGenerateId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationDTO[]>;
        }));
    }

    protected processSearchOperationsByOperGenerateId(response: HttpResponseBase): Observable<OperationDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperationDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationDTO[]>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param currencyId (optional) 
     * @param operationDate (optional) 
     * @return Success
     */
    soldOperation(accountId: number | undefined, currencyId: number | undefined, operationDate: moment.Moment | undefined): Observable<SoldOperationDto> {
        let url_ = this.baseUrl + "/api/services/app/Operation/SoldOperation?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (operationDate === null)
            throw new Error("The parameter 'operationDate' cannot be null.");
        else if (operationDate !== undefined)
            url_ += "operationDate=" + encodeURIComponent(operationDate ? "" + operationDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSoldOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSoldOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SoldOperationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SoldOperationDto>;
        }));
    }

    protected processSoldOperation(response: HttpResponseBase): Observable<SoldOperationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoldOperationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoldOperationDto>(null as any);
    }

    /**
     * @param allowDeletion (optional) 
     * @return Success
     */
    allowDeletionOperExterna(allowDeletion: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Operation/AllowDeletionOperExterna?";
        if (allowDeletion === null)
            throw new Error("The parameter 'allowDeletion' cannot be null.");
        else if (allowDeletion !== undefined)
            url_ += "allowDeletion=" + encodeURIComponent("" + allowDeletion) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllowDeletionOperExterna(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllowDeletionOperExterna(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAllowDeletionOperExterna(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getSetupStergOperExterna(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Operation/GetSetupStergOperExterna";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSetupStergOperExterna(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSetupStergOperExterna(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetSetupStergOperExterna(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class OperationDefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param operationId (optional) 
     * @return Success
     */
    initOperation(operationId: number | undefined): Observable<OperationDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationDefinition/InitOperation?";
        if (operationId === null)
            throw new Error("The parameter 'operationId' cannot be null.");
        else if (operationId !== undefined)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationDefinitionDto>;
        }));
    }

    protected processInitOperation(response: HttpResponseBase): Observable<OperationDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationDefinitionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationDefinitionDto>(null as any);
    }

    /**
     * @return Success
     */
    operationDefinitionDetailsList(): Observable<OperationDefinitionDetailsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OperationDefinition/OperationDefinitionDetailsList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperationDefinitionDetailsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperationDefinitionDetailsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationDefinitionDetailsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationDefinitionDetailsDto[]>;
        }));
    }

    protected processOperationDefinitionDetailsList(response: HttpResponseBase): Observable<OperationDefinitionDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperationDefinitionDetailsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationDefinitionDetailsDto[]>(null as any);
    }

    /**
     * @return Success
     */
    operationDefinitionList(): Observable<OperationDefinitionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OperationDefinition/OperationDefinitionList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperationDefinitionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperationDefinitionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationDefinitionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationDefinitionDto[]>;
        }));
    }

    protected processOperationDefinitionList(response: HttpResponseBase): Observable<OperationDefinitionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperationDefinitionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationDefinitionDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOperationDefinitionDetailsId(id: number | undefined): Observable<OperationDefinitionDetailsDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationDefinition/GetOperationDefinitionDetailsId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationDefinitionDetailsId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationDefinitionDetailsId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationDefinitionDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationDefinitionDetailsDto>;
        }));
    }

    protected processGetOperationDefinitionDetailsId(response: HttpResponseBase): Observable<OperationDefinitionDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationDefinitionDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationDefinitionDetailsDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOperationDefinitionId(id: number | undefined): Observable<OperationDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationDefinition/GetOperationDefinitionId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationDefinitionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationDefinitionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationDefinitionDto>;
        }));
    }

    protected processGetOperationDefinitionId(response: HttpResponseBase): Observable<OperationDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationDefinitionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationDefinitionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveOperationDefinitionDetails(body: OperationDefinitionDetailsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperationDefinition/SaveOperationDefinitionDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOperationDefinitionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOperationDefinitionDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveOperationDefinitionDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveOperationDefinition(body: OperationDefinitionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperationDefinition/SaveOperationDefinition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOperationDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOperationDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveOperationDefinition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOperationDefinitionDetails(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperationDefinition/DeleteOperationDefinitionDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperationDefinitionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperationDefinitionDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOperationDefinitionDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOperationDefinition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperationDefinition/DeleteOperationDefinition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperationDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperationDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOperationDefinition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class OperationTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperationTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOperTypeById(id: number | undefined): Observable<OperationTypesEditDto> {
        let url_ = this.baseUrl + "/api/services/app/OperationTypes/GetOperTypeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationTypesEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationTypesEditDto>;
        }));
    }

    protected processGetOperTypeById(response: HttpResponseBase): Observable<OperationTypesEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationTypesEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationTypesEditDto>(null as any);
    }

    /**
     * @return Success
     */
    operTypesList(): Observable<OperationTypesListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OperationTypes/OperTypesList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperTypesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperTypesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperationTypesListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperationTypesListDto[]>;
        }));
    }

    protected processOperTypesList(response: HttpResponseBase): Observable<OperationTypesListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperationTypesListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationTypesListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveOperType(body: OperationTypesEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperationTypes/SaveOperType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOperType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOperType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveOperType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class OperGenerateServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    operGenerateList(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<OperGenerateListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OperGenerateService/OperGenerateList?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperGenerateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperGenerateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperGenerateListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperGenerateListDto[]>;
        }));
    }

    protected processOperGenerateList(response: HttpResponseBase): Observable<OperGenerateListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OperGenerateListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperGenerateListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    operGenerateAddInit(): Observable<OperGenerateAddDto> {
        let url_ = this.baseUrl + "/api/services/app/OperGenerateService/OperGenerateAddInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperGenerateAddInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperGenerateAddInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperGenerateAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperGenerateAddDto>;
        }));
    }

    protected processOperGenerateAddInit(response: HttpResponseBase): Observable<OperGenerateAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperGenerateAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperGenerateAddDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    operGenerateAddSearchOper(body: OperGenerateAddDto | undefined): Observable<OperGenerateAddDto> {
        let url_ = this.baseUrl + "/api/services/app/OperGenerateService/OperGenerateAddSearchOper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperGenerateAddSearchOper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperGenerateAddSearchOper(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OperGenerateAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OperGenerateAddDto>;
        }));
    }

    protected processOperGenerateAddSearchOper(response: HttpResponseBase): Observable<OperGenerateAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperGenerateAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperGenerateAddDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    operGenerateAdd(body: OperGenerateAddDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperGenerateService/OperGenerateAdd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperGenerateAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperGenerateAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOperGenerateAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    operGenerateDelete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OperGenerateService/OperGenerateDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperGenerateDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperGenerateDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOperGenerateDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PaapServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param selectedYear (optional) 
     * @param body (optional) 
     * @return Success
     */
    approvePaapList(selectedYear: number | undefined, body: PaapDepartamentListDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/ApprovePaapList?";
        if (selectedYear === null)
            throw new Error("The parameter 'selectedYear' cannot be null.");
        else if (selectedYear !== undefined)
            url_ += "selectedYear=" + encodeURIComponent("" + selectedYear) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprovePaapList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprovePaapList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApprovePaapList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @return Success
     */
    deletePaap(paapId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/DeletePaap?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePaap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePaap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePaap(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @return Success
     */
    getSinglePaap(paapId: number | undefined): Observable<PaapDto> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetSinglePaap?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSinglePaap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSinglePaap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapDto>;
        }));
    }

    protected processGetSinglePaap(response: HttpResponseBase): Observable<PaapDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaapDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapDto>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @return Success
     */
    getPaap(paapId: number | undefined): Observable<PaapEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetPaap?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapEditDto>;
        }));
    }

    protected processGetPaap(response: HttpResponseBase): Observable<PaapEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaapEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapEditDto>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @return Success
     */
    getPaapStateListByPaapId(paapId: number | undefined): Observable<PaapStateListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Paap/getPaapStateListByPaapId?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "PaapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaapStateListByPaapId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaapStateListByPaapId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapStateListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapStateListDto[]>;
        }));
    }

    protected processGetPaapStateListByPaapId(response: HttpResponseBase): Observable<PaapStateListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapStateListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapStateListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getPAAPYearList(): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetPAAPYearList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPAAPYearList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPAAPYearList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processGetPAAPYearList(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    getPAAPByDepartament(year: number | undefined): Observable<PaapDepartamentListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetPAAPByDepartament?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPAAPByDepartament(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPAAPByDepartament(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapDepartamentListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapDepartamentListDto[]>;
        }));
    }

    protected processGetPAAPByDepartament(response: HttpResponseBase): Observable<PaapDepartamentListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapDepartamentListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapDepartamentListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getPAAPList(): Observable<PaapDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetPAAPList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPAAPList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPAAPList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapDto[]>;
        }));
    }

    protected processGetPAAPList(response: HttpResponseBase): Observable<PaapDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapDto[]>(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    getPAAPListByYear(year: number | undefined): Observable<PaapDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetPAAPListByYear?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPAAPListByYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPAAPListByYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapDto[]>;
        }));
    }

    protected processGetPAAPListByYear(response: HttpResponseBase): Observable<PaapDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapDto[]>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @return Success
     */
    getPaapStateByPaapId(paapId: number | undefined): Observable<PaapStateEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetPaapStateByPaapId?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaapStateByPaapId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaapStateByPaapId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapStateEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapStateEditDto>;
        }));
    }

    protected processGetPaapStateByPaapId(response: HttpResponseBase): Observable<PaapStateEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaapStateEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapStateEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paapSave(body: PaapEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/PaapSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaapSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaapSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPaapSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelApprovedPaap(body: PaapStateEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/CancelApprovedPaap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelApprovedPaap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelApprovedPaap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelApprovedPaap(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param departamentId (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    getAvailableSum(categoryId: number | undefined, departamentId: number | undefined, dataEnd: moment.Moment | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetAvailableSum?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (departamentId === null)
            throw new Error("The parameter 'departamentId' cannot be null.");
        else if (departamentId !== undefined)
            url_ += "departamentId=" + encodeURIComponent("" + departamentId) + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableSum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableSum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetAvailableSum(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    cancelAllApprovedPaap(year: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/CancelAllApprovedPaap?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelAllApprovedPaap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelAllApprovedPaap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelAllApprovedPaap(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @return Success
     */
    getInvoiceDetails(paapId: number | undefined): Observable<InvoiceDetailsForPAAPDto> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetInvoiceDetails?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDetailsForPAAPDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDetailsForPAAPDto>;
        }));
    }

    protected processGetInvoiceDetails(response: HttpResponseBase): Observable<InvoiceDetailsForPAAPDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDetailsForPAAPDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDetailsForPAAPDto>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @param body (optional) 
     * @return Success
     */
    approveInvoices(paapId: number | undefined, body: InvoiceDetailsForPAAPDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/ApproveInvoices?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApproveInvoices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param pappId (optional) 
     * @param invoiceDetailId (optional) 
     * @return Success
     */
    deleteAllocatedInvoice(pappId: number | undefined, invoiceDetailId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/DeleteAllocatedInvoice?";
        if (pappId === null)
            throw new Error("The parameter 'pappId' cannot be null.");
        else if (pappId !== undefined)
            url_ += "pappId=" + encodeURIComponent("" + pappId) + "&";
        if (invoiceDetailId === null)
            throw new Error("The parameter 'invoiceDetailId' cannot be null.");
        else if (invoiceDetailId !== undefined)
            url_ += "invoiceDetailId=" + encodeURIComponent("" + invoiceDetailId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllocatedInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllocatedInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllocatedInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @return Success
     */
    finalizePAAP(paapId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/FinalizePAAP?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinalizePAAP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinalizePAAP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFinalizePAAP(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @return Success
     */
    cancelFinalizePAAP(paapId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/CancelFinalizePAAP?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelFinalizePAAP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelFinalizePAAP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelFinalizePAAP(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    amanarePAAP(body: AmanarePaapEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/AmanarePAAP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAmanarePAAP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAmanarePAAP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAmanarePAAP(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    realocarePaap(body: RealocarePaapDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Paap/RealocarePaap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRealocarePaap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRealocarePaap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRealocarePaap(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateTranse(body: PaapEditDto | undefined): Observable<PaapEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GenerateTranse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateTranse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateTranse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapEditDto>;
        }));
    }

    protected processGenerateTranse(response: HttpResponseBase): Observable<PaapEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaapEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addTransa(body: PaapEditDto | undefined): Observable<PaapEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Paap/AddTransa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTransa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTransa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapEditDto>;
        }));
    }

    protected processAddTransa(response: HttpResponseBase): Observable<PaapEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaapEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapEditDto>(null as any);
    }

    /**
     * @param index (optional) 
     * @param body (optional) 
     * @return Success
     */
    reglareTranse(index: number | undefined, body: PaapEditDto | undefined): Observable<PaapEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Paap/ReglareTranse?";
        if (index === null)
            throw new Error("The parameter 'index' cannot be null.");
        else if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReglareTranse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReglareTranse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapEditDto>;
        }));
    }

    protected processReglareTranse(response: HttpResponseBase): Observable<PaapEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaapEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapEditDto>(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    getPAAPListTranseByYear(year: number | undefined): Observable<PaapTranseListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetPAAPListTranseByYear?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPAAPListTranseByYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPAAPListTranseByYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapTranseListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapTranseListDto[]>;
        }));
    }

    protected processGetPAAPListTranseByYear(response: HttpResponseBase): Observable<PaapTranseListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapTranseListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapTranseListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkEqualSumPAAPTranse(body: PaapDto[] | null | undefined): Observable<PaapDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Paap/CheckEqualSumPAAPTranse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckEqualSumPAAPTranse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckEqualSumPAAPTranse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapDto[]>;
        }));
    }

    protected processCheckEqualSumPAAPTranse(response: HttpResponseBase): Observable<PaapDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapDto[]>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @return Success
     */
    getTranseByPaapId(paapId: number | undefined): Observable<PaapTranseListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetTranseByPaapId?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTranseByPaapId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTranseByPaapId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapTranseListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapTranseListDto[]>;
        }));
    }

    protected processGetTranseByPaapId(response: HttpResponseBase): Observable<PaapTranseListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapTranseListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapTranseListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getInvoiceDetailsWithoutPaap(): Observable<InvoiceDetailPAAPWithInvoiceElementsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetInvoiceDetailsWithoutPaap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetailsWithoutPaap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetailsWithoutPaap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDetailPAAPWithInvoiceElementsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDetailPAAPWithInvoiceElementsDto[]>;
        }));
    }

    protected processGetInvoiceDetailsWithoutPaap(response: HttpResponseBase): Observable<InvoiceDetailPAAPWithInvoiceElementsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InvoiceDetailPAAPWithInvoiceElementsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDetailPAAPWithInvoiceElementsDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getInvoiceDetailsWithoutPaapCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetInvoiceDetailsWithoutPaapCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetailsWithoutPaapCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetailsWithoutPaapCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetInvoiceDetailsWithoutPaapCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param paapId (optional) 
     * @return Success
     */
    approveInvoicesPentruAlocareFacturi(invoiceId: number | undefined, paapId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Paap/ApproveInvoicesPentruAlocareFacturi?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveInvoicesPentruAlocareFacturi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveInvoicesPentruAlocareFacturi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApproveInvoicesPentruAlocareFacturi(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    nefinalizat30zilePaapListCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Paap/Nefinalizat30zilePaapListCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNefinalizat30zilePaapListCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNefinalizat30zilePaapListCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processNefinalizat30zilePaapListCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @return Success
     */
    nefinalizatDepasitPaapListCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Paap/NefinalizatDepasitPaapListCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNefinalizatDepasitPaapListCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNefinalizatDepasitPaapListCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processNefinalizatDepasitPaapListCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @return Success
     */
    getUserDeptId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetUserDeptId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDeptId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDeptId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetUserDeptId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @return Success
     */
    getUserDeptName(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Paap/GetUserDeptName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDeptName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDeptName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetUserDeptName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class PaapRedistribuireServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    getPaapPierdeList(year: number | undefined): Observable<PaapPierdeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaapRedistribuire/GetPaapPierdeList?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaapPierdeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaapPierdeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapPierdeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapPierdeDto[]>;
        }));
    }

    protected processGetPaapPierdeList(response: HttpResponseBase): Observable<PaapPierdeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapPierdeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapPierdeDto[]>(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    getPaapPrimList(year: number | undefined): Observable<PaapPrimesteDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaapRedistribuire/GetPaapPrimList?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaapPrimList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaapPrimList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapPrimesteDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapPrimesteDto[]>;
        }));
    }

    protected processGetPaapPrimList(response: HttpResponseBase): Observable<PaapPrimesteDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapPrimesteDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapPrimesteDto[]>(null as any);
    }

    /**
     * @param paapPrimesteId (optional) 
     * @return Success
     */
    getPaapRedistribDetalii(paapPrimesteId: number | undefined): Observable<PaapRedistribuireDetaliiDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaapRedistribuire/GetPaapRedistribDetalii?";
        if (paapPrimesteId === null)
            throw new Error("The parameter 'paapPrimesteId' cannot be null.");
        else if (paapPrimesteId !== undefined)
            url_ += "paapPrimesteId=" + encodeURIComponent("" + paapPrimesteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaapRedistribDetalii(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaapRedistribDetalii(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapRedistribuireDetaliiDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapRedistribuireDetaliiDto[]>;
        }));
    }

    protected processGetPaapRedistribDetalii(response: HttpResponseBase): Observable<PaapRedistribuireDetaliiDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapRedistribuireDetaliiDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapRedistribuireDetaliiDto[]>(null as any);
    }

    /**
     * @param paapRedistribuireId (optional) 
     * @return Success
     */
    getPaapRedistribuire(paapRedistribuireId: number | undefined): Observable<PaapRedistribuireDto> {
        let url_ = this.baseUrl + "/api/services/app/PaapRedistribuire/GetPaapRedistribuire?";
        if (paapRedistribuireId === null)
            throw new Error("The parameter 'paapRedistribuireId' cannot be null.");
        else if (paapRedistribuireId !== undefined)
            url_ += "paapRedistribuireId=" + encodeURIComponent("" + paapRedistribuireId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaapRedistribuire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaapRedistribuire(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapRedistribuireDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapRedistribuireDto>;
        }));
    }

    protected processGetPaapRedistribuire(response: HttpResponseBase): Observable<PaapRedistribuireDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaapRedistribuireDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapRedistribuireDto>(null as any);
    }

    /**
     * @param achizRedistribId (optional) 
     * @return Success
     */
    deleteAchizitieRedistribuita(achizRedistribId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaapRedistribuire/DeleteAchizitieRedistribuita?";
        if (achizRedistribId === null)
            throw new Error("The parameter 'achizRedistribId' cannot be null.");
        else if (achizRedistribId !== undefined)
            url_ += "achizRedistribId=" + encodeURIComponent("" + achizRedistribId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAchizitieRedistribuita(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAchizitieRedistribuita(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAchizitieRedistribuita(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: PaapRedistribuireDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaapRedistribuire/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    getPaapRedistribuireList(year: number | undefined): Observable<PaapRedistribuireListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaapRedistribuire/GetPaapRedistribuireList?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaapRedistribuireList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaapRedistribuireList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapRedistribuireListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapRedistribuireListDto[]>;
        }));
    }

    protected processGetPaapRedistribuireList(response: HttpResponseBase): Observable<PaapRedistribuireListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapRedistribuireListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapRedistribuireListDto[]>(null as any);
    }
}

@Injectable()
export class PaapReferatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param referatId (optional) 
     * @return Success
     */
    deletePappReferat(referatId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaapReferat/DeletePappReferat?";
        if (referatId === null)
            throw new Error("The parameter 'referatId' cannot be null.");
        else if (referatId !== undefined)
            url_ += "referatId=" + encodeURIComponent("" + referatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePappReferat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePappReferat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePappReferat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param referatId (optional) 
     * @param paapId (optional) 
     * @return Success
     */
    getPaapReferatEdit(referatId: number | undefined, paapId: number | undefined): Observable<PaapReferatEditDto> {
        let url_ = this.baseUrl + "/api/services/app/PaapReferat/GetPaapReferatEdit?";
        if (referatId === null)
            throw new Error("The parameter 'referatId' cannot be null.");
        else if (referatId !== undefined)
            url_ += "referatId=" + encodeURIComponent("" + referatId) + "&";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaapReferatEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaapReferatEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapReferatEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapReferatEditDto>;
        }));
    }

    protected processGetPaapReferatEdit(response: HttpResponseBase): Observable<PaapReferatEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaapReferatEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapReferatEditDto>(null as any);
    }

    /**
     * @param paapId (optional) 
     * @return Success
     */
    getPaapReferatList(paapId: number | undefined): Observable<PaapReferatDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaapReferat/GetPaapReferatList?";
        if (paapId === null)
            throw new Error("The parameter 'paapId' cannot be null.");
        else if (paapId !== undefined)
            url_ += "paapId=" + encodeURIComponent("" + paapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaapReferatList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaapReferatList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaapReferatDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaapReferatDto[]>;
        }));
    }

    protected processGetPaapReferatList(response: HttpResponseBase): Observable<PaapReferatDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaapReferatDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaapReferatDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePaapReferat(body: PaapReferatEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaapReferat/SavePaapReferat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePaapReferat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePaapReferat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePaapReferat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PaymentOrdersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initForm(): Observable<PayementOrdersForm> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayementOrdersForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayementOrdersForm>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<PayementOrdersForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayementOrdersForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayementOrdersForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paymentOrdersList(body: PayementOrdersForm | undefined): Observable<PayementOrdersForm> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/PaymentOrdersList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentOrdersList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentOrdersList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayementOrdersForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayementOrdersForm>;
        }));
    }

    protected processPaymentOrdersList(response: HttpResponseBase): Observable<PayementOrdersForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayementOrdersForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayementOrdersForm>(null as any);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    paymentOrderDetail(id: number | undefined, body: PayementOrdersForm | undefined): Observable<PayementOrdersForm> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/PaymentOrderDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentOrderDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentOrderDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayementOrdersForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayementOrdersForm>;
        }));
    }

    protected processPaymentOrderDetail(response: HttpResponseBase): Observable<PayementOrdersForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayementOrdersForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayementOrdersForm>(null as any);
    }

    /**
     * @param searchStartDate (optional) 
     * @param searchEndDate (optional) 
     * @param payerId (optional) 
     * @param payerBankId (optional) 
     * @param thirdPartyId (optional) 
     * @param oPList (optional) 
     * @param oPDetail_Id (optional) 
     * @param oPDetail_OrderNr (optional) 
     * @param oPDetail_OrderDate (optional) 
     * @param oPDetail_Value (optional) 
     * @param oPDetail_WrittenValue (optional) 
     * @param oPDetail_PayerBankId (optional) 
     * @param oPDetail_PayerBankAccountId (optional) 
     * @param oPDetail_BeneficiaryId (optional) 
     * @param oPDetail_BeneficiaryName (optional) 
     * @param oPDetail_BenefBankId (optional) 
     * @param oPDetail_BenefBankAccountId (optional) 
     * @param oPDetail_CurrencyId (optional) 
     * @param oPDetail_InvoicesList (optional) 
     * @param oPDetail_PaymentDetails (optional) 
     * @param oPDetail_Finalised (optional) 
     * @param showList (optional) 
     * @param showEditForm (optional) 
     * @param appClientId (optional) 
     * @return Success
     */
    getNextOPNumber(searchStartDate: moment.Moment | undefined, searchEndDate: moment.Moment | undefined, payerId: number | undefined, payerBankId: number | null | undefined, thirdPartyId: number | null | undefined, oPList: PayementOrdersList[] | null | undefined, oPDetail_Id: number | undefined, oPDetail_OrderNr: number | undefined, oPDetail_OrderDate: moment.Moment | undefined, oPDetail_Value: number | undefined, oPDetail_WrittenValue: string | null | undefined, oPDetail_PayerBankId: number | null | undefined, oPDetail_PayerBankAccountId: number | null | undefined, oPDetail_BeneficiaryId: number | null | undefined, oPDetail_BeneficiaryName: string | null | undefined, oPDetail_BenefBankId: number | null | undefined, oPDetail_BenefBankAccountId: number | null | undefined, oPDetail_CurrencyId: number | null | undefined, oPDetail_InvoicesList: InvoiceListSelectableDto[] | null | undefined, oPDetail_PaymentDetails: string | null | undefined, oPDetail_Finalised: OperationStatus | undefined, showList: boolean | undefined, showEditForm: boolean | undefined, appClientId: number | undefined): Observable<PayementOrdersForm> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/GetNextOPNumber?";
        if (searchStartDate === null)
            throw new Error("The parameter 'searchStartDate' cannot be null.");
        else if (searchStartDate !== undefined)
            url_ += "SearchStartDate=" + encodeURIComponent(searchStartDate ? "" + searchStartDate.toISOString() : "") + "&";
        if (searchEndDate === null)
            throw new Error("The parameter 'searchEndDate' cannot be null.");
        else if (searchEndDate !== undefined)
            url_ += "SearchEndDate=" + encodeURIComponent(searchEndDate ? "" + searchEndDate.toISOString() : "") + "&";
        if (payerId === null)
            throw new Error("The parameter 'payerId' cannot be null.");
        else if (payerId !== undefined)
            url_ += "PayerId=" + encodeURIComponent("" + payerId) + "&";
        if (payerBankId !== undefined && payerBankId !== null)
            url_ += "PayerBankId=" + encodeURIComponent("" + payerBankId) + "&";
        if (thirdPartyId !== undefined && thirdPartyId !== null)
            url_ += "ThirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        if (oPList !== undefined && oPList !== null)
            oPList && oPList.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "OPList[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (oPDetail_Id === null)
            throw new Error("The parameter 'oPDetail_Id' cannot be null.");
        else if (oPDetail_Id !== undefined)
            url_ += "OPDetail.Id=" + encodeURIComponent("" + oPDetail_Id) + "&";
        if (oPDetail_OrderNr === null)
            throw new Error("The parameter 'oPDetail_OrderNr' cannot be null.");
        else if (oPDetail_OrderNr !== undefined)
            url_ += "OPDetail.OrderNr=" + encodeURIComponent("" + oPDetail_OrderNr) + "&";
        if (oPDetail_OrderDate === null)
            throw new Error("The parameter 'oPDetail_OrderDate' cannot be null.");
        else if (oPDetail_OrderDate !== undefined)
            url_ += "OPDetail.OrderDate=" + encodeURIComponent(oPDetail_OrderDate ? "" + oPDetail_OrderDate.toISOString() : "") + "&";
        if (oPDetail_Value === null)
            throw new Error("The parameter 'oPDetail_Value' cannot be null.");
        else if (oPDetail_Value !== undefined)
            url_ += "OPDetail.Value=" + encodeURIComponent("" + oPDetail_Value) + "&";
        if (oPDetail_WrittenValue !== undefined && oPDetail_WrittenValue !== null)
            url_ += "OPDetail.WrittenValue=" + encodeURIComponent("" + oPDetail_WrittenValue) + "&";
        if (oPDetail_PayerBankId !== undefined && oPDetail_PayerBankId !== null)
            url_ += "OPDetail.PayerBankId=" + encodeURIComponent("" + oPDetail_PayerBankId) + "&";
        if (oPDetail_PayerBankAccountId !== undefined && oPDetail_PayerBankAccountId !== null)
            url_ += "OPDetail.PayerBankAccountId=" + encodeURIComponent("" + oPDetail_PayerBankAccountId) + "&";
        if (oPDetail_BeneficiaryId !== undefined && oPDetail_BeneficiaryId !== null)
            url_ += "OPDetail.BeneficiaryId=" + encodeURIComponent("" + oPDetail_BeneficiaryId) + "&";
        if (oPDetail_BeneficiaryName !== undefined && oPDetail_BeneficiaryName !== null)
            url_ += "OPDetail.BeneficiaryName=" + encodeURIComponent("" + oPDetail_BeneficiaryName) + "&";
        if (oPDetail_BenefBankId !== undefined && oPDetail_BenefBankId !== null)
            url_ += "OPDetail.BenefBankId=" + encodeURIComponent("" + oPDetail_BenefBankId) + "&";
        if (oPDetail_BenefBankAccountId !== undefined && oPDetail_BenefBankAccountId !== null)
            url_ += "OPDetail.BenefBankAccountId=" + encodeURIComponent("" + oPDetail_BenefBankAccountId) + "&";
        if (oPDetail_CurrencyId !== undefined && oPDetail_CurrencyId !== null)
            url_ += "OPDetail.CurrencyId=" + encodeURIComponent("" + oPDetail_CurrencyId) + "&";
        if (oPDetail_InvoicesList !== undefined && oPDetail_InvoicesList !== null)
            oPDetail_InvoicesList && oPDetail_InvoicesList.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "OPDetail.InvoicesList[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (oPDetail_PaymentDetails !== undefined && oPDetail_PaymentDetails !== null)
            url_ += "OPDetail.PaymentDetails=" + encodeURIComponent("" + oPDetail_PaymentDetails) + "&";
        if (oPDetail_Finalised === null)
            throw new Error("The parameter 'oPDetail_Finalised' cannot be null.");
        else if (oPDetail_Finalised !== undefined)
            url_ += "OPDetail.Finalised=" + encodeURIComponent("" + oPDetail_Finalised) + "&";
        if (showList === null)
            throw new Error("The parameter 'showList' cannot be null.");
        else if (showList !== undefined)
            url_ += "ShowList=" + encodeURIComponent("" + showList) + "&";
        if (showEditForm === null)
            throw new Error("The parameter 'showEditForm' cannot be null.");
        else if (showEditForm !== undefined)
            url_ += "ShowEditForm=" + encodeURIComponent("" + showEditForm) + "&";
        if (appClientId === null)
            throw new Error("The parameter 'appClientId' cannot be null.");
        else if (appClientId !== undefined)
            url_ += "AppClientId=" + encodeURIComponent("" + appClientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextOPNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextOPNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayementOrdersForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayementOrdersForm>;
        }));
    }

    protected processGetNextOPNumber(response: HttpResponseBase): Observable<PayementOrdersForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayementOrdersForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayementOrdersForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paymentOrderSave(body: PayementOrdersForm | undefined): Observable<PayementOrdersForm> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/PaymentOrderSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentOrderSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentOrderSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayementOrdersForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayementOrdersForm>;
        }));
    }

    protected processPaymentOrderSave(response: HttpResponseBase): Observable<PayementOrdersForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayementOrdersForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayementOrdersForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    oPSaveValidation(body: PayementOrdersForm | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/OPSaveValidation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOPSaveValidation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOPSaveValidation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOPSaveValidation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    paymentOrderDelete(id: number | undefined, body: PayementOrdersForm | undefined): Observable<PayementOrdersForm> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/PaymentOrderDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentOrderDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentOrderDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayementOrdersForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayementOrdersForm>;
        }));
    }

    protected processPaymentOrderDelete(response: HttpResponseBase): Observable<PayementOrdersForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayementOrdersForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayementOrdersForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveValidation(body: PayementOrdersForm | undefined): Observable<PayementOrdersForm> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/SaveValidation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveValidation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveValidation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayementOrdersForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayementOrdersForm>;
        }));
    }

    protected processSaveValidation(response: HttpResponseBase): Observable<PayementOrdersForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayementOrdersForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayementOrdersForm>(null as any);
    }

    /**
     * @param benefBankId (optional) 
     * @return Success
     */
    searchPaymentOrderByBenefBankId(benefBankId: number | undefined): Observable<PaymentOrderExportList[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/SearchPaymentOrderByBenefBankId?";
        if (benefBankId === null)
            throw new Error("The parameter 'benefBankId' cannot be null.");
        else if (benefBankId !== undefined)
            url_ += "benefBankId=" + encodeURIComponent("" + benefBankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPaymentOrderByBenefBankId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPaymentOrderByBenefBankId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentOrderExportList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentOrderExportList[]>;
        }));
    }

    protected processSearchPaymentOrderByBenefBankId(response: HttpResponseBase): Observable<PaymentOrderExportList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentOrderExportList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentOrderExportList[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportOPToCSV(body: number[] | null | undefined): Observable<BTExport[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/ExportOPToCSV";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportOPToCSV(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportOPToCSV(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BTExport[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BTExport[]>;
        }));
    }

    protected processExportOPToCSV(response: HttpResponseBase): Observable<BTExport[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BTExport.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BTExport[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportOPToCSVBin(body: number[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/ExportOPToCSVBin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportOPToCSVBin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportOPToCSVBin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processExportOPToCSVBin(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    finalizeExportedOp(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentOrders/FinalizeExportedOp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinalizeExportedOp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinalizeExportedOp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFinalizeExportedOp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PersonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    thirdPartyAccSetupList(): Observable<GetThirdPartyAccOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/ThirdPartyAccSetupList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThirdPartyAccSetupList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThirdPartyAccSetupList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetThirdPartyAccOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetThirdPartyAccOutput>;
        }));
    }

    protected processThirdPartyAccSetupList(response: HttpResponseBase): Observable<GetThirdPartyAccOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetThirdPartyAccOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetThirdPartyAccOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBankAccSetupById(id: number | undefined): Observable<ThirdPartyAccEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/GetBankAccSetupById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccSetupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccSetupById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThirdPartyAccEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThirdPartyAccEditDto>;
        }));
    }

    protected processGetBankAccSetupById(response: HttpResponseBase): Observable<ThirdPartyAccEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThirdPartyAccEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThirdPartyAccEditDto>(null as any);
    }

    /**
     * @param cui (optional) 
     * @return Success
     */
    anafDateFirma(cui: number | undefined): Observable<DateFirmaAnaf> {
        let url_ = this.baseUrl + "/api/services/app/Person/AnafDateFirma?";
        if (cui === null)
            throw new Error("The parameter 'cui' cannot be null.");
        else if (cui !== undefined)
            url_ += "cui=" + encodeURIComponent("" + cui) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnafDateFirma(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnafDateFirma(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateFirmaAnaf>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateFirmaAnaf>;
        }));
    }

    protected processAnafDateFirma(response: HttpResponseBase): Observable<DateFirmaAnaf> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateFirmaAnaf.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateFirmaAnaf>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveThirdPartySetupAcc(body: ThirdPartyAccEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Person/SaveThirdPartySetupAcc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveThirdPartySetupAcc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveThirdPartySetupAcc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveThirdPartySetupAcc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bankAccountId (optional) 
     * @return Success
     */
    deleteThirdPartySetupAcc(bankAccountId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Person/DeleteThirdPartySetupAcc?";
        if (bankAccountId === null)
            throw new Error("The parameter 'bankAccountId' cannot be null.");
        else if (bankAccountId !== undefined)
            url_ += "bankAccountId=" + encodeURIComponent("" + bankAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteThirdPartySetupAcc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteThirdPartySetupAcc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteThirdPartySetupAcc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    personSetupList(): Observable<PersonListDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/PersonSetupList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonSetupList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonSetupList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonListDto>;
        }));
    }

    protected processPersonSetupList(response: HttpResponseBase): Observable<PersonListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonListDto>(null as any);
    }

    /**
     * @return Success
     */
    bankSetupList(): Observable<GetBankOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/BankSetupList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBankSetupList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBankSetupList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBankOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBankOutput>;
        }));
    }

    protected processBankSetupList(response: HttpResponseBase): Observable<GetBankOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBankOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBankOutput>(null as any);
    }

    /**
     * @return Success
     */
    personList(): Observable<GetPersonOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/PersonList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPersonOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPersonOutput>;
        }));
    }

    protected processPersonList(response: HttpResponseBase): Observable<GetPersonOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPersonOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPersonOutput>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    personListSearch(search: string | null | undefined): Observable<GetPersonOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/PersonListSearch?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonListSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonListSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPersonOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPersonOutput>;
        }));
    }

    protected processPersonListSearch(response: HttpResponseBase): Observable<GetPersonOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPersonOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPersonOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPerson(body: CreatePersonDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Person/CreatePerson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreatePerson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    currencyList(): Observable<GetCurrencyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/CurrencyList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrencyList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrencyList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrencyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrencyOutput>;
        }));
    }

    protected processCurrencyList(response: HttpResponseBase): Observable<GetCurrencyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrencyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrencyOutput>(null as any);
    }

    /**
     * @return Success
     */
    foreignCurrencyList(): Observable<GetCurrencyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/ForeignCurrencyList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForeignCurrencyList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForeignCurrencyList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrencyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrencyOutput>;
        }));
    }

    protected processForeignCurrencyList(response: HttpResponseBase): Observable<GetCurrencyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrencyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrencyOutput>(null as any);
    }

    /**
     * @return Success
     */
    countryList(): Observable<GetCountryOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/CountryList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountryOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountryOutput>;
        }));
    }

    protected processCountryList(response: HttpResponseBase): Observable<GetCountryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCountryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountryOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    regionList(id: number | undefined): Observable<GetRegionOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/RegionList?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRegionOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRegionOutput>;
        }));
    }

    protected processRegionList(response: HttpResponseBase): Observable<GetRegionOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegionOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionOutput>(null as any);
    }

    /**
     * @return Success
     */
    bankList(): Observable<GetBankOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/BankList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBankList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBankList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBankOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBankOutput>;
        }));
    }

    protected processBankList(response: HttpResponseBase): Observable<GetBankOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBankOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBankOutput>(null as any);
    }

    /**
     * @return Success
     */
    thirdPartyList(): Observable<GetThirdPartyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/ThirdPartyList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThirdPartyList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThirdPartyList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetThirdPartyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetThirdPartyOutput>;
        }));
    }

    protected processThirdPartyList(response: HttpResponseBase): Observable<GetThirdPartyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetThirdPartyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetThirdPartyOutput>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    thirdPartySearch(search: string | null | undefined): Observable<GetThirdPartyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/ThirdPartySearch?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThirdPartySearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThirdPartySearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetThirdPartyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetThirdPartyOutput>;
        }));
    }

    protected processThirdPartySearch(response: HttpResponseBase): Observable<GetThirdPartyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetThirdPartyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetThirdPartyOutput>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    thirdPartySearchForDecont(search: string | null | undefined): Observable<GetThirdPartyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/ThirdPartySearchForDecont?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThirdPartySearchForDecont(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThirdPartySearchForDecont(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetThirdPartyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetThirdPartyOutput>;
        }));
    }

    protected processThirdPartySearchForDecont(response: HttpResponseBase): Observable<GetThirdPartyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetThirdPartyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetThirdPartyOutput>(null as any);
    }

    /**
     * @return Success
     */
    thirdPartyDDList(): Observable<ThirdPartyListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/ThirdPartyDDList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThirdPartyDDList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThirdPartyDDList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThirdPartyListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThirdPartyListDDDto[]>;
        }));
    }

    protected processThirdPartyDDList(response: HttpResponseBase): Observable<ThirdPartyListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ThirdPartyListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThirdPartyListDDDto[]>(null as any);
    }

    /**
     * @param thirdPartyId (optional) 
     * @return Success
     */
    thirdPartyAccList(thirdPartyId: number | undefined): Observable<GetThirdPartyAccOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/ThirdPartyAccList?";
        if (thirdPartyId === null)
            throw new Error("The parameter 'thirdPartyId' cannot be null.");
        else if (thirdPartyId !== undefined)
            url_ += "thirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThirdPartyAccList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThirdPartyAccList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetThirdPartyAccOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetThirdPartyAccOutput>;
        }));
    }

    protected processThirdPartyAccList(response: HttpResponseBase): Observable<GetThirdPartyAccOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetThirdPartyAccOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetThirdPartyAccOutput>(null as any);
    }

    /**
     * @return Success
     */
    appClientBankAccountList(): Observable<ThirdPartyAccListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/AppClientBankAccountList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAppClientBankAccountList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAppClientBankAccountList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThirdPartyAccListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThirdPartyAccListDDDto[]>;
        }));
    }

    protected processAppClientBankAccountList(response: HttpResponseBase): Observable<ThirdPartyAccListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ThirdPartyAccListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThirdPartyAccListDDDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPersonById(id: number | undefined): Observable<PersonEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/GetPersonById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonEditDto>;
        }));
    }

    protected processGetPersonById(response: HttpResponseBase): Observable<PersonEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePerson(body: PersonEditDto | undefined): Observable<PersonEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/SavePerson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonEditDto>;
        }));
    }

    protected processSavePerson(response: HttpResponseBase): Observable<PersonEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonEditDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBankAccById(id: number | undefined): Observable<ThirdPartyAccEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/GetBankAccById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThirdPartyAccEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThirdPartyAccEditDto>;
        }));
    }

    protected processGetBankAccById(response: HttpResponseBase): Observable<ThirdPartyAccEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThirdPartyAccEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThirdPartyAccEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveThirdPartyAcc(body: ThirdPartyAccEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Person/SaveThirdPartyAcc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveThirdPartyAcc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveThirdPartyAcc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveThirdPartyAcc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    exchangeRateInit(): Observable<ExchangeRateModelDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/ExchangeRateInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeRateInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeRateInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangeRateModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangeRateModelDto>;
        }));
    }

    protected processExchangeRateInit(response: HttpResponseBase): Observable<ExchangeRateModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExchangeRateModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeRateModelDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchExchangeRates(body: ExchangeRateModelDto | undefined): Observable<ExchangeRateModelDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/SearchExchangeRates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchExchangeRates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchExchangeRates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangeRateModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangeRateModelDto>;
        }));
    }

    protected processSearchExchangeRates(response: HttpResponseBase): Observable<ExchangeRateModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExchangeRateModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeRateModelDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exchangeRateAdd(body: ExchangeRateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Person/ExchangeRateAdd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeRateAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeRateAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExchangeRateAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    exchangeRateDetele(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Person/ExchangeRateDetele?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeRateDetele(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeRateDetele(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExchangeRateDetele(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    exchangeRateId(id: number | undefined): Observable<ExchangeRateDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/ExchangeRateId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeRateId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeRateId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangeRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangeRateDto>;
        }));
    }

    protected processExchangeRateId(response: HttpResponseBase): Observable<ExchangeRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExchangeRateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeRateDto>(null as any);
    }

    /**
     * @param thirdPartyId (optional) 
     * @return Success
     */
    banksForThirdParty(thirdPartyId: number | undefined): Observable<BankListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/BanksForThirdParty?";
        if (thirdPartyId === null)
            throw new Error("The parameter 'thirdPartyId' cannot be null.");
        else if (thirdPartyId !== undefined)
            url_ += "thirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBanksForThirdParty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBanksForThirdParty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankListDto[]>;
        }));
    }

    protected processBanksForThirdParty(response: HttpResponseBase): Observable<BankListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BankListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankListDto[]>(null as any);
    }

    /**
     * @param thirdPartyId (optional) 
     * @param bankId (optional) 
     * @param currencyId (optional) 
     * @return Success
     */
    bankAccountsForThirdParty(thirdPartyId: number | undefined, bankId: number | null | undefined, currencyId: number | undefined): Observable<ThirdPartyAccListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/BankAccountsForThirdParty?";
        if (thirdPartyId === null)
            throw new Error("The parameter 'thirdPartyId' cannot be null.");
        else if (thirdPartyId !== undefined)
            url_ += "thirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        if (bankId !== undefined && bankId !== null)
            url_ += "bankId=" + encodeURIComponent("" + bankId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBankAccountsForThirdParty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBankAccountsForThirdParty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThirdPartyAccListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThirdPartyAccListDto[]>;
        }));
    }

    protected processBankAccountsForThirdParty(response: HttpResponseBase): Observable<ThirdPartyAccListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ThirdPartyAccListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThirdPartyAccListDto[]>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    thirdPartyListDD(search: string | null | undefined): Observable<ThirdPartyListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/ThirdPartyListDD?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThirdPartyListDD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThirdPartyListDD(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThirdPartyListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThirdPartyListDto[]>;
        }));
    }

    protected processThirdPartyListDD(response: HttpResponseBase): Observable<ThirdPartyListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ThirdPartyListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThirdPartyListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getCurrentAppClientName(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Person/GetCurrentAppClientName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentAppClientName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentAppClientName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetCurrentAppClientName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    searchPerson(search: string | null | undefined): Observable<PersonListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/SearchPerson?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonListDto[]>;
        }));
    }

    protected processSearchPerson(response: HttpResponseBase): Observable<PersonListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PersonListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonListDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePerson(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Person/DeletePerson?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePerson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param bankValutaId (optional) 
     * @param currencyId (optional) 
     * @return Success
     */
    bankAccountsForExchangeValuta(bankValutaId: number | undefined, currencyId: number | undefined): Observable<BankAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/BankAccountsForExchangeValuta?";
        if (bankValutaId === null)
            throw new Error("The parameter 'bankValutaId' cannot be null.");
        else if (bankValutaId !== undefined)
            url_ += "bankValutaId=" + encodeURIComponent("" + bankValutaId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBankAccountsForExchangeValuta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBankAccountsForExchangeValuta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankAccountDto[]>;
        }));
    }

    protected processBankAccountsForExchangeValuta(response: HttpResponseBase): Observable<BankAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BankAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountDto[]>(null as any);
    }

    /**
     * @param bankLeiId (optional) 
     * @return Success
     */
    bankAccountsForExchangeLei(bankLeiId: number | undefined): Observable<BankAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/BankAccountsForExchangeLei?";
        if (bankLeiId === null)
            throw new Error("The parameter 'bankLeiId' cannot be null.");
        else if (bankLeiId !== undefined)
            url_ += "bankLeiId=" + encodeURIComponent("" + bankLeiId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBankAccountsForExchangeLei(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBankAccountsForExchangeLei(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankAccountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankAccountDto[]>;
        }));
    }

    protected processBankAccountsForExchangeLei(response: HttpResponseBase): Observable<BankAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BankAccountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountDto[]>(null as any);
    }

    /**
     * @return Success
     */
    bankForExchangeLei(): Observable<BankListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/BankForExchangeLei";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBankForExchangeLei(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBankForExchangeLei(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankListDto[]>;
        }));
    }

    protected processBankForExchangeLei(response: HttpResponseBase): Observable<BankListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BankListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankListDto[]>(null as any);
    }

    /**
     * @param currencyId (optional) 
     * @return Success
     */
    bankForExchangeValuta(currencyId: number | null | undefined): Observable<BankListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/BankForExchangeValuta?";
        if (currencyId !== undefined && currencyId !== null)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBankForExchangeValuta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBankForExchangeValuta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankListDto[]>;
        }));
    }

    protected processBankForExchangeValuta(response: HttpResponseBase): Observable<BankListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BankListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    actualizarePerson(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Person/ActualizarePerson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActualizarePerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActualizarePerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActualizarePerson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    initForm(): Observable<PersonInitForm> {
        let url_ = this.baseUrl + "/api/services/app/Person/InitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonInitForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonInitForm>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<PersonInitForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonInitForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonInitForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchPersonList(body: PersonInitForm | undefined): Observable<PersonListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/SearchPersonList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPersonList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPersonList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonListDto[]>;
        }));
    }

    protected processSearchPersonList(response: HttpResponseBase): Observable<PersonListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PersonListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonListDto[]>(null as any);
    }

    /**
     * @param search (optional) 
     * @return Success
     */
    searchPersonForInvObjectByInput(search: string | null | undefined): Observable<GetThirdPartyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Person/SearchPersonForInvObjectByInput?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPersonForInvObjectByInput(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPersonForInvObjectByInput(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetThirdPartyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetThirdPartyOutput>;
        }));
    }

    protected processSearchPersonForInvObjectByInput(response: HttpResponseBase): Observable<GetThirdPartyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetThirdPartyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetThirdPartyOutput>(null as any);
    }
}

@Injectable()
export class PrepaymentBalanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param prepaymentType (optional) 
     * @return Success
     */
    initForm(prepaymentType: number | undefined): Observable<PrepaymentsBalanceListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentBalance/InitForm?";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsBalanceListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsBalanceListDto>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<PrepaymentsBalanceListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsBalanceListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsBalanceListDto>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @param prepaymentType (optional) 
     * @return Success
     */
    prepaymentsListDD(dataStart: moment.Moment | null | undefined, dataEnd: moment.Moment | null | undefined, prepaymentType: number | undefined): Observable<PrepaymentsDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentBalance/PrepaymentsListDD?";
        if (dataStart !== undefined && dataStart !== null)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd !== undefined && dataEnd !== null)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepaymentsListDD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepaymentsListDD(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsDDDto[]>;
        }));
    }

    protected processPrepaymentsListDD(response: HttpResponseBase): Observable<PrepaymentsDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PrepaymentsDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsDDDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    serchGest(body: PrepaymentsBalanceListDto | undefined): Observable<PrepaymentsBalanceListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentBalance/SerchGest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSerchGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSerchGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsBalanceListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsBalanceListDto>;
        }));
    }

    protected processSerchGest(response: HttpResponseBase): Observable<PrepaymentsBalanceListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsBalanceListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsBalanceListDto>(null as any);
    }

    /**
     * @param prepaymentType (optional) 
     * @return Success
     */
    initFormCompute(prepaymentType: number | undefined): Observable<PrepaymentsBalanceComputeListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentBalance/InitFormCompute?";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitFormCompute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitFormCompute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsBalanceComputeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsBalanceComputeListDto>;
        }));
    }

    protected processInitFormCompute(response: HttpResponseBase): Observable<PrepaymentsBalanceComputeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsBalanceComputeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsBalanceComputeListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    serchComputeOper(body: PrepaymentsBalanceComputeListDto | undefined): Observable<PrepaymentsBalanceComputeListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentBalance/SerchComputeOper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSerchComputeOper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSerchComputeOper(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsBalanceComputeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsBalanceComputeListDto>;
        }));
    }

    protected processSerchComputeOper(response: HttpResponseBase): Observable<PrepaymentsBalanceComputeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsBalanceComputeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsBalanceComputeListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    computeDateGest(body: PrepaymentsBalanceComputeListDto | undefined): Observable<PrepaymentsBalanceComputeListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentBalance/ComputeDateGest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComputeDateGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComputeDateGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsBalanceComputeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsBalanceComputeListDto>;
        }));
    }

    protected processComputeDateGest(response: HttpResponseBase): Observable<PrepaymentsBalanceComputeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsBalanceComputeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsBalanceComputeListDto>(null as any);
    }

    /**
     * @param prepaymentType (optional) 
     * @return Success
     */
    initFormDel(prepaymentType: number | undefined): Observable<PrepaymentsBalanceDelListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentBalance/InitFormDel?";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitFormDel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitFormDel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsBalanceDelListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsBalanceDelListDto>;
        }));
    }

    protected processInitFormDel(response: HttpResponseBase): Observable<PrepaymentsBalanceDelListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsBalanceDelListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsBalanceDelListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    serchDateGest(body: PrepaymentsBalanceDelListDto | undefined): Observable<PrepaymentsBalanceDelListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentBalance/SerchDateGest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSerchDateGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSerchDateGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsBalanceDelListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsBalanceDelListDto>;
        }));
    }

    protected processSerchDateGest(response: HttpResponseBase): Observable<PrepaymentsBalanceDelListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsBalanceDelListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsBalanceDelListDto>(null as any);
    }

    /**
     * @param prepaymentType (optional) 
     * @param deleteDate (optional) 
     * @return Success
     */
    deleteDateGest(prepaymentType: PrepaymentType | undefined, deleteDate: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentBalance/DeleteDateGest?";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        if (deleteDate === null)
            throw new Error("The parameter 'deleteDate' cannot be null.");
        else if (deleteDate !== undefined)
            url_ += "deleteDate=" + encodeURIComponent(deleteDate ? "" + deleteDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDateGest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDateGest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDateGest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PrepaymentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param prepaymentType (optional) 
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    prepaymentsEntryList(prepaymentType: number | undefined, dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined): Observable<PrepaymentsListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/PrepaymentsEntryList?";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepaymentsEntryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepaymentsEntryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsListDto[]>;
        }));
    }

    protected processPrepaymentsEntryList(response: HttpResponseBase): Observable<PrepaymentsListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PrepaymentsListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsListDto[]>(null as any);
    }

    /**
     * @param prepaymentType (optional) 
     * @return Success
     */
    addFromInvoiceInit(prepaymentType: number | undefined): Observable<PrepaymentsAddDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/AddFromInvoiceInit?";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFromInvoiceInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFromInvoiceInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsAddDto>;
        }));
    }

    protected processAddFromInvoiceInit(response: HttpResponseBase): Observable<PrepaymentsAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsAddDto>(null as any);
    }

    /**
     * @param formNr (optional) 
     * @param body (optional) 
     * @return Success
     */
    showForm(formNr: number | undefined, body: PrepaymentsAddDto | undefined): Observable<PrepaymentsAddDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/ShowForm?";
        if (formNr === null)
            throw new Error("The parameter 'formNr' cannot be null.");
        else if (formNr !== undefined)
            url_ += "formNr=" + encodeURIComponent("" + formNr) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsAddDto>;
        }));
    }

    protected processShowForm(response: HttpResponseBase): Observable<PrepaymentsAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsAddDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    invoiceDetails(body: PrepaymentsAddDto | undefined): Observable<PrepaymentsAddDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/InvoiceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsAddDto>;
        }));
    }

    protected processInvoiceDetails(response: HttpResponseBase): Observable<PrepaymentsAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsAddDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePrepayments(body: PrepaymentsAddDto | undefined): Observable<PrepaymentsAddDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/SavePrepayments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePrepayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePrepayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsAddDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsAddDto>;
        }));
    }

    protected processSavePrepayments(response: HttpResponseBase): Observable<PrepaymentsAddDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsAddDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsAddDto>(null as any);
    }

    /**
     * @param prepaymentId (optional) 
     * @return Success
     */
    deletePrepayment(prepaymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/DeletePrepayment?";
        if (prepaymentId === null)
            throw new Error("The parameter 'prepaymentId' cannot be null.");
        else if (prepaymentId !== undefined)
            url_ += "prepaymentId=" + encodeURIComponent("" + prepaymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePrepayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePrepayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePrepayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param prepaymentId (optional) 
     * @param prepaymentType (optional) 
     * @return Success
     */
    addDirectInit(prepaymentId: number | undefined, prepaymentType: number | undefined): Observable<PrepaymentsAddDirectDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/AddDirectInit?";
        if (prepaymentId === null)
            throw new Error("The parameter 'prepaymentId' cannot be null.");
        else if (prepaymentId !== undefined)
            url_ += "prepaymentId=" + encodeURIComponent("" + prepaymentId) + "&";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDirectInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDirectInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsAddDirectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsAddDirectDto>;
        }));
    }

    protected processAddDirectInit(response: HttpResponseBase): Observable<PrepaymentsAddDirectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsAddDirectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsAddDirectDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePrepaymentDirect(body: PrepaymentsAddDirectDto | undefined): Observable<PrepaymentsAddDirectDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/SavePrepaymentDirect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePrepaymentDirect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePrepaymentDirect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsAddDirectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsAddDirectDto>;
        }));
    }

    protected processSavePrepaymentDirect(response: HttpResponseBase): Observable<PrepaymentsAddDirectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsAddDirectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsAddDirectDto>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param modCalcul (optional) 
     * @return Success
     */
    calcDurata(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, modCalcul: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/CalcDurata?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (modCalcul === null)
            throw new Error("The parameter 'modCalcul' cannot be null.");
        else if (modCalcul !== undefined)
            url_ += "modCalcul=" + encodeURIComponent("" + modCalcul) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcDurata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcDurata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCalcDurata(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param prepaymentId (optional) 
     * @param prepaymentType (optional) 
     * @return Success
     */
    prepaymentsExitInit(prepaymentId: number | undefined, prepaymentType: number | undefined): Observable<PrepaymentsExitDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/PrepaymentsExitInit?";
        if (prepaymentId === null)
            throw new Error("The parameter 'prepaymentId' cannot be null.");
        else if (prepaymentId !== undefined)
            url_ += "prepaymentId=" + encodeURIComponent("" + prepaymentId) + "&";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepaymentsExitInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepaymentsExitInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsExitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsExitDto>;
        }));
    }

    protected processPrepaymentsExitInit(response: HttpResponseBase): Observable<PrepaymentsExitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsExitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsExitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePrepaymentExit(body: PrepaymentsExitDto | undefined): Observable<PrepaymentsExitDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/SavePrepaymentExit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePrepaymentExit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePrepaymentExit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsExitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsExitDto>;
        }));
    }

    protected processSavePrepaymentExit(response: HttpResponseBase): Observable<PrepaymentsExitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsExitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsExitDto>(null as any);
    }

    /**
     * @param prepaymentType (optional) 
     * @return Success
     */
    durationSetupDetails(prepaymentType: number | undefined): Observable<PrepaymentsDurationSetupDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/DurationSetupDetails?";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDurationSetupDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDurationSetupDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsDurationSetupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsDurationSetupDto>;
        }));
    }

    protected processDurationSetupDetails(response: HttpResponseBase): Observable<PrepaymentsDurationSetupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsDurationSetupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsDurationSetupDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    durationSetupSave(body: PrepaymentsDurationSetupDto | undefined): Observable<PrepaymentsDurationSetupDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/DurationSetupSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDurationSetupSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDurationSetupSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsDurationSetupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsDurationSetupDto>;
        }));
    }

    protected processDurationSetupSave(response: HttpResponseBase): Observable<PrepaymentsDurationSetupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsDurationSetupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsDurationSetupDto>(null as any);
    }

    /**
     * @param prepaymentType (optional) 
     * @return Success
     */
    decDeprecSetupDetails(prepaymentType: number | undefined): Observable<PrepaymentsDecDeprecSetupDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/DecDeprecSetupDetails?";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDecDeprecSetupDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDecDeprecSetupDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsDecDeprecSetupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsDecDeprecSetupDto>;
        }));
    }

    protected processDecDeprecSetupDetails(response: HttpResponseBase): Observable<PrepaymentsDecDeprecSetupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsDecDeprecSetupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsDecDeprecSetupDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    decDeprecSetupSave(body: PrepaymentsDecDeprecSetupDto | undefined): Observable<PrepaymentsDecDeprecSetupDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/DecDeprecSetupSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDecDeprecSetupSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDecDeprecSetupSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsDecDeprecSetupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsDecDeprecSetupDto>;
        }));
    }

    protected processDecDeprecSetupSave(response: HttpResponseBase): Observable<PrepaymentsDecDeprecSetupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsDecDeprecSetupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsDecDeprecSetupDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addDirectChangeDate(body: PrepaymentsAddDirectDto | undefined): Observable<PrepaymentsAddDirectDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/AddDirectChangeDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDirectChangeDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDirectChangeDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsAddDirectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsAddDirectDto>;
        }));
    }

    protected processAddDirectChangeDate(response: HttpResponseBase): Observable<PrepaymentsAddDirectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsAddDirectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsAddDirectDto>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    getPrepaymentsForInvoiceDetails(invoiceId: number | undefined): Observable<PrepaymentsListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Prepayments/GetPrepaymentsForInvoiceDetails?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrepaymentsForInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrepaymentsForInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsListDto[]>;
        }));
    }

    protected processGetPrepaymentsForInvoiceDetails(response: HttpResponseBase): Observable<PrepaymentsListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PrepaymentsListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsListDto[]>(null as any);
    }
}

@Injectable()
export class PrepaymentsOperDocTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    operDocTypeList(): Observable<GetPrepaymentsOperDocTypeOutput> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentsOperDocType/OperDocTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperDocTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperDocTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPrepaymentsOperDocTypeOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPrepaymentsOperDocTypeOutput>;
        }));
    }

    protected processOperDocTypeList(response: HttpResponseBase): Observable<GetPrepaymentsOperDocTypeOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPrepaymentsOperDocTypeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPrepaymentsOperDocTypeOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOperDocTypeById(id: number | undefined): Observable<PrepaymentsOperDocTypeEditDto> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentsOperDocType/GetOperDocTypeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperDocTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperDocTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsOperDocTypeEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsOperDocTypeEditDto>;
        }));
    }

    protected processGetOperDocTypeById(response: HttpResponseBase): Observable<PrepaymentsOperDocTypeEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsOperDocTypeEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsOperDocTypeEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveOperDocType(body: PrepaymentsOperDocTypeEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentsOperDocType/SaveOperDocType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOperDocType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOperDocType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveOperDocType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOperDocType(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentsOperDocType/DeleteOperDocType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperDocType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperDocType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOperDocType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PrepaymentsReportingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param repDate (optional) 
     * @param prepaymentType (optional) 
     * @return Success
     */
    prepaymentsRegReport(repDate: moment.Moment | undefined, prepaymentType: number | undefined): Observable<PrepaymentsRegistruReport> {
        let url_ = this.baseUrl + "/api/services/app/PrepaymentsReporting/PrepaymentsRegReport?";
        if (repDate === null)
            throw new Error("The parameter 'repDate' cannot be null.");
        else if (repDate !== undefined)
            url_ += "repDate=" + encodeURIComponent(repDate ? "" + repDate.toISOString() : "") + "&";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepaymentsRegReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepaymentsRegReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsRegistruReport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsRegistruReport>;
        }));
    }

    protected processPrepaymentsRegReport(response: HttpResponseBase): Observable<PrepaymentsRegistruReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsRegistruReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsRegistruReport>(null as any);
    }
}

@Injectable()
export class RataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    rataListId(imprumutId: number | undefined): Observable<RataDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Rata/RataListId?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRataListId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRataListId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RataDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RataDto[]>;
        }));
    }

    protected processRataListId(response: HttpResponseBase): Observable<RataDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RataDto[]>(null as any);
    }

    /**
     * @return Success
     */
    rataList(): Observable<RataDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Rata/RataList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRataList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRataList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RataDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RataDto[]>;
        }));
    }

    protected processRataList(response: HttpResponseBase): Observable<RataDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RataDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRataId(id: number | undefined): Observable<RataEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Rata/GetRataId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRataId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRataId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RataEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RataEditDto>;
        }));
    }

    protected processGetRataId(response: HttpResponseBase): Observable<RataEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RataEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RataEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    regenerareScadentarDeLaRandCurent(body: RataEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rata/RegenerareScadentarDeLaRandCurent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegenerareScadentarDeLaRandCurent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegenerareScadentarDeLaRandCurent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegenerareScadentarDeLaRandCurent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveRata(body: RataEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rata/SaveRata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveRata(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param rataId (optional) 
     * @return Success
     */
    generatePlataConta(rataId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rata/GeneratePlataConta?";
        if (rataId === null)
            throw new Error("The parameter 'rataId' cannot be null.");
        else if (rataId !== undefined)
            url_ += "rataId=" + encodeURIComponent("" + rataId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePlataConta(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePlataConta(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGeneratePlataConta(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateRateOrientativeRataDescrescatoare(body: RataEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rata/GenerateRateOrientativeRataDescrescatoare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateRateOrientativeRataDescrescatoare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateRateOrientativeRataDescrescatoare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateRateOrientativeRataDescrescatoare(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateRateOrientativeRataTotalaEgala(body: RataEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rata/GenerateRateOrientativeRataTotalaEgala";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateRateOrientativeRataTotalaEgala(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateRateOrientativeRataTotalaEgala(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateRateOrientativeRataTotalaEgala(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imprumutId (optional) 
     * @param dataPlataRata (optional) 
     * @return Success
     */
    deleteAllRateIdDate(imprumutId: number | undefined, dataPlataRata: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rata/DeleteAllRateIdDate?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        if (dataPlataRata === null)
            throw new Error("The parameter 'dataPlataRata' cannot be null.");
        else if (dataPlataRata !== undefined)
            url_ += "dataPlataRata=" + encodeURIComponent(dataPlataRata ? "" + dataPlataRata.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllRateIdDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllRateIdDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllRateIdDate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRata(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rata/DeleteRata?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRata(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class RegInventarServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param reportDate (optional) 
     * @return Success
     */
    recalculRegInventar(reportDate: moment.Moment | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RegInventar/RecalculRegInventar?";
        if (reportDate === null)
            throw new Error("The parameter 'reportDate' cannot be null.");
        else if (reportDate !== undefined)
            url_ += "reportDate=" + encodeURIComponent(reportDate ? "" + reportDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecalculRegInventar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecalculRegInventar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRecalculRegInventar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class RegInventarExceptiiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param regInventarId (optional) 
     * @return Success
     */
    deleteExceptRegInventar(regInventarId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RegInventarExceptii/DeleteExceptRegInventar?";
        if (regInventarId === null)
            throw new Error("The parameter 'regInventarId' cannot be null.");
        else if (regInventarId !== undefined)
            url_ += "regInventarId=" + encodeURIComponent("" + regInventarId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteExceptRegInventar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExceptRegInventar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteExceptRegInventar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getRegInventarInit(): Observable<GetRegInventarOutput> {
        let url_ = this.baseUrl + "/api/services/app/RegInventarExceptii/GetRegInventarInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegInventarInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegInventarInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRegInventarOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRegInventarOutput>;
        }));
    }

    protected processGetRegInventarInit(response: HttpResponseBase): Observable<GetRegInventarOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegInventarOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegInventarOutput>(null as any);
    }

    /**
     * @param regList (optional) 
     * @return Success
     */
    getExceptRegInventarList(regList: RegInventarExceptiiListDto[] | null | undefined): Observable<RegInventarExceptiiListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RegInventarExceptii/GetExceptRegInventarList?";
        if (regList !== undefined && regList !== null)
            regList && regList.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "regList[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExceptRegInventarList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExceptRegInventarList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegInventarExceptiiListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegInventarExceptiiListDto[]>;
        }));
    }

    protected processGetExceptRegInventarList(response: HttpResponseBase): Observable<RegInventarExceptiiListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegInventarExceptiiListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegInventarExceptiiListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exceptRegInventarAddRow(body: RegInventarExceptiiListDto[] | null | undefined): Observable<RegInventarExceptiiListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RegInventarExceptii/ExceptRegInventarAddRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExceptRegInventarAddRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExceptRegInventarAddRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegInventarExceptiiListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegInventarExceptiiListDto[]>;
        }));
    }

    protected processExceptRegInventarAddRow(response: HttpResponseBase): Observable<RegInventarExceptiiListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegInventarExceptiiListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegInventarExceptiiListDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveExceptRegInventar(body: RegInventarExceptiiListDto[] | null | undefined): Observable<RegInventarExceptiiListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RegInventarExceptii/SaveExceptRegInventar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveExceptRegInventar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveExceptRegInventar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegInventarExceptiiListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegInventarExceptiiListDto[]>;
        }));
    }

    protected processSaveExceptRegInventar(response: HttpResponseBase): Observable<RegInventarExceptiiListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegInventarExceptiiListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegInventarExceptiiListDto[]>(null as any);
    }
}

@Injectable()
export class RegInventarExceptiiEliminareServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param regInventarId (optional) 
     * @return Success
     */
    deleteExceptRegInventar(regInventarId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RegInventarExceptiiEliminare/DeleteExceptRegInventar?";
        if (regInventarId === null)
            throw new Error("The parameter 'regInventarId' cannot be null.");
        else if (regInventarId !== undefined)
            url_ += "regInventarId=" + encodeURIComponent("" + regInventarId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteExceptRegInventar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExceptRegInventar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteExceptRegInventar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exceptEliminareRegInventarAddRow(body: ExceptEliminareRegInventarListDto[] | null | undefined): Observable<ExceptEliminareRegInventarListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RegInventarExceptiiEliminare/ExceptEliminareRegInventarAddRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExceptEliminareRegInventarAddRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExceptEliminareRegInventarAddRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExceptEliminareRegInventarListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExceptEliminareRegInventarListDto[]>;
        }));
    }

    protected processExceptEliminareRegInventarAddRow(response: HttpResponseBase): Observable<ExceptEliminareRegInventarListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExceptEliminareRegInventarListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExceptEliminareRegInventarListDto[]>(null as any);
    }

    /**
     * @param regList (optional) 
     * @return Success
     */
    getExceptEliminareRegInventarList(regList: ExceptEliminareRegInventarListDto[] | null | undefined): Observable<ExceptEliminareRegInventarListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RegInventarExceptiiEliminare/GetExceptEliminareRegInventarList?";
        if (regList !== undefined && regList !== null)
            regList && regList.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "regList[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExceptEliminareRegInventarList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExceptEliminareRegInventarList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExceptEliminareRegInventarListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExceptEliminareRegInventarListDto[]>;
        }));
    }

    protected processGetExceptEliminareRegInventarList(response: HttpResponseBase): Observable<ExceptEliminareRegInventarListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExceptEliminareRegInventarListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExceptEliminareRegInventarListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getRegInventarInit(): Observable<GetExceptElimRegInventarOutput> {
        let url_ = this.baseUrl + "/api/services/app/RegInventarExceptiiEliminare/GetRegInventarInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegInventarInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegInventarInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetExceptElimRegInventarOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetExceptElimRegInventarOutput>;
        }));
    }

    protected processGetRegInventarInit(response: HttpResponseBase): Observable<GetExceptElimRegInventarOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExceptElimRegInventarOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExceptElimRegInventarOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveExceptEliminareRegInventar(body: ExceptEliminareRegInventarListDto[] | null | undefined): Observable<ExceptEliminareRegInventarListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RegInventarExceptiiEliminare/SaveExceptEliminareRegInventar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveExceptEliminareRegInventar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveExceptEliminareRegInventar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExceptEliminareRegInventarListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExceptEliminareRegInventarListDto[]>;
        }));
    }

    protected processSaveExceptEliminareRegInventar(response: HttpResponseBase): Observable<ExceptEliminareRegInventarListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExceptEliminareRegInventarListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExceptEliminareRegInventarListDto[]>(null as any);
    }
}

@Injectable()
export class ReportConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param repId (optional) 
     * @return Success
     */
    delete(repId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/Delete?";
        if (repId === null)
            throw new Error("The parameter 'repId' cannot be null.");
        else if (repId !== undefined)
            url_ += "repId=" + encodeURIComponent("" + repId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param repId (optional) 
     * @return Success
     */
    editRep(repId: number | null | undefined): Observable<RepConfigEditDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/EditRep?";
        if (repId !== undefined && repId !== null)
            url_ += "repId=" + encodeURIComponent("" + repId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepConfigEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepConfigEditDto>;
        }));
    }

    protected processEditRep(response: HttpResponseBase): Observable<RepConfigEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepConfigEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepConfigEditDto>(null as any);
    }

    /**
     * @param repConfigId (optional) 
     * @return Success
     */
    initForm(repConfigId: number | undefined): Observable<ReportConfigForm> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/InitForm?";
        if (repConfigId === null)
            throw new Error("The parameter 'repConfigId' cannot be null.");
        else if (repConfigId !== undefined)
            url_ += "repConfigId=" + encodeURIComponent("" + repConfigId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportConfigForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportConfigForm>;
        }));
    }

    protected processInitForm(response: HttpResponseBase): Observable<ReportConfigForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportConfigForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportConfigForm>(null as any);
    }

    /**
     * @return Success
     */
    reportInitList(): Observable<RepConfigInitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/ReportInitList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportInitList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportInitList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepConfigInitDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepConfigInitDto[]>;
        }));
    }

    protected processReportInitList(response: HttpResponseBase): Observable<RepConfigInitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RepConfigInitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepConfigInitDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveReport(body: RepConfigEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/SaveReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param index (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(index: number | undefined, body: ReportConfigForm | undefined): Observable<ReportConfigForm> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/Save?";
        if (index === null)
            throw new Error("The parameter 'index' cannot be null.");
        else if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportConfigForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportConfigForm>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ReportConfigForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportConfigForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportConfigForm>(null as any);
    }

    /**
     * @param reportId (optional) 
     * @param body (optional) 
     * @return Success
     */
    reportDelete(reportId: number | undefined, body: ReportConfigForm | undefined): Observable<ReportConfigForm> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/ReportDelete?";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportConfigForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportConfigForm>;
        }));
    }

    protected processReportDelete(response: HttpResponseBase): Observable<ReportConfigForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportConfigForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportConfigForm>(null as any);
    }

    /**
     * @param repConfigId (optional) 
     * @param reportId (optional) 
     * @return Success
     */
    formulaInit(repConfigId: number | undefined, reportId: number | undefined): Observable<ReportConfigFormulaForm> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/FormulaInit?";
        if (repConfigId === null)
            throw new Error("The parameter 'repConfigId' cannot be null.");
        else if (repConfigId !== undefined)
            url_ += "repConfigId=" + encodeURIComponent("" + repConfigId) + "&";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormulaInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormulaInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportConfigFormulaForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportConfigFormulaForm>;
        }));
    }

    protected processFormulaInit(response: HttpResponseBase): Observable<ReportConfigFormulaForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportConfigFormulaForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportConfigFormulaForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    formulaList(body: ReportConfigFormulaForm | undefined): Observable<ReportConfigFormulaForm> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/FormulaList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormulaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormulaList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportConfigFormulaForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportConfigFormulaForm>;
        }));
    }

    protected processFormulaList(response: HttpResponseBase): Observable<ReportConfigFormulaForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportConfigFormulaForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportConfigFormulaForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    repFormulaAddRow(body: ReportConfigFormulaForm | undefined): Observable<ReportConfigFormulaForm> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/RepFormulaAddRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepFormulaAddRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepFormulaAddRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportConfigFormulaForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportConfigFormulaForm>;
        }));
    }

    protected processRepFormulaAddRow(response: HttpResponseBase): Observable<ReportConfigFormulaForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportConfigFormulaForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportConfigFormulaForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    repFormulaSave(body: ReportConfigFormulaForm | undefined): Observable<ReportConfigFormulaForm> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/RepFormulaSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepFormulaSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepFormulaSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportConfigFormulaForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportConfigFormulaForm>;
        }));
    }

    protected processRepFormulaSave(response: HttpResponseBase): Observable<ReportConfigFormulaForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportConfigFormulaForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportConfigFormulaForm>(null as any);
    }

    /**
     * @return Success
     */
    calcReportList(): Observable<CalcRapListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ReportConfig/CalcReportList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcReportList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcReportList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CalcRapListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CalcRapListDto[]>;
        }));
    }

    protected processCalcReportList(response: HttpResponseBase): Observable<CalcRapListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CalcRapListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CalcRapListDto[]>(null as any);
    }
}

@Injectable()
export class ReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    balanceDDList(): Observable<BalanceDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Reports/BalanceDDList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceDDList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceDDList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceDDDto[]>;
        }));
    }

    protected processBalanceDDList(response: HttpResponseBase): Observable<BalanceDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BalanceDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceDDDto[]>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @param currencyType (optional) 
     * @param startAccount (optional) 
     * @param endAccount (optional) 
     * @param nivelRand (optional) 
     * @return Success
     */
    reportBalance(balanceId: number | undefined, currencyType: number | undefined, startAccount: string | null | undefined, endAccount: string | null | undefined, nivelRand: number | null | undefined): Observable<BalanceView> {
        let url_ = this.baseUrl + "/api/services/app/Reports/ReportBalance?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        if (currencyType === null)
            throw new Error("The parameter 'currencyType' cannot be null.");
        else if (currencyType !== undefined)
            url_ += "currencyType=" + encodeURIComponent("" + currencyType) + "&";
        if (startAccount !== undefined && startAccount !== null)
            url_ += "startAccount=" + encodeURIComponent("" + startAccount) + "&";
        if (endAccount !== undefined && endAccount !== null)
            url_ += "endAccount=" + encodeURIComponent("" + endAccount) + "&";
        if (nivelRand !== undefined && nivelRand !== null)
            url_ += "nivelRand=" + encodeURIComponent("" + nivelRand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceView>;
        }));
    }

    protected processReportBalance(response: HttpResponseBase): Observable<BalanceView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BalanceView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceView>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @param currencyType (optional) 
     * @param startAccount (optional) 
     * @param endAccount (optional) 
     * @param nivelRand (optional) 
     * @return Success
     */
    reportBalanceCurrency(balanceId: number | undefined, currencyType: number | undefined, startAccount: string | null | undefined, endAccount: string | null | undefined, nivelRand: number | null | undefined): Observable<BalanceView[]> {
        let url_ = this.baseUrl + "/api/services/app/Reports/ReportBalanceCurrency?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        if (currencyType === null)
            throw new Error("The parameter 'currencyType' cannot be null.");
        else if (currencyType !== undefined)
            url_ += "currencyType=" + encodeURIComponent("" + currencyType) + "&";
        if (startAccount !== undefined && startAccount !== null)
            url_ += "startAccount=" + encodeURIComponent("" + startAccount) + "&";
        if (endAccount !== undefined && endAccount !== null)
            url_ += "endAccount=" + encodeURIComponent("" + endAccount) + "&";
        if (nivelRand !== undefined && nivelRand !== null)
            url_ += "nivelRand=" + encodeURIComponent("" + nivelRand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportBalanceCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportBalanceCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalanceView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalanceView[]>;
        }));
    }

    protected processReportBalanceCurrency(response: HttpResponseBase): Observable<BalanceView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BalanceView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceView[]>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @param searchAccount (optional) 
     * @param nivelRand (optional) 
     * @param currencyId (optional) 
     * @return Success
     */
    savedBalanceReport(savedBalanceId: number | undefined, searchAccount: string | null | undefined, nivelRand: number | null | undefined, currencyId: number | undefined): Observable<SavedBalanceViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Reports/SavedBalanceReport?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        if (searchAccount !== undefined && searchAccount !== null)
            url_ += "searchAccount=" + encodeURIComponent("" + searchAccount) + "&";
        if (nivelRand !== undefined && nivelRand !== null)
            url_ += "nivelRand=" + encodeURIComponent("" + nivelRand) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavedBalanceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavedBalanceReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SavedBalanceViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SavedBalanceViewDto>;
        }));
    }

    protected processSavedBalanceReport(response: HttpResponseBase): Observable<SavedBalanceViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SavedBalanceViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SavedBalanceViewDto>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param currencyId (optional) 
     * @param docTypeId (optional) 
     * @param opStatus (optional) 
     * @param searchAccount1 (optional) 
     * @param searchAccount2 (optional) 
     * @return Success
     */
    registruJurnalReport(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, currencyId: number | undefined, docTypeId: number | undefined, opStatus: number | undefined, searchAccount1: string | null | undefined, searchAccount2: string | null | undefined): Observable<RegistruJurnal> {
        let url_ = this.baseUrl + "/api/services/app/Reports/RegistruJurnalReport?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (docTypeId === null)
            throw new Error("The parameter 'docTypeId' cannot be null.");
        else if (docTypeId !== undefined)
            url_ += "docTypeId=" + encodeURIComponent("" + docTypeId) + "&";
        if (opStatus === null)
            throw new Error("The parameter 'opStatus' cannot be null.");
        else if (opStatus !== undefined)
            url_ += "opStatus=" + encodeURIComponent("" + opStatus) + "&";
        if (searchAccount1 !== undefined && searchAccount1 !== null)
            url_ += "searchAccount1=" + encodeURIComponent("" + searchAccount1) + "&";
        if (searchAccount2 !== undefined && searchAccount2 !== null)
            url_ += "searchAccount2=" + encodeURIComponent("" + searchAccount2) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistruJurnalReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistruJurnalReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistruJurnal>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistruJurnal>;
        }));
    }

    protected processRegistruJurnalReport(response: HttpResponseBase): Observable<RegistruJurnal> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistruJurnal.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistruJurnal>(null as any);
    }

    /**
     * @return Success
     */
    currencyDDList(): Observable<CurrencyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Reports/CurrencyDDList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrencyDDList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrencyDDList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto[]>;
        }));
    }

    protected processCurrencyDDList(response: HttpResponseBase): Observable<CurrencyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CurrencyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto[]>(null as any);
    }

    /**
     * @return Success
     */
    documentTypeList(): Observable<DocumentTypeListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Reports/DocumentTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentTypeListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentTypeListDDDto[]>;
        }));
    }

    protected processDocumentTypeList(response: HttpResponseBase): Observable<DocumentTypeListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DocumentTypeListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeListDDDto[]>(null as any);
    }

    /**
     * @return Success
     */
    fisaContInit(): Observable<FisaContModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/FisaContInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFisaContInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFisaContInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FisaContModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FisaContModel>;
        }));
    }

    protected processFisaContInit(response: HttpResponseBase): Observable<FisaContModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FisaContModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FisaContModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    fisaContView(body: FisaContModel | undefined): Observable<FisaContModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/FisaContView";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFisaContView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFisaContView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FisaContModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FisaContModel>;
        }));
    }

    protected processFisaContView(response: HttpResponseBase): Observable<FisaContModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FisaContModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FisaContModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    fisaContChangeCoresp(body: FisaContModel | undefined): Observable<FisaContModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/FisaContChangeCoresp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFisaContChangeCoresp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFisaContChangeCoresp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FisaContModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FisaContModel>;
        }));
    }

    protected processFisaContChangeCoresp(response: HttpResponseBase): Observable<FisaContModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FisaContModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FisaContModel>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param currencyId (optional) 
     * @param corespAccountId (optional) 
     * @return Success
     */
    fisaContReport(accountId: number | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, currencyId: number | undefined, corespAccountId: number | null | undefined): Observable<FisaContModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/FisaContReport?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (corespAccountId !== undefined && corespAccountId !== null)
            url_ += "corespAccountId=" + encodeURIComponent("" + corespAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFisaContReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFisaContReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FisaContModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FisaContModel>;
        }));
    }

    protected processFisaContReport(response: HttpResponseBase): Observable<FisaContModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FisaContModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FisaContModel>(null as any);
    }

    /**
     * @return Success
     */
    accountList(): Observable<AccountListDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Reports/AccountList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountListDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountListDDDto[]>;
        }));
    }

    protected processAccountList(response: HttpResponseBase): Observable<AccountListDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountListDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDDDto[]>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @param currencyId (optional) 
     * @return Success
     */
    registruCasaDateRange(dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined, currencyId: number | undefined): Observable<RegistruCasaModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Reports/RegistruCasaDateRange?";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistruCasaDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistruCasaDateRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistruCasaModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistruCasaModel[]>;
        }));
    }

    protected processRegistruCasaDateRange(response: HttpResponseBase): Observable<RegistruCasaModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RegistruCasaModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistruCasaModel[]>(null as any);
    }

    /**
     * @param dataEnd (optional) 
     * @param currencyId (optional) 
     * @return Success
     */
    registruCasa(dataEnd: moment.Moment | undefined, currencyId: number | undefined): Observable<RegistruCasaModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/RegistruCasa?";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistruCasa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistruCasa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistruCasaModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistruCasaModel>;
        }));
    }

    protected processRegistruCasa(response: HttpResponseBase): Observable<RegistruCasaModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistruCasaModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistruCasaModel>(null as any);
    }

    /**
     * @param repDate (optional) 
     * @param prepaymentType (optional) 
     * @return Success
     */
    prepaymentsRegReport(repDate: moment.Moment | undefined, prepaymentType: number | undefined): Observable<PrepaymentsRegistruReport> {
        let url_ = this.baseUrl + "/api/services/app/Reports/PrepaymentsRegReport?";
        if (repDate === null)
            throw new Error("The parameter 'repDate' cannot be null.");
        else if (repDate !== undefined)
            url_ += "repDate=" + encodeURIComponent(repDate ? "" + repDate.toISOString() : "") + "&";
        if (prepaymentType === null)
            throw new Error("The parameter 'prepaymentType' cannot be null.");
        else if (prepaymentType !== undefined)
            url_ += "prepaymentType=" + encodeURIComponent("" + prepaymentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepaymentsRegReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepaymentsRegReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrepaymentsRegistruReport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrepaymentsRegistruReport>;
        }));
    }

    protected processPrepaymentsRegReport(response: HttpResponseBase): Observable<PrepaymentsRegistruReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaymentsRegistruReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaymentsRegistruReport>(null as any);
    }

    /**
     * @param inventoryNr (optional) 
     * @return Success
     */
    inventoryNrExists(inventoryNr: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Reports/InventoryNrExists?";
        if (inventoryNr === null)
            throw new Error("The parameter 'inventoryNr' cannot be null.");
        else if (inventoryNr !== undefined)
            url_ += "inventoryNr=" + encodeURIComponent("" + inventoryNr) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInventoryNrExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInventoryNrExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processInventoryNrExists(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param repDate (optional) 
     * @param storage (optional) 
     * @return Success
     */
    assetRegistruReport(repDate: moment.Moment | undefined, storage: number | null | undefined): Observable<ImoAssetRegistruReport> {
        let url_ = this.baseUrl + "/api/services/app/Reports/AssetRegistruReport?";
        if (repDate === null)
            throw new Error("The parameter 'repDate' cannot be null.");
        else if (repDate !== undefined)
            url_ += "repDate=" + encodeURIComponent(repDate ? "" + repDate.toISOString() : "") + "&";
        if (storage !== undefined && storage !== null)
            url_ += "storage=" + encodeURIComponent("" + storage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetRegistruReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetRegistruReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetRegistruReport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetRegistruReport>;
        }));
    }

    protected processAssetRegistruReport(response: HttpResponseBase): Observable<ImoAssetRegistruReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetRegistruReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetRegistruReport>(null as any);
    }

    /**
     * @param dataFisa (optional) 
     * @param inventoryNr (optional) 
     * @return Success
     */
    assetFisa(dataFisa: moment.Moment | undefined, inventoryNr: number | undefined): Observable<ImoAssetFisaReport> {
        let url_ = this.baseUrl + "/api/services/app/Reports/AssetFisa?";
        if (dataFisa === null)
            throw new Error("The parameter 'dataFisa' cannot be null.");
        else if (dataFisa !== undefined)
            url_ += "dataFisa=" + encodeURIComponent(dataFisa ? "" + dataFisa.toISOString() : "") + "&";
        if (inventoryNr === null)
            throw new Error("The parameter 'inventoryNr' cannot be null.");
        else if (inventoryNr !== undefined)
            url_ += "inventoryNr=" + encodeURIComponent("" + inventoryNr) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetFisa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetFisa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetFisaReport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetFisaReport>;
        }));
    }

    protected processAssetFisa(response: HttpResponseBase): Observable<ImoAssetFisaReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetFisaReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetFisaReport>(null as any);
    }

    /**
     * @param repDate (optional) 
     * @param storage (optional) 
     * @return Success
     */
    assetRegistruV2Report(repDate: moment.Moment | undefined, storage: number | null | undefined): Observable<ImoAssetRegV2Report> {
        let url_ = this.baseUrl + "/api/services/app/Reports/AssetRegistruV2Report?";
        if (repDate === null)
            throw new Error("The parameter 'repDate' cannot be null.");
        else if (repDate !== undefined)
            url_ += "repDate=" + encodeURIComponent(repDate ? "" + repDate.toISOString() : "") + "&";
        if (storage !== undefined && storage !== null)
            url_ += "storage=" + encodeURIComponent("" + storage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetRegistruV2Report(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetRegistruV2Report(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImoAssetRegV2Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImoAssetRegV2Report>;
        }));
    }

    protected processAssetRegistruV2Report(response: HttpResponseBase): Observable<ImoAssetRegV2Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImoAssetRegV2Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImoAssetRegV2Report>(null as any);
    }

    /**
     * @param invOperId (optional) 
     * @param inventoryType (optional) 
     * @return Success
     */
    inventariereReport(invOperId: number | undefined, inventoryType: number | undefined): Observable<InvObjectImoAssetReport> {
        let url_ = this.baseUrl + "/api/services/app/Reports/InventariereReport?";
        if (invOperId === null)
            throw new Error("The parameter 'invOperId' cannot be null.");
        else if (invOperId !== undefined)
            url_ += "invOperId=" + encodeURIComponent("" + invOperId) + "&";
        if (inventoryType === null)
            throw new Error("The parameter 'inventoryType' cannot be null.");
        else if (inventoryType !== undefined)
            url_ += "inventoryType=" + encodeURIComponent("" + inventoryType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInventariereReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInventariereReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectImoAssetReport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectImoAssetReport>;
        }));
    }

    protected processInventariereReport(response: HttpResponseBase): Observable<InvObjectImoAssetReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectImoAssetReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectImoAssetReport>(null as any);
    }

    /**
     * @param operationId (optional) 
     * @param inventoryType (optional) 
     * @return Success
     */
    bonTransferReport(operationId: number | undefined, inventoryType: number | undefined): Observable<BonTransferModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/BonTransferReport?";
        if (operationId === null)
            throw new Error("The parameter 'operationId' cannot be null.");
        else if (operationId !== undefined)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        if (inventoryType === null)
            throw new Error("The parameter 'inventoryType' cannot be null.");
        else if (inventoryType !== undefined)
            url_ += "inventoryType=" + encodeURIComponent("" + inventoryType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBonTransferReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBonTransferReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BonTransferModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BonTransferModel>;
        }));
    }

    protected processBonTransferReport(response: HttpResponseBase): Observable<BonTransferModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BonTransferModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BonTransferModel>(null as any);
    }

    /**
     * @param dispositionId (optional) 
     * @param operationType (optional) 
     * @return Success
     */
    dispositionReport(dispositionId: number | undefined, operationType: number | undefined): Observable<DispositionModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/DispositionReport?";
        if (dispositionId === null)
            throw new Error("The parameter 'dispositionId' cannot be null.");
        else if (dispositionId !== undefined)
            url_ += "dispositionId=" + encodeURIComponent("" + dispositionId) + "&";
        if (operationType === null)
            throw new Error("The parameter 'operationType' cannot be null.");
        else if (operationType !== undefined)
            url_ += "operationType=" + encodeURIComponent("" + operationType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDispositionReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDispositionReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DispositionModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DispositionModel>;
        }));
    }

    protected processDispositionReport(response: HttpResponseBase): Observable<DispositionModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DispositionModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DispositionModel>(null as any);
    }

    /**
     * @param date (optional) 
     * @param numeCasier (optional) 
     * @param dataDecizie (optional) 
     * @return Success
     */
    declaratieCasier(date: moment.Moment | undefined, numeCasier: string | null | undefined, dataDecizie: moment.Moment | undefined): Observable<DeclaratieCasierModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Reports/DeclaratieCasier?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (numeCasier !== undefined && numeCasier !== null)
            url_ += "numeCasier=" + encodeURIComponent("" + numeCasier) + "&";
        if (dataDecizie === null)
            throw new Error("The parameter 'dataDecizie' cannot be null.");
        else if (dataDecizie !== undefined)
            url_ += "dataDecizie=" + encodeURIComponent(dataDecizie ? "" + dataDecizie.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeclaratieCasier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeclaratieCasier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeclaratieCasierModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeclaratieCasierModel[]>;
        }));
    }

    protected processDeclaratieCasier(response: HttpResponseBase): Observable<DeclaratieCasierModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DeclaratieCasierModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeclaratieCasierModel[]>(null as any);
    }

    /**
     * @param reportId (optional) 
     * @param reportStartDate (optional) 
     * @param reportEndDate (optional) 
     * @param isDateRange (optional) 
     * @param rulaj (optional) 
     * @param convertToLocalCurrency (optional) 
     * @return Success
     */
    calculRaport(reportId: number | undefined, reportStartDate: moment.Moment | undefined, reportEndDate: moment.Moment | undefined, isDateRange: boolean | undefined, rulaj: boolean | undefined, convertToLocalCurrency: boolean | undefined): Observable<ReportCalc> {
        let url_ = this.baseUrl + "/api/services/app/Reports/CalculRaport?";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        if (reportStartDate === null)
            throw new Error("The parameter 'reportStartDate' cannot be null.");
        else if (reportStartDate !== undefined)
            url_ += "reportStartDate=" + encodeURIComponent(reportStartDate ? "" + reportStartDate.toISOString() : "") + "&";
        if (reportEndDate === null)
            throw new Error("The parameter 'reportEndDate' cannot be null.");
        else if (reportEndDate !== undefined)
            url_ += "reportEndDate=" + encodeURIComponent(reportEndDate ? "" + reportEndDate.toISOString() : "") + "&";
        if (isDateRange === null)
            throw new Error("The parameter 'isDateRange' cannot be null.");
        else if (isDateRange !== undefined)
            url_ += "isDateRange=" + encodeURIComponent("" + isDateRange) + "&";
        if (rulaj === null)
            throw new Error("The parameter 'rulaj' cannot be null.");
        else if (rulaj !== undefined)
            url_ += "rulaj=" + encodeURIComponent("" + rulaj) + "&";
        if (convertToLocalCurrency === null)
            throw new Error("The parameter 'convertToLocalCurrency' cannot be null.");
        else if (convertToLocalCurrency !== undefined)
            url_ += "convertToLocalCurrency=" + encodeURIComponent("" + convertToLocalCurrency) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculRaport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculRaport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportCalc>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportCalc>;
        }));
    }

    protected processCalculRaport(response: HttpResponseBase): Observable<ReportCalc> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportCalc.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportCalc>(null as any);
    }

    /**
     * @param reportDate (optional) 
     * @return Success
     */
    registruInventarReport(reportDate: moment.Moment | undefined): Observable<RegistruInventarReport> {
        let url_ = this.baseUrl + "/api/services/app/Reports/RegistruInventarReport?";
        if (reportDate === null)
            throw new Error("The parameter 'reportDate' cannot be null.");
        else if (reportDate !== undefined)
            url_ += "reportDate=" + encodeURIComponent(reportDate ? "" + reportDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistruInventarReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistruInventarReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistruInventarReport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistruInventarReport>;
        }));
    }

    protected processRegistruInventarReport(response: HttpResponseBase): Observable<RegistruInventarReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistruInventarReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistruInventarReport>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    invoiceReport(invoiceId: number | undefined): Observable<InvoiceModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/InvoiceReport?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceModel>;
        }));
    }

    protected processInvoiceReport(response: HttpResponseBase): Observable<InvoiceModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceModel>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @param raportId (optional) 
     * @return Success
     */
    sitFinanReport(balanceId: number | undefined, raportId: number | undefined): Observable<SitFinanReportModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/SitFinanReport?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        if (raportId === null)
            throw new Error("The parameter 'raportId' cannot be null.");
        else if (raportId !== undefined)
            url_ += "raportId=" + encodeURIComponent("" + raportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanReportModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanReportModel>;
        }));
    }

    protected processSitFinanReport(response: HttpResponseBase): Observable<SitFinanReportModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanReportModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanReportModel>(null as any);
    }

    /**
     * @param repDate (optional) 
     * @param storageId (optional) 
     * @return Success
     */
    invObjectReport(repDate: moment.Moment | undefined, storageId: number | null | undefined): Observable<InvObjectReportModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/InvObjectReport?";
        if (repDate === null)
            throw new Error("The parameter 'repDate' cannot be null.");
        else if (repDate !== undefined)
            url_ += "repDate=" + encodeURIComponent(repDate ? "" + repDate.toISOString() : "") + "&";
        if (storageId !== undefined && storageId !== null)
            url_ += "storageId=" + encodeURIComponent("" + storageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvObjectReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvObjectReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvObjectReportModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvObjectReportModel>;
        }));
    }

    protected processInvObjectReport(response: HttpResponseBase): Observable<InvObjectReportModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvObjectReportModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvObjectReportModel>(null as any);
    }

    /**
     * @param operationId (optional) 
     * @param inventoryType (optional) 
     * @return Success
     */
    bonConsumReport(operationId: number | undefined, inventoryType: number | undefined): Observable<BonConsumModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/BonConsumReport?";
        if (operationId === null)
            throw new Error("The parameter 'operationId' cannot be null.");
        else if (operationId !== undefined)
            url_ += "operationId=" + encodeURIComponent("" + operationId) + "&";
        if (inventoryType === null)
            throw new Error("The parameter 'inventoryType' cannot be null.");
        else if (inventoryType !== undefined)
            url_ += "inventoryType=" + encodeURIComponent("" + inventoryType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBonConsumReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBonConsumReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BonConsumModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BonConsumModel>;
        }));
    }

    protected processBonConsumReport(response: HttpResponseBase): Observable<BonConsumModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BonConsumModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BonConsumModel>(null as any);
    }

    /**
     * @param currencyId (optional) 
     * @param accountId (optional) 
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @param periodTypeId (optional) 
     * @param isDateRange (optional) 
     * @return Success
     */
    soldCurentReport(currencyId: number | null | undefined, accountId: number | null | undefined, dataStart: moment.Moment | null | undefined, dataEnd: moment.Moment | null | undefined, periodTypeId: number | null | undefined, isDateRange: boolean | undefined): Observable<SoldContCurentModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Reports/SoldCurentReport?";
        if (currencyId !== undefined && currencyId !== null)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (accountId !== undefined && accountId !== null)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (dataStart !== undefined && dataStart !== null)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd !== undefined && dataEnd !== null)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        if (periodTypeId !== undefined && periodTypeId !== null)
            url_ += "periodTypeId=" + encodeURIComponent("" + periodTypeId) + "&";
        if (isDateRange === null)
            throw new Error("The parameter 'isDateRange' cannot be null.");
        else if (isDateRange !== undefined)
            url_ += "isDateRange=" + encodeURIComponent("" + isDateRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSoldCurentReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSoldCurentReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SoldContCurentModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SoldContCurentModel[]>;
        }));
    }

    protected processSoldCurentReport(response: HttpResponseBase): Observable<SoldContCurentModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SoldContCurentModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoldContCurentModel[]>(null as any);
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @param periodTypeId (optional) 
     * @return Success
     */
    verifySoldPeriod(dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined, periodTypeId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Reports/VerifySoldPeriod?";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        if (periodTypeId === null)
            throw new Error("The parameter 'periodTypeId' cannot be null.");
        else if (periodTypeId !== undefined)
            url_ += "periodTypeId=" + encodeURIComponent("" + periodTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySoldPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySoldPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifySoldPeriod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param thirdPartyId (optional) 
     * @param startDate (optional) 
     * @return Success
     */
    soldFurnizoriReport(thirdPartyId: number | undefined, startDate: moment.Moment | undefined): Observable<SoldFurnizoriDebitoriModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/SoldFurnizoriReport?";
        if (thirdPartyId === null)
            throw new Error("The parameter 'thirdPartyId' cannot be null.");
        else if (thirdPartyId !== undefined)
            url_ += "thirdPartyId=" + encodeURIComponent("" + thirdPartyId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSoldFurnizoriReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSoldFurnizoriReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SoldFurnizoriDebitoriModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SoldFurnizoriDebitoriModel>;
        }));
    }

    protected processSoldFurnizoriReport(response: HttpResponseBase): Observable<SoldFurnizoriDebitoriModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoldFurnizoriDebitoriModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoldFurnizoriDebitoriModel>(null as any);
    }

    /**
     * @param departmentId (optional) 
     * @param bugetPrevId (optional) 
     * @param activityType (optional) 
     * @return Success
     */
    bugetPrevReport(departmentId: number | undefined, bugetPrevId: number | undefined, activityType: boolean | undefined): Observable<BugetPrevReportDto> {
        let url_ = this.baseUrl + "/api/services/app/Reports/BugetPrevReport?";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        if (activityType === null)
            throw new Error("The parameter 'activityType' cannot be null.");
        else if (activityType !== undefined)
            url_ += "activityType=" + encodeURIComponent("" + activityType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetPrevReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetPrevReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetPrevReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetPrevReportDto>;
        }));
    }

    protected processBugetPrevReport(response: HttpResponseBase): Observable<BugetPrevReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetPrevReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetPrevReportDto>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @return Success
     */
    anexaReport(savedBalanceId: number | undefined): Observable<AnexaReportModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/AnexaReport?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnexaReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnexaReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnexaReportModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnexaReportModel>;
        }));
    }

    protected processAnexaReport(response: HttpResponseBase): Observable<AnexaReportModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnexaReportModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnexaReportModel>(null as any);
    }

    /**
     * @param variantaBugetId (optional) 
     * @param tipRand (optional) 
     * @param nivelRand (optional) 
     * @param anBuget (optional) 
     * @param tip (optional) 
     * @param frecventa (optional) 
     * @param tipActivitate (optional) 
     * @param tipRaport (optional) 
     * @return Success
     */
    raportBVC(variantaBugetId: number | undefined, tipRand: string | null | undefined, nivelRand: number | undefined, anBuget: number | undefined, tip: number | undefined, frecventa: string | null | undefined, tipActivitate: string | null | undefined, tipRaport: number | undefined): Observable<BVC_Report> {
        let url_ = this.baseUrl + "/api/services/app/Reports/RaportBVC?";
        if (variantaBugetId === null)
            throw new Error("The parameter 'variantaBugetId' cannot be null.");
        else if (variantaBugetId !== undefined)
            url_ += "variantaBugetId=" + encodeURIComponent("" + variantaBugetId) + "&";
        if (tipRand !== undefined && tipRand !== null)
            url_ += "tipRand=" + encodeURIComponent("" + tipRand) + "&";
        if (nivelRand === null)
            throw new Error("The parameter 'nivelRand' cannot be null.");
        else if (nivelRand !== undefined)
            url_ += "nivelRand=" + encodeURIComponent("" + nivelRand) + "&";
        if (anBuget === null)
            throw new Error("The parameter 'anBuget' cannot be null.");
        else if (anBuget !== undefined)
            url_ += "anBuget=" + encodeURIComponent("" + anBuget) + "&";
        if (tip === null)
            throw new Error("The parameter 'tip' cannot be null.");
        else if (tip !== undefined)
            url_ += "tip=" + encodeURIComponent("" + tip) + "&";
        if (frecventa !== undefined && frecventa !== null)
            url_ += "frecventa=" + encodeURIComponent("" + frecventa) + "&";
        if (tipActivitate !== undefined && tipActivitate !== null)
            url_ += "tipActivitate=" + encodeURIComponent("" + tipActivitate) + "&";
        if (tipRaport === null)
            throw new Error("The parameter 'tipRaport' cannot be null.");
        else if (tipRaport !== undefined)
            url_ += "tipRaport=" + encodeURIComponent("" + tipRaport) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRaportBVC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRaportBVC(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BVC_Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BVC_Report>;
        }));
    }

    protected processRaportBVC(response: HttpResponseBase): Observable<BVC_Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BVC_Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BVC_Report>(null as any);
    }

    /**
     * @param tipRand (optional) 
     * @param bugetRealizatId (optional) 
     * @param includReferat (optional) 
     * @param tipRealizat (optional) 
     * @param tipRaport (optional) 
     * @param anBuget (optional) 
     * @param tip (optional) 
     * @param variantaBugetId (optional) 
     * @param nivelRand (optional) 
     * @return Success
     */
    bVC_RealizatReport(tipRand: string | null | undefined, bugetRealizatId: number | undefined, includReferat: boolean | undefined, tipRealizat: number | undefined, tipRaport: number | undefined, anBuget: number | undefined, tip: number | undefined, variantaBugetId: number | undefined, nivelRand: number | undefined): Observable<BVC_Realizat_Report> {
        let url_ = this.baseUrl + "/api/services/app/Reports/BVC_RealizatReport?";
        if (tipRand !== undefined && tipRand !== null)
            url_ += "tipRand=" + encodeURIComponent("" + tipRand) + "&";
        if (bugetRealizatId === null)
            throw new Error("The parameter 'bugetRealizatId' cannot be null.");
        else if (bugetRealizatId !== undefined)
            url_ += "bugetRealizatId=" + encodeURIComponent("" + bugetRealizatId) + "&";
        if (includReferat === null)
            throw new Error("The parameter 'includReferat' cannot be null.");
        else if (includReferat !== undefined)
            url_ += "includReferat=" + encodeURIComponent("" + includReferat) + "&";
        if (tipRealizat === null)
            throw new Error("The parameter 'tipRealizat' cannot be null.");
        else if (tipRealizat !== undefined)
            url_ += "tipRealizat=" + encodeURIComponent("" + tipRealizat) + "&";
        if (tipRaport === null)
            throw new Error("The parameter 'tipRaport' cannot be null.");
        else if (tipRaport !== undefined)
            url_ += "tipRaport=" + encodeURIComponent("" + tipRaport) + "&";
        if (anBuget === null)
            throw new Error("The parameter 'anBuget' cannot be null.");
        else if (anBuget !== undefined)
            url_ += "anBuget=" + encodeURIComponent("" + anBuget) + "&";
        if (tip === null)
            throw new Error("The parameter 'tip' cannot be null.");
        else if (tip !== undefined)
            url_ += "tip=" + encodeURIComponent("" + tip) + "&";
        if (variantaBugetId === null)
            throw new Error("The parameter 'variantaBugetId' cannot be null.");
        else if (variantaBugetId !== undefined)
            url_ += "variantaBugetId=" + encodeURIComponent("" + variantaBugetId) + "&";
        if (nivelRand === null)
            throw new Error("The parameter 'nivelRand' cannot be null.");
        else if (nivelRand !== undefined)
            url_ += "nivelRand=" + encodeURIComponent("" + nivelRand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_RealizatReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_RealizatReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BVC_Realizat_Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BVC_Realizat_Report>;
        }));
    }

    protected processBVC_RealizatReport(response: HttpResponseBase): Observable<BVC_Realizat_Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BVC_Realizat_Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BVC_Realizat_Report>(null as any);
    }

    /**
     * @param raportId (optional) 
     * @param balanceId (optional) 
     * @param isDailyBalance (optional) 
     * @param isDateRange (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param colNumber (optional) 
     * @return Success
     */
    getSitFinanRaport(raportId: number | undefined, balanceId: number | null | undefined, isDailyBalance: boolean | undefined, isDateRange: boolean | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, colNumber: number | undefined): Observable<SitFinanRaport> {
        let url_ = this.baseUrl + "/api/services/app/Reports/GetSitFinanRaport?";
        if (raportId === null)
            throw new Error("The parameter 'raportId' cannot be null.");
        else if (raportId !== undefined)
            url_ += "raportId=" + encodeURIComponent("" + raportId) + "&";
        if (balanceId !== undefined && balanceId !== null)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        if (isDailyBalance === null)
            throw new Error("The parameter 'isDailyBalance' cannot be null.");
        else if (isDailyBalance !== undefined)
            url_ += "isDailyBalance=" + encodeURIComponent("" + isDailyBalance) + "&";
        if (isDateRange === null)
            throw new Error("The parameter 'isDateRange' cannot be null.");
        else if (isDateRange !== undefined)
            url_ += "isDateRange=" + encodeURIComponent("" + isDateRange) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (colNumber === null)
            throw new Error("The parameter 'colNumber' cannot be null.");
        else if (colNumber !== undefined)
            url_ += "colNumber=" + encodeURIComponent("" + colNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSitFinanRaport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSitFinanRaport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanRaport>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanRaport>;
        }));
    }

    protected processGetSitFinanRaport(response: HttpResponseBase): Observable<SitFinanRaport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanRaport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanRaport>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @return Success
     */
    cursValutarBNR(balanceId: number | undefined): Observable<CursValutarBNRModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/CursValutarBNR?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCursValutarBNR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCursValutarBNR(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CursValutarBNRModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CursValutarBNRModel>;
        }));
    }

    protected processCursValutarBNR(response: HttpResponseBase): Observable<CursValutarBNRModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CursValutarBNRModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CursValutarBNRModel>(null as any);
    }

    /**
     * @param savedBalanceId (optional) 
     * @param lichidType (optional) 
     * @return Success
     */
    lichidCalcReport(savedBalanceId: number | undefined, lichidType: number | undefined): Observable<LichidCalcModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/LichidCalcReport?";
        if (savedBalanceId === null)
            throw new Error("The parameter 'savedBalanceId' cannot be null.");
        else if (savedBalanceId !== undefined)
            url_ += "savedBalanceId=" + encodeURIComponent("" + savedBalanceId) + "&";
        if (lichidType === null)
            throw new Error("The parameter 'lichidType' cannot be null.");
        else if (lichidType !== undefined)
            url_ += "lichidType=" + encodeURIComponent("" + lichidType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLichidCalcReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLichidCalcReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidCalcModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidCalcModel>;
        }));
    }

    protected processLichidCalcReport(response: HttpResponseBase): Observable<LichidCalcModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LichidCalcModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidCalcModel>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @return Success
     */
    depozitBancarReport(balanceId: number | undefined): Observable<DepozitBancarDto> {
        let url_ = this.baseUrl + "/api/services/app/Reports/DepozitBancarReport?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDepozitBancarReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDepozitBancarReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepozitBancarDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepozitBancarDto>;
        }));
    }

    protected processDepozitBancarReport(response: HttpResponseBase): Observable<DepozitBancarDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepozitBancarDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepozitBancarDto>(null as any);
    }

    /**
     * @param tipRand (optional) 
     * @param bugetBalRealizatId (optional) 
     * @param tipRealizat (optional) 
     * @param anBuget (optional) 
     * @param tip (optional) 
     * @param variantaBugetId (optional) 
     * @param nivelRand (optional) 
     * @param tipActivitate (optional) 
     * @param tipRaport (optional) 
     * @param includPrevazutAnual (optional) 
     * @return Success
     */
    bVC_BalRealizatReport(tipRand: string | null | undefined, bugetBalRealizatId: number | undefined, tipRealizat: number | undefined, anBuget: number | undefined, tip: number | undefined, variantaBugetId: number | undefined, nivelRand: number | undefined, tipActivitate: string | null | undefined, tipRaport: number | undefined, includPrevazutAnual: boolean | undefined): Observable<BVC_BalRealizat_Report> {
        let url_ = this.baseUrl + "/api/services/app/Reports/BVC_BalRealizatReport?";
        if (tipRand !== undefined && tipRand !== null)
            url_ += "tipRand=" + encodeURIComponent("" + tipRand) + "&";
        if (bugetBalRealizatId === null)
            throw new Error("The parameter 'bugetBalRealizatId' cannot be null.");
        else if (bugetBalRealizatId !== undefined)
            url_ += "bugetBalRealizatId=" + encodeURIComponent("" + bugetBalRealizatId) + "&";
        if (tipRealizat === null)
            throw new Error("The parameter 'tipRealizat' cannot be null.");
        else if (tipRealizat !== undefined)
            url_ += "tipRealizat=" + encodeURIComponent("" + tipRealizat) + "&";
        if (anBuget === null)
            throw new Error("The parameter 'anBuget' cannot be null.");
        else if (anBuget !== undefined)
            url_ += "anBuget=" + encodeURIComponent("" + anBuget) + "&";
        if (tip === null)
            throw new Error("The parameter 'tip' cannot be null.");
        else if (tip !== undefined)
            url_ += "tip=" + encodeURIComponent("" + tip) + "&";
        if (variantaBugetId === null)
            throw new Error("The parameter 'variantaBugetId' cannot be null.");
        else if (variantaBugetId !== undefined)
            url_ += "variantaBugetId=" + encodeURIComponent("" + variantaBugetId) + "&";
        if (nivelRand === null)
            throw new Error("The parameter 'nivelRand' cannot be null.");
        else if (nivelRand !== undefined)
            url_ += "nivelRand=" + encodeURIComponent("" + nivelRand) + "&";
        if (tipActivitate !== undefined && tipActivitate !== null)
            url_ += "tipActivitate=" + encodeURIComponent("" + tipActivitate) + "&";
        if (tipRaport === null)
            throw new Error("The parameter 'tipRaport' cannot be null.");
        else if (tipRaport !== undefined)
            url_ += "tipRaport=" + encodeURIComponent("" + tipRaport) + "&";
        if (includPrevazutAnual === null)
            throw new Error("The parameter 'includPrevazutAnual' cannot be null.");
        else if (includPrevazutAnual !== undefined)
            url_ += "includPrevazutAnual=" + encodeURIComponent("" + includPrevazutAnual) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_BalRealizatReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_BalRealizatReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BVC_BalRealizat_Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BVC_BalRealizat_Report>;
        }));
    }

    protected processBVC_BalRealizatReport(response: HttpResponseBase): Observable<BVC_BalRealizat_Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BVC_BalRealizat_Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BVC_BalRealizat_Report>(null as any);
    }

    /**
     * @param anBVC (optional) 
     * @param bugetPrevId (optional) 
     * @return Success
     */
    bVC_PrevResurseReport(anBVC: number | undefined, bugetPrevId: number | undefined): Observable<BVC_PrevResurseModel> {
        let url_ = this.baseUrl + "/api/services/app/Reports/BVC_PrevResurseReport?";
        if (anBVC === null)
            throw new Error("The parameter 'anBVC' cannot be null.");
        else if (anBVC !== undefined)
            url_ += "anBVC=" + encodeURIComponent("" + anBVC) + "&";
        if (bugetPrevId === null)
            throw new Error("The parameter 'bugetPrevId' cannot be null.");
        else if (bugetPrevId !== undefined)
            url_ += "bugetPrevId=" + encodeURIComponent("" + bugetPrevId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBVC_PrevResurseReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBVC_PrevResurseReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BVC_PrevResurseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BVC_PrevResurseModel>;
        }));
    }

    protected processBVC_PrevResurseReport(response: HttpResponseBase): Observable<BVC_PrevResurseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BVC_PrevResurseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BVC_PrevResurseModel>(null as any);
    }

    /**
     * @param anBVC (optional) 
     * @return Success
     */
    bugetReport(anBVC: number | undefined): Observable<BugetRaportare> {
        let url_ = this.baseUrl + "/api/services/app/Reports/BugetReport?";
        if (anBVC === null)
            throw new Error("The parameter 'anBVC' cannot be null.");
        else if (anBVC !== undefined)
            url_ += "AnBVC=" + encodeURIComponent("" + anBVC) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBugetReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBugetReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BugetRaportare>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BugetRaportare>;
        }));
    }

    protected processBugetReport(response: HttpResponseBase): Observable<BugetRaportare> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BugetRaportare.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugetRaportare>(null as any);
    }

    /**
     * @return Success
     */
    invoiceDetailsInit(): Observable<InvoiceDetailsReportDto> {
        let url_ = this.baseUrl + "/api/services/app/Reports/InvoiceDetailsInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceDetailsInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceDetailsInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDetailsReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDetailsReportDto>;
        }));
    }

    protected processInvoiceDetailsInit(response: HttpResponseBase): Observable<InvoiceDetailsReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDetailsReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDetailsReportDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchInvoiceDetails(body: InvoiceDetailsReportDto | undefined): Observable<InvoiceDetailsReportDto> {
        let url_ = this.baseUrl + "/api/services/app/Reports/SearchInvoiceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDetailsReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDetailsReportDto>;
        }));
    }

    protected processSearchInvoiceDetails(response: HttpResponseBase): Observable<InvoiceDetailsReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDetailsReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDetailsReportDto>(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined && permission !== null)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class SavedBalanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    initBalanceForm(): Observable<SavedBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/SavedBalance/InitBalanceForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitBalanceForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitBalanceForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SavedBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SavedBalanceDto>;
        }));
    }

    protected processInitBalanceForm(response: HttpResponseBase): Observable<SavedBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SavedBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SavedBalanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savedBalanceList(body: SavedBalanceDto | undefined): Observable<SavedBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/SavedBalance/SavedBalanceList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavedBalanceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavedBalanceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SavedBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SavedBalanceDto>;
        }));
    }

    protected processSavedBalanceList(response: HttpResponseBase): Observable<SavedBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SavedBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SavedBalanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveBalance(body: SavedBalanceDto | undefined): Observable<SavedBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/SavedBalance/SaveBalance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SavedBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SavedBalanceDto>;
        }));
    }

    protected processSaveBalance(response: HttpResponseBase): Observable<SavedBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SavedBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SavedBalanceDto>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @return Success
     */
    deleteBalance(balanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SavedBalance/DeleteBalance?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteBalance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @param currencyId (optional) 
     * @param body (optional) 
     * @return Success
     */
    balanceDetailsInit(balanceId: number | undefined, currencyId: number | undefined, body: SavedBalanceDto | undefined): Observable<SavedBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/SavedBalance/BalanceDetailsInit?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceDetailsInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceDetailsInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SavedBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SavedBalanceDto>;
        }));
    }

    protected processBalanceDetailsInit(response: HttpResponseBase): Observable<SavedBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SavedBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SavedBalanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    balanceDetails(body: SavedBalanceDto | undefined): Observable<SavedBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/SavedBalance/BalanceDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SavedBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SavedBalanceDto>;
        }));
    }

    protected processBalanceDetails(response: HttpResponseBase): Observable<SavedBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SavedBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SavedBalanceDto>(null as any);
    }

    /**
     * @return Success
     */
    balanceListForBNR(): Observable<BNR_BalanceListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SavedBalance/BalanceListForBNR";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalanceListForBNR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalanceListForBNR(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BNR_BalanceListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BNR_BalanceListDto[]>;
        }));
    }

    protected processBalanceListForBNR(response: HttpResponseBase): Observable<BNR_BalanceListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BNR_BalanceListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BNR_BalanceListDto[]>(null as any);
    }

    /**
     * @return Success
     */
    lichidSavedBalanceList(): Observable<LichidSavedBalanceListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SavedBalance/LichidSavedBalanceList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLichidSavedBalanceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLichidSavedBalanceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LichidSavedBalanceListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LichidSavedBalanceListDto[]>;
        }));
    }

    protected processLichidSavedBalanceList(response: HttpResponseBase): Observable<LichidSavedBalanceListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LichidSavedBalanceListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LichidSavedBalanceListDto[]>(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(null as any);
    }
}

@Injectable()
export class SitFinanCalcServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    calcInit(): Observable<SitFinanCalcForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/CalcInit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcForm>;
        }));
    }

    protected processCalcInit(response: HttpResponseBase): Observable<SitFinanCalcForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    calcList(body: SitFinanCalcForm | undefined): Observable<SitFinanCalcForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/CalcList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcForm>;
        }));
    }

    protected processCalcList(response: HttpResponseBase): Observable<SitFinanCalcForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcForm>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @return Success
     */
    deleteCalcRapoarte(balanceId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/DeleteCalcRapoarte?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCalcRapoarte(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCalcRapoarte(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCalcRapoarte(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    calcRapoarte(balanceId: number | undefined, body: SitFinanCalcForm | undefined): Observable<SitFinanCalcForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/CalcRapoarte?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcRapoarte(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcRapoarte(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcForm>;
        }));
    }

    protected processCalcRapoarte(response: HttpResponseBase): Observable<SitFinanCalcForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcForm>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @return Success
     */
    calcDetInit(balanceId: number | undefined): Observable<SitFinanCalcReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/CalcDetInit?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcDetInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcDetInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcReportForm>;
        }));
    }

    protected processCalcDetInit(response: HttpResponseBase): Observable<SitFinanCalcReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcReportForm>(null as any);
    }

    /**
     * @param reportId (optional) 
     * @param body (optional) 
     * @return Success
     */
    calcDetRap(reportId: number | undefined, body: SitFinanCalcReportForm | undefined): Observable<SitFinanCalcReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/CalcDetRap?";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcDetRap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcDetRap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcReportForm>;
        }));
    }

    protected processCalcDetRap(response: HttpResponseBase): Observable<SitFinanCalcReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcReportForm>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @param raportId (optional) 
     * @param body (optional) 
     * @return Success
     */
    calcRaport(balanceId: number | undefined, raportId: number | undefined, body: SitFinanCalcReportForm | undefined): Observable<SitFinanCalcReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/CalcRaport?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        if (raportId === null)
            throw new Error("The parameter 'raportId' cannot be null.");
        else if (raportId !== undefined)
            url_ += "raportId=" + encodeURIComponent("" + raportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcRaport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcRaport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcReportForm>;
        }));
    }

    protected processCalcRaport(response: HttpResponseBase): Observable<SitFinanCalcReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcReportForm>(null as any);
    }

    /**
     * @param balanceId (optional) 
     * @param raportId (optional) 
     * @return Success
     */
    calcRaportBackEnd(balanceId: number | undefined, raportId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/CalcRaportBackEnd?";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        if (raportId === null)
            throw new Error("The parameter 'raportId' cannot be null.");
        else if (raportId !== undefined)
            url_ += "raportId=" + encodeURIComponent("" + raportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcRaportBackEnd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcRaportBackEnd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCalcRaportBackEnd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveValuesRecalc(body: SitFinanCalcReportForm | undefined): Observable<SitFinanCalcReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/SaveValuesRecalc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveValuesRecalc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveValuesRecalc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcReportForm>;
        }));
    }

    protected processSaveValuesRecalc(response: HttpResponseBase): Observable<SitFinanCalcReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcReportForm>(null as any);
    }

    /**
     * @param rowId (optional) 
     * @param columnId (optional) 
     * @param body (optional) 
     * @return Success
     */
    showValueDetails(rowId: number | undefined, columnId: number | undefined, body: SitFinanCalcReportForm | undefined): Observable<SitFinanCalcReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/ShowValueDetails?";
        if (rowId === null)
            throw new Error("The parameter 'rowId' cannot be null.");
        else if (rowId !== undefined)
            url_ += "rowId=" + encodeURIComponent("" + rowId) + "&";
        if (columnId === null)
            throw new Error("The parameter 'columnId' cannot be null.");
        else if (columnId !== undefined)
            url_ += "columnId=" + encodeURIComponent("" + columnId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowValueDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowValueDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcReportForm>;
        }));
    }

    protected processShowValueDetails(response: HttpResponseBase): Observable<SitFinanCalcReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcReportForm>(null as any);
    }

    /**
     * @param reportId (optional) 
     * @param body (optional) 
     * @return Success
     */
    showNotaDetail(reportId: number | undefined, body: SitFinanCalcReportForm | undefined): Observable<SitFinanCalcReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/ShowNotaDetail?";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowNotaDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowNotaDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcReportForm>;
        }));
    }

    protected processShowNotaDetail(response: HttpResponseBase): Observable<SitFinanCalcReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcReportForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveNota(body: SitFinanCalcReportForm | undefined): Observable<SitFinanCalcReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/SaveNota";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveNota(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveNota(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcReportForm>;
        }));
    }

    protected processSaveNota(response: HttpResponseBase): Observable<SitFinanCalcReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcReportForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recalcNota(body: SitFinanCalcReportForm | undefined): Observable<SitFinanCalcReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/RecalcNota";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecalcNota(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecalcNota(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcReportForm>;
        }));
    }

    protected processRecalcNota(response: HttpResponseBase): Observable<SitFinanCalcReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanCalcReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcReportForm>(null as any);
    }

    /**
     * @param columnId (optional) 
     * @param reportId (optional) 
     * @param balanceId (optional) 
     * @return Success
     */
    showReportDetails(columnId: number | undefined, reportId: number | undefined, balanceId: number | undefined): Observable<SitFinanCalcDetail[]> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanCalc/ShowReportDetails?";
        if (columnId === null)
            throw new Error("The parameter 'columnId' cannot be null.");
        else if (columnId !== undefined)
            url_ += "columnId=" + encodeURIComponent("" + columnId) + "&";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        if (balanceId === null)
            throw new Error("The parameter 'balanceId' cannot be null.");
        else if (balanceId !== undefined)
            url_ += "balanceId=" + encodeURIComponent("" + balanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowReportDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcDetail[]>;
        }));
    }

    protected processShowReportDetails(response: HttpResponseBase): Observable<SitFinanCalcDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SitFinanCalcDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcDetail[]>(null as any);
    }
}

@Injectable()
export class SitFinanConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    sitFinanInitForm(): Observable<SitFinanForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanInitForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanInitForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanInitForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanForm>;
        }));
    }

    protected processSitFinanInitForm(response: HttpResponseBase): Observable<SitFinanForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitFinanList(body: SitFinanForm | undefined): Observable<SitFinanForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanForm>;
        }));
    }

    protected processSitFinanList(response: HttpResponseBase): Observable<SitFinanForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanForm>(null as any);
    }

    /**
     * @param reportId (optional) 
     * @return Success
     */
    sitFinanRapFluxConfigList(reportId: number | undefined): Observable<SitFinanRapFluxConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanRapFluxConfigList?";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanRapFluxConfigList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanRapFluxConfigList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanRapFluxConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanRapFluxConfigDto[]>;
        }));
    }

    protected processSitFinanRapFluxConfigList(response: HttpResponseBase): Observable<SitFinanRapFluxConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SitFinanRapFluxConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanRapFluxConfigDto[]>(null as any);
    }

    /**
     * @return Success
     */
    sitFinanListDD(): Observable<SitFinanDDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanListDD";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanListDD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanListDD(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanDDDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanDDDto[]>;
        }));
    }

    protected processSitFinanListDD(response: HttpResponseBase): Observable<SitFinanDDDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SitFinanDDDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanDDDto[]>(null as any);
    }

    /**
     * @param sitFinanId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sitFinanEdit(sitFinanId: number | undefined, body: SitFinanForm | undefined): Observable<SitFinanForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanEdit?";
        if (sitFinanId === null)
            throw new Error("The parameter 'sitFinanId' cannot be null.");
        else if (sitFinanId !== undefined)
            url_ += "sitFinanId=" + encodeURIComponent("" + sitFinanId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanForm>;
        }));
    }

    protected processSitFinanEdit(response: HttpResponseBase): Observable<SitFinanForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitFinanSave(body: SitFinanForm | undefined): Observable<SitFinanForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanForm>;
        }));
    }

    protected processSitFinanSave(response: HttpResponseBase): Observable<SitFinanForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanForm>(null as any);
    }

    /**
     * @param sitFinanId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sitFinanDelete(sitFinanId: number | undefined, body: SitFinanForm | undefined): Observable<SitFinanForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanDelete?";
        if (sitFinanId === null)
            throw new Error("The parameter 'sitFinanId' cannot be null.");
        else if (sitFinanId !== undefined)
            url_ += "sitFinanId=" + encodeURIComponent("" + sitFinanId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanForm>;
        }));
    }

    protected processSitFinanDelete(response: HttpResponseBase): Observable<SitFinanForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanForm>(null as any);
    }

    /**
     * @param sitFinanId (optional) 
     * @return Success
     */
    sitFinanReportInit(sitFinanId: number | undefined): Observable<SitFinanReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanReportInit?";
        if (sitFinanId === null)
            throw new Error("The parameter 'sitFinanId' cannot be null.");
        else if (sitFinanId !== undefined)
            url_ += "sitFinanId=" + encodeURIComponent("" + sitFinanId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanReportInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanReportInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanReportForm>;
        }));
    }

    protected processSitFinanReportInit(response: HttpResponseBase): Observable<SitFinanReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanReportForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitFinanReportList(body: SitFinanReportForm | undefined): Observable<SitFinanReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanReportList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanReportList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanReportList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanReportForm>;
        }));
    }

    protected processSitFinanReportList(response: HttpResponseBase): Observable<SitFinanReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanReportForm>(null as any);
    }

    /**
     * @param index (optional) 
     * @param body (optional) 
     * @return Success
     */
    sitFinanReportSave(index: number | undefined, body: SitFinanReportForm | undefined): Observable<SitFinanReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanReportSave?";
        if (index === null)
            throw new Error("The parameter 'index' cannot be null.");
        else if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanReportSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanReportSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanReportForm>;
        }));
    }

    protected processSitFinanReportSave(response: HttpResponseBase): Observable<SitFinanReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanReportForm>(null as any);
    }

    /**
     * @param reportId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sitFinanReportDelete(reportId: number | undefined, body: SitFinanReportForm | undefined): Observable<SitFinanReportForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanReportDelete?";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanReportDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanReportDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanReportForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanReportForm>;
        }));
    }

    protected processSitFinanReportDelete(response: HttpResponseBase): Observable<SitFinanReportForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanReportForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanReportForm>(null as any);
    }

    /**
     * @param sitFinanId (optional) 
     * @param reportId (optional) 
     * @return Success
     */
    sitFinanFormulaInit(sitFinanId: number | undefined, reportId: number | undefined): Observable<SitFinanFormuleForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanFormulaInit?";
        if (sitFinanId === null)
            throw new Error("The parameter 'sitFinanId' cannot be null.");
        else if (sitFinanId !== undefined)
            url_ += "sitFinanId=" + encodeURIComponent("" + sitFinanId) + "&";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanFormulaInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanFormulaInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanFormuleForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanFormuleForm>;
        }));
    }

    protected processSitFinanFormulaInit(response: HttpResponseBase): Observable<SitFinanFormuleForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanFormuleForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanFormuleForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitFinanFormulaList(body: SitFinanFormuleForm | undefined): Observable<SitFinanFormuleForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanFormulaList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanFormulaList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanFormulaList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanFormuleForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanFormuleForm>;
        }));
    }

    protected processSitFinanFormulaList(response: HttpResponseBase): Observable<SitFinanFormuleForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanFormuleForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanFormuleForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitFinanFormulaAddRow(body: SitFinanFormuleForm | undefined): Observable<SitFinanFormuleForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanFormulaAddRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanFormulaAddRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanFormulaAddRow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanFormuleForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanFormuleForm>;
        }));
    }

    protected processSitFinanFormulaAddRow(response: HttpResponseBase): Observable<SitFinanFormuleForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanFormuleForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanFormuleForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitFinanFormulaSave(body: SitFinanFormuleForm | undefined): Observable<SitFinanFormuleForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanFormulaSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanFormulaSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanFormulaSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanFormuleForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanFormuleForm>;
        }));
    }

    protected processSitFinanFormulaSave(response: HttpResponseBase): Observable<SitFinanFormuleForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanFormuleForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanFormuleForm>(null as any);
    }

    /**
     * @param sitFinanRapId (optional) 
     * @param body (optional) 
     * @return Success
     */
    sitFinanFluxSave(sitFinanRapId: number | undefined, body: SitFinanRapFluxConfigDto[] | null | undefined): Observable<SitFinanRapFluxConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanFluxSave?";
        if (sitFinanRapId === null)
            throw new Error("The parameter 'sitFinanRapId' cannot be null.");
        else if (sitFinanRapId !== undefined)
            url_ += "SitFinanRapId=" + encodeURIComponent("" + sitFinanRapId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanFluxSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanFluxSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanRapFluxConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanRapFluxConfigDto[]>;
        }));
    }

    protected processSitFinanFluxSave(response: HttpResponseBase): Observable<SitFinanRapFluxConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SitFinanRapFluxConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanRapFluxConfigDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitFinanColList(body: SitFinanFormuleForm | undefined): Observable<SitFinanFormuleForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanColList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanColList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanColList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanFormuleForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanFormuleForm>;
        }));
    }

    protected processSitFinanColList(response: HttpResponseBase): Observable<SitFinanFormuleForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanFormuleForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanFormuleForm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitFinanColSave(body: SitFinanFormuleForm | undefined): Observable<SitFinanFormuleForm> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanColSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanColSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanColSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanFormuleForm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanFormuleForm>;
        }));
    }

    protected processSitFinanColSave(response: HttpResponseBase): Observable<SitFinanFormuleForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanFormuleForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanFormuleForm>(null as any);
    }

    /**
     * @param sitFinanId (optional) 
     * @param reportId (optional) 
     * @return Success
     */
    sitFinanNoteInit(sitFinanId: number | undefined, reportId: number | undefined): Observable<SitFinanRapConfigNoteDto> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanNoteInit?";
        if (sitFinanId === null)
            throw new Error("The parameter 'sitFinanId' cannot be null.");
        else if (sitFinanId !== undefined)
            url_ += "sitFinanId=" + encodeURIComponent("" + sitFinanId) + "&";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanNoteInit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanNoteInit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanRapConfigNoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanRapConfigNoteDto>;
        }));
    }

    protected processSitFinanNoteInit(response: HttpResponseBase): Observable<SitFinanRapConfigNoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanRapConfigNoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanRapConfigNoteDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitFinanNoteSave(body: SitFinanRapConfigNoteDto | undefined): Observable<SitFinanRapConfigNoteDto> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanConfig/SitFinanNoteSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSitFinanNoteSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSitFinanNoteSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanRapConfigNoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanRapConfigNoteDto>;
        }));
    }

    protected processSitFinanNoteSave(response: HttpResponseBase): Observable<SitFinanRapConfigNoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitFinanRapConfigNoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanRapConfigNoteDto>(null as any);
    }
}

@Injectable()
export class SitFinanRapServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param isDailyBalance (optional) 
     * @return Success
     */
    calcBalanceList(isDailyBalance: boolean | undefined): Observable<SitFinanCalcBalanceListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanRap/CalcBalanceList?";
        if (isDailyBalance === null)
            throw new Error("The parameter 'isDailyBalance' cannot be null.");
        else if (isDailyBalance !== undefined)
            url_ += "isDailyBalance=" + encodeURIComponent("" + isDailyBalance) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcBalanceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcBalanceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcBalanceListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcBalanceListDto[]>;
        }));
    }

    protected processCalcBalanceList(response: HttpResponseBase): Observable<SitFinanCalcBalanceListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SitFinanCalcBalanceListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcBalanceListDto[]>(null as any);
    }

    /**
     * @param saveBalanceId (optional) 
     * @return Success
     */
    calcRaportList(saveBalanceId: number | null | undefined): Observable<SitFinanCalcRapListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanRap/CalcRaportList?";
        if (saveBalanceId !== undefined && saveBalanceId !== null)
            url_ += "saveBalanceId=" + encodeURIComponent("" + saveBalanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcRaportList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcRaportList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcRapListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcRapListDto[]>;
        }));
    }

    protected processCalcRaportList(response: HttpResponseBase): Observable<SitFinanCalcRapListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SitFinanCalcRapListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcRapListDto[]>(null as any);
    }

    /**
     * @param raportId (optional) 
     * @return Success
     */
    raportColNumber(raportId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanRap/RaportColNumber?";
        if (raportId === null)
            throw new Error("The parameter 'raportId' cannot be null.");
        else if (raportId !== undefined)
            url_ += "raportId=" + encodeURIComponent("" + raportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRaportColNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRaportColNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRaportColNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param isDailyBalance (optional) 
     * @return Success
     */
    getCalcRaportListByDateRange(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, isDailyBalance: boolean | undefined): Observable<SitFinanCalcRapListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanRap/GetCalcRaportListByDateRange?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (isDailyBalance === null)
            throw new Error("The parameter 'isDailyBalance' cannot be null.");
        else if (isDailyBalance !== undefined)
            url_ += "isDailyBalance=" + encodeURIComponent("" + isDailyBalance) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalcRaportListByDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalcRaportListByDateRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanCalcRapListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanCalcRapListDto[]>;
        }));
    }

    protected processGetCalcRaportListByDateRange(response: HttpResponseBase): Observable<SitFinanCalcRapListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SitFinanCalcRapListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanCalcRapListDto[]>(null as any);
    }

    /**
     * @param raportId (optional) 
     * @return Success
     */
    getReportColumnList(raportId: number | undefined): Observable<SitFinanReportColumn[]> {
        let url_ = this.baseUrl + "/api/services/app/SitFinanRap/GetReportColumnList?";
        if (raportId === null)
            throw new Error("The parameter 'raportId' cannot be null.");
        else if (raportId !== undefined)
            url_ += "raportId=" + encodeURIComponent("" + raportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportColumnList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportColumnList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SitFinanReportColumn[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SitFinanReportColumn[]>;
        }));
    }

    protected processGetReportColumnList(response: HttpResponseBase): Observable<SitFinanReportColumn[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SitFinanReportColumn.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SitFinanReportColumn[]>(null as any);
    }
}

@Injectable()
export class SoldInitialServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dataStart (optional) 
     * @param dataEnd (optional) 
     * @return Success
     */
    soldList(dataStart: moment.Moment | undefined, dataEnd: moment.Moment | undefined): Observable<SoldInitialDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SoldInitial/SoldList?";
        if (dataStart === null)
            throw new Error("The parameter 'dataStart' cannot be null.");
        else if (dataStart !== undefined)
            url_ += "dataStart=" + encodeURIComponent(dataStart ? "" + dataStart.toISOString() : "") + "&";
        if (dataEnd === null)
            throw new Error("The parameter 'dataEnd' cannot be null.");
        else if (dataEnd !== undefined)
            url_ += "dataEnd=" + encodeURIComponent(dataEnd ? "" + dataEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSoldList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSoldList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SoldInitialDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SoldInitialDto[]>;
        }));
    }

    protected processSoldList(response: HttpResponseBase): Observable<SoldInitialDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SoldInitialDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoldInitialDto[]>(null as any);
    }

    /**
     * @param soldId (optional) 
     * @return Success
     */
    getSold(soldId: number | undefined): Observable<SoldInitialEditDto> {
        let url_ = this.baseUrl + "/api/services/app/SoldInitial/GetSold?";
        if (soldId === null)
            throw new Error("The parameter 'soldId' cannot be null.");
        else if (soldId !== undefined)
            url_ += "soldId=" + encodeURIComponent("" + soldId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSold(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSold(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SoldInitialEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SoldInitialEditDto>;
        }));
    }

    protected processGetSold(response: HttpResponseBase): Observable<SoldInitialEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoldInitialEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoldInitialEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveSold(body: SoldInitialEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SoldInitial/SaveSold";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSold(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSold(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveSold(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param soldId (optional) 
     * @return Success
     */
    deleteSold(soldId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SoldInitial/DeleteSold?";
        if (soldId === null)
            throw new Error("The parameter 'soldId' cannot be null.");
        else if (soldId !== undefined)
            url_ += "soldId=" + encodeURIComponent("" + soldId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSold(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSold(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteSold(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    tokenAuthenticate(token: string | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/TokenAuthenticate?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTokenAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTokenAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processTokenAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(null as any);
    }
}

@Injectable()
export class TragereServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveTragere(body: TragereDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tragere/SaveTragere";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTragere(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTragere(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveTragere(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTragere(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tragere/DeleteTragere?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTragere(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTragere(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTragere(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imprumutId (optional) 
     * @return Success
     */
    tragereListId(imprumutId: number | undefined): Observable<TragereDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tragere/TragereListId?";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "imprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTragereListId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTragereListId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TragereDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TragereDto[]>;
        }));
    }

    protected processTragereListId(response: HttpResponseBase): Observable<TragereDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TragereDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TragereDto[]>(null as any);
    }

    /**
     * @return Success
     */
    dateTragereList(): Observable<DataTragereDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tragere/DateTragereList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDateTragereList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDateTragereList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataTragereDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataTragereDto[]>;
        }));
    }

    protected processDateTragereList(response: HttpResponseBase): Observable<DataTragereDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataTragereDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataTragereDto[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    deleteDobandaByDate(date: moment.Moment | undefined): Observable<DataTragereDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tragere/DeleteDobandaByDate?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDobandaByDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDobandaByDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataTragereDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataTragereDto[]>;
        }));
    }

    protected processDeleteDobandaByDate(response: HttpResponseBase): Observable<DataTragereDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataTragereDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataTragereDto[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    calculatorDobanda(date: moment.Moment | undefined): Observable<DataTragereDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tragere/CalculatorDobanda?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculatorDobanda(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculatorDobanda(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataTragereDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataTragereDto[]>;
        }));
    }

    protected processCalculatorDobanda(response: HttpResponseBase): Observable<DataTragereDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataTragereDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataTragereDto[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @param imprumutId (optional) 
     * @return Success
     */
    simulateCalculatorDobandaSiComision(date: moment.Moment | undefined, imprumutId: number | undefined): Observable<TragereDto> {
        let url_ = this.baseUrl + "/api/services/app/Tragere/SimulateCalculatorDobandaSiComision?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (imprumutId === null)
            throw new Error("The parameter 'imprumutId' cannot be null.");
        else if (imprumutId !== undefined)
            url_ += "ImprumutId=" + encodeURIComponent("" + imprumutId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimulateCalculatorDobandaSiComision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimulateCalculatorDobandaSiComision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TragereDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TragereDto>;
        }));
    }

    protected processSimulateCalculatorDobandaSiComision(response: HttpResponseBase): Observable<TragereDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TragereDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TragereDto>(null as any);
    }

    /**
     * @param date (optional) 
     * @param body (optional) 
     * @return Success
     */
    calculComision(date: moment.Moment | undefined, body: Comision | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Tragere/calculComision?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculComision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculComision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCalculComision(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class TranzactiiFonduriServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param _dataEnd (optional) 
     * @param _dataStart (optional) 
     * @param _debit (optional) 
     * @param _credit (optional) 
     * @param _explicatie (optional) 
     * @return Success
     */
    tranzactiiFonduriList(_dataEnd: moment.Moment | undefined, _dataStart: moment.Moment | undefined, _debit: string | null | undefined, _credit: string | null | undefined, _explicatie: string | null | undefined): Observable<TranzactiiFonduriDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TranzactiiFonduri/TranzactiiFonduriList?";
        if (_dataEnd === null)
            throw new Error("The parameter '_dataEnd' cannot be null.");
        else if (_dataEnd !== undefined)
            url_ += "_dataEnd=" + encodeURIComponent(_dataEnd ? "" + _dataEnd.toISOString() : "") + "&";
        if (_dataStart === null)
            throw new Error("The parameter '_dataStart' cannot be null.");
        else if (_dataStart !== undefined)
            url_ += "_dataStart=" + encodeURIComponent(_dataStart ? "" + _dataStart.toISOString() : "") + "&";
        if (_debit !== undefined && _debit !== null)
            url_ += "_debit=" + encodeURIComponent("" + _debit) + "&";
        if (_credit !== undefined && _credit !== null)
            url_ += "_credit=" + encodeURIComponent("" + _credit) + "&";
        if (_explicatie !== undefined && _explicatie !== null)
            url_ += "_explicatie=" + encodeURIComponent("" + _explicatie) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTranzactiiFonduriList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTranzactiiFonduriList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TranzactiiFonduriDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TranzactiiFonduriDto[]>;
        }));
    }

    protected processTranzactiiFonduriList(response: HttpResponseBase): Observable<TranzactiiFonduriDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TranzactiiFonduriDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TranzactiiFonduriDto[]>(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(null as any);
    }
}

export class AccountListDDDto implements IAccountListDDDto {
    id: number;
    name: string | undefined;
    currencyId: number;

    constructor(data?: IAccountListDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.currencyId = _data["currencyId"];
        }
    }

    static fromJS(data: any): AccountListDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountListDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["currencyId"] = this.currencyId;
        return data;
    }

    clone(): AccountListDDDto {
        const json = this.toJSON();
        let result = new AccountListDDDto();
        result.init(json);
        return result;
    }
}

export interface IAccountListDDDto {
    id: number;
    name: string | undefined;
    currencyId: number;
}

export class GetAccountOutput implements IGetAccountOutput {
    getAccounts: AccountListDDDto[] | undefined;

    constructor(data?: IGetAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getAccounts"])) {
                this.getAccounts = [] as any;
                for (let item of _data["getAccounts"])
                    this.getAccounts.push(AccountListDDDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getAccounts)) {
            data["getAccounts"] = [];
            for (let item of this.getAccounts)
                data["getAccounts"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAccountOutput {
        const json = this.toJSON();
        let result = new GetAccountOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAccountOutput {
    getAccounts: AccountListDDDto[] | undefined;
}

export class AccountListDto implements IAccountListDto {
    id: number;
    symbol: string | undefined;
    syntheticAccount: string | undefined;
    accountName: string | undefined;
    accountType: string | undefined;
    currency: string | undefined;
    activityType: string | undefined;
    accountFuncTypeName: string | undefined;
    thirdParty: string | undefined;
    accountStatus: boolean;
    denumireSector: string | undefined;
    nivelRand: number | undefined;
    dataValabilitate: moment.Moment;

    constructor(data?: IAccountListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.symbol = _data["symbol"];
            this.syntheticAccount = _data["syntheticAccount"];
            this.accountName = _data["accountName"];
            this.accountType = _data["accountType"];
            this.currency = _data["currency"];
            this.activityType = _data["activityType"];
            this.accountFuncTypeName = _data["accountFuncTypeName"];
            this.thirdParty = _data["thirdParty"];
            this.accountStatus = _data["accountStatus"];
            this.denumireSector = _data["denumireSector"];
            this.nivelRand = _data["nivelRand"];
            this.dataValabilitate = _data["dataValabilitate"] ? moment(_data["dataValabilitate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["symbol"] = this.symbol;
        data["syntheticAccount"] = this.syntheticAccount;
        data["accountName"] = this.accountName;
        data["accountType"] = this.accountType;
        data["currency"] = this.currency;
        data["activityType"] = this.activityType;
        data["accountFuncTypeName"] = this.accountFuncTypeName;
        data["thirdParty"] = this.thirdParty;
        data["accountStatus"] = this.accountStatus;
        data["denumireSector"] = this.denumireSector;
        data["nivelRand"] = this.nivelRand;
        data["dataValabilitate"] = this.dataValabilitate ? this.dataValabilitate.toISOString() : <any>undefined;
        return data;
    }

    clone(): AccountListDto {
        const json = this.toJSON();
        let result = new AccountListDto();
        result.init(json);
        return result;
    }
}

export interface IAccountListDto {
    id: number;
    symbol: string | undefined;
    syntheticAccount: string | undefined;
    accountName: string | undefined;
    accountType: string | undefined;
    currency: string | undefined;
    activityType: string | undefined;
    accountFuncTypeName: string | undefined;
    thirdParty: string | undefined;
    accountStatus: boolean;
    denumireSector: string | undefined;
    nivelRand: number | undefined;
    dataValabilitate: moment.Moment;
}

export class AccountListFormDto implements IAccountListFormDto {
    searchAccount: string | undefined;
    accountStatus: boolean;
    accounts: AccountListDto[] | undefined;

    constructor(data?: IAccountListFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchAccount = _data["searchAccount"];
            this.accountStatus = _data["accountStatus"];
            if (Array.isArray(_data["accounts"])) {
                this.accounts = [] as any;
                for (let item of _data["accounts"])
                    this.accounts.push(AccountListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountListFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountListFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchAccount"] = this.searchAccount;
        data["accountStatus"] = this.accountStatus;
        if (Array.isArray(this.accounts)) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        return data;
    }

    clone(): AccountListFormDto {
        const json = this.toJSON();
        let result = new AccountListFormDto();
        result.init(json);
        return result;
    }
}

export interface IAccountListFormDto {
    searchAccount: string | undefined;
    accountStatus: boolean;
    accounts: AccountListDto[] | undefined;
}

export class AccountEditDto implements IAccountEditDto {
    id: number;
    symbol: string | undefined;
    syntheticAccount: string | undefined;
    syntheticAccountId: number | undefined;
    accountName: string | undefined;
    externalCode: string | undefined;
    currencyId: number;
    activityTypeId: number | undefined;
    thirdPartyId: number | undefined;
    accountType: number;
    accountFuncType: number;
    computingAccount: boolean;
    bankAccountId: number | undefined;
    taxStatus: number;
    accountStatus: boolean;
    sectorBnrId: number | undefined;
    nivelRand: number | undefined;
    dataValabilitate: moment.Moment;

    constructor(data?: IAccountEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.symbol = _data["symbol"];
            this.syntheticAccount = _data["syntheticAccount"];
            this.syntheticAccountId = _data["syntheticAccountId"];
            this.accountName = _data["accountName"];
            this.externalCode = _data["externalCode"];
            this.currencyId = _data["currencyId"];
            this.activityTypeId = _data["activityTypeId"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.accountType = _data["accountType"];
            this.accountFuncType = _data["accountFuncType"];
            this.computingAccount = _data["computingAccount"];
            this.bankAccountId = _data["bankAccountId"];
            this.taxStatus = _data["taxStatus"];
            this.accountStatus = _data["accountStatus"];
            this.sectorBnrId = _data["sectorBnrId"];
            this.nivelRand = _data["nivelRand"];
            this.dataValabilitate = _data["dataValabilitate"] ? moment(_data["dataValabilitate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["symbol"] = this.symbol;
        data["syntheticAccount"] = this.syntheticAccount;
        data["syntheticAccountId"] = this.syntheticAccountId;
        data["accountName"] = this.accountName;
        data["externalCode"] = this.externalCode;
        data["currencyId"] = this.currencyId;
        data["activityTypeId"] = this.activityTypeId;
        data["thirdPartyId"] = this.thirdPartyId;
        data["accountType"] = this.accountType;
        data["accountFuncType"] = this.accountFuncType;
        data["computingAccount"] = this.computingAccount;
        data["bankAccountId"] = this.bankAccountId;
        data["taxStatus"] = this.taxStatus;
        data["accountStatus"] = this.accountStatus;
        data["sectorBnrId"] = this.sectorBnrId;
        data["nivelRand"] = this.nivelRand;
        data["dataValabilitate"] = this.dataValabilitate ? this.dataValabilitate.toISOString() : <any>undefined;
        return data;
    }

    clone(): AccountEditDto {
        const json = this.toJSON();
        let result = new AccountEditDto();
        result.init(json);
        return result;
    }
}

export interface IAccountEditDto {
    id: number;
    symbol: string | undefined;
    syntheticAccount: string | undefined;
    syntheticAccountId: number | undefined;
    accountName: string | undefined;
    externalCode: string | undefined;
    currencyId: number;
    activityTypeId: number | undefined;
    thirdPartyId: number | undefined;
    accountType: number;
    accountFuncType: number;
    computingAccount: boolean;
    bankAccountId: number | undefined;
    taxStatus: number;
    accountStatus: boolean;
    sectorBnrId: number | undefined;
    nivelRand: number | undefined;
    dataValabilitate: moment.Moment;
}

export enum AccountTaxPropertyType {
    _0 = 0,
    _1 = 1,
}

export class AccountDeductibilityDto implements IAccountDeductibilityDto {
    id: number;
    propertyDate: moment.Moment;
    propertyType: AccountTaxPropertyType;
    propertyTypeId: number;
    propertyValue: number;
    propertyValueStr: string | undefined;
    accountNededId: number | undefined;
    accountNeded: string | undefined;

    constructor(data?: IAccountDeductibilityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.propertyDate = _data["propertyDate"] ? moment(_data["propertyDate"].toString()) : <any>undefined;
            this.propertyType = _data["propertyType"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.propertyValue = _data["propertyValue"];
            this.propertyValueStr = _data["propertyValueStr"];
            this.accountNededId = _data["accountNededId"];
            this.accountNeded = _data["accountNeded"];
        }
    }

    static fromJS(data: any): AccountDeductibilityDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDeductibilityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyDate"] = this.propertyDate ? this.propertyDate.toISOString() : <any>undefined;
        data["propertyType"] = this.propertyType;
        data["propertyTypeId"] = this.propertyTypeId;
        data["propertyValue"] = this.propertyValue;
        data["propertyValueStr"] = this.propertyValueStr;
        data["accountNededId"] = this.accountNededId;
        data["accountNeded"] = this.accountNeded;
        return data;
    }

    clone(): AccountDeductibilityDto {
        const json = this.toJSON();
        let result = new AccountDeductibilityDto();
        result.init(json);
        return result;
    }
}

export interface IAccountDeductibilityDto {
    id: number;
    propertyDate: moment.Moment;
    propertyType: AccountTaxPropertyType;
    propertyTypeId: number;
    propertyValue: number;
    propertyValueStr: string | undefined;
    accountNededId: number | undefined;
    accountNeded: string | undefined;
}

export class AccountDeductibilityForm implements IAccountDeductibilityForm {
    accountSearch: string | undefined;
    accountId: number;
    showList: boolean;
    showEdit: boolean;
    appClientId: number;
    accountName: string | undefined;
    deductibilityList: AccountDeductibilityDto[] | undefined;
    deductibilityEdit: AccountDeductibilityDto;

    constructor(data?: IAccountDeductibilityForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountSearch = _data["accountSearch"];
            this.accountId = _data["accountId"];
            this.showList = _data["showList"];
            this.showEdit = _data["showEdit"];
            this.appClientId = _data["appClientId"];
            this.accountName = _data["accountName"];
            if (Array.isArray(_data["deductibilityList"])) {
                this.deductibilityList = [] as any;
                for (let item of _data["deductibilityList"])
                    this.deductibilityList.push(AccountDeductibilityDto.fromJS(item));
            }
            this.deductibilityEdit = _data["deductibilityEdit"] ? AccountDeductibilityDto.fromJS(_data["deductibilityEdit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountDeductibilityForm {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDeductibilityForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountSearch"] = this.accountSearch;
        data["accountId"] = this.accountId;
        data["showList"] = this.showList;
        data["showEdit"] = this.showEdit;
        data["appClientId"] = this.appClientId;
        data["accountName"] = this.accountName;
        if (Array.isArray(this.deductibilityList)) {
            data["deductibilityList"] = [];
            for (let item of this.deductibilityList)
                data["deductibilityList"].push(item.toJSON());
        }
        data["deductibilityEdit"] = this.deductibilityEdit ? this.deductibilityEdit.toJSON() : <any>undefined;
        return data;
    }

    clone(): AccountDeductibilityForm {
        const json = this.toJSON();
        let result = new AccountDeductibilityForm();
        result.init(json);
        return result;
    }
}

export interface IAccountDeductibilityForm {
    accountSearch: string | undefined;
    accountId: number;
    showList: boolean;
    showEdit: boolean;
    appClientId: number;
    accountName: string | undefined;
    deductibilityList: AccountDeductibilityDto[] | undefined;
    deductibilityEdit: AccountDeductibilityDto;
}

export class AccountHistoryListDto implements IAccountHistoryListDto {
    id: number;
    symbol: string | undefined;
    accountName: string | undefined;
    accountType: string | undefined;
    currency: string | undefined;
    activityType: string | undefined;
    accountFuncTypeName: string | undefined;
    thirdParty: string | undefined;
    accountStatus: boolean;
    dataValabilitate: moment.Moment;

    constructor(data?: IAccountHistoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.symbol = _data["symbol"];
            this.accountName = _data["accountName"];
            this.accountType = _data["accountType"];
            this.currency = _data["currency"];
            this.activityType = _data["activityType"];
            this.accountFuncTypeName = _data["accountFuncTypeName"];
            this.thirdParty = _data["thirdParty"];
            this.accountStatus = _data["accountStatus"];
            this.dataValabilitate = _data["dataValabilitate"] ? moment(_data["dataValabilitate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountHistoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountHistoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["symbol"] = this.symbol;
        data["accountName"] = this.accountName;
        data["accountType"] = this.accountType;
        data["currency"] = this.currency;
        data["activityType"] = this.activityType;
        data["accountFuncTypeName"] = this.accountFuncTypeName;
        data["thirdParty"] = this.thirdParty;
        data["accountStatus"] = this.accountStatus;
        data["dataValabilitate"] = this.dataValabilitate ? this.dataValabilitate.toISOString() : <any>undefined;
        return data;
    }

    clone(): AccountHistoryListDto {
        const json = this.toJSON();
        let result = new AccountHistoryListDto();
        result.init(json);
        return result;
    }
}

export interface IAccountHistoryListDto {
    id: number;
    symbol: string | undefined;
    accountName: string | undefined;
    accountType: string | undefined;
    currency: string | undefined;
    activityType: string | undefined;
    accountFuncTypeName: string | undefined;
    thirdParty: string | undefined;
    accountStatus: boolean;
    dataValabilitate: moment.Moment;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class AccountConfigDto implements IAccountConfigDto {
    id: number;
    symbol: string | undefined;
    accountRad: string | undefined;
    sufix: string | undefined;
    includPunct: boolean;
    includMoneda: boolean;
    includId1: boolean;
    exactAccount: boolean;
    nrCaractere: number | undefined;
    thirdPartyAccount: boolean;
    valabilityDate: moment.Moment;
    description: string | undefined;
    imoAssetStorageId: number | undefined;
    imoAssetStorage: string | undefined;
    appClientId: number;
    scopDeplasareType: number | undefined;
    diurnaType: number | undefined;
    activityTypeId: number | undefined;
    activityType: string | undefined;

    constructor(data?: IAccountConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.symbol = _data["symbol"];
            this.accountRad = _data["accountRad"];
            this.sufix = _data["sufix"];
            this.includPunct = _data["includPunct"];
            this.includMoneda = _data["includMoneda"];
            this.includId1 = _data["includId1"];
            this.exactAccount = _data["exactAccount"];
            this.nrCaractere = _data["nrCaractere"];
            this.thirdPartyAccount = _data["thirdPartyAccount"];
            this.valabilityDate = _data["valabilityDate"] ? moment(_data["valabilityDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.imoAssetStorageId = _data["imoAssetStorageId"];
            this.imoAssetStorage = _data["imoAssetStorage"];
            this.appClientId = _data["appClientId"];
            this.scopDeplasareType = _data["scopDeplasareType"];
            this.diurnaType = _data["diurnaType"];
            this.activityTypeId = _data["activityTypeId"];
            this.activityType = _data["activityType"];
        }
    }

    static fromJS(data: any): AccountConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["symbol"] = this.symbol;
        data["accountRad"] = this.accountRad;
        data["sufix"] = this.sufix;
        data["includPunct"] = this.includPunct;
        data["includMoneda"] = this.includMoneda;
        data["includId1"] = this.includId1;
        data["exactAccount"] = this.exactAccount;
        data["nrCaractere"] = this.nrCaractere;
        data["thirdPartyAccount"] = this.thirdPartyAccount;
        data["valabilityDate"] = this.valabilityDate ? this.valabilityDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["imoAssetStorageId"] = this.imoAssetStorageId;
        data["imoAssetStorage"] = this.imoAssetStorage;
        data["appClientId"] = this.appClientId;
        data["scopDeplasareType"] = this.scopDeplasareType;
        data["diurnaType"] = this.diurnaType;
        data["activityTypeId"] = this.activityTypeId;
        data["activityType"] = this.activityType;
        return data;
    }

    clone(): AccountConfigDto {
        const json = this.toJSON();
        let result = new AccountConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAccountConfigDto {
    id: number;
    symbol: string | undefined;
    accountRad: string | undefined;
    sufix: string | undefined;
    includPunct: boolean;
    includMoneda: boolean;
    includId1: boolean;
    exactAccount: boolean;
    nrCaractere: number | undefined;
    thirdPartyAccount: boolean;
    valabilityDate: moment.Moment;
    description: string | undefined;
    imoAssetStorageId: number | undefined;
    imoAssetStorage: string | undefined;
    appClientId: number;
    scopDeplasareType: number | undefined;
    diurnaType: number | undefined;
    activityTypeId: number | undefined;
    activityType: string | undefined;
}

export enum AccountDivConfigType {
    _0 = 0,
    _1 = 1,
}

export enum AccountDivConfigPersType {
    _0 = 0,
    _1 = 1,
}

export enum AccountDivConfigResidenceType {
    _0 = 0,
    _1 = 1,
}

export class AccountDivConfigDto implements IAccountDivConfigDto {
    id: number;
    accountType: AccountDivConfigType;
    accountTypeStr: string | undefined;
    persType: AccountDivConfigPersType;
    persTypeStr: string | undefined;
    residenceType: AccountDivConfigResidenceType;
    residenceTypeStr: string | undefined;
    divYear: number | undefined;
    accountId: number;
    accountName: string | undefined;
    appClientId: number;

    constructor(data?: IAccountDivConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountType = _data["accountType"];
            this.accountTypeStr = _data["accountTypeStr"];
            this.persType = _data["persType"];
            this.persTypeStr = _data["persTypeStr"];
            this.residenceType = _data["residenceType"];
            this.residenceTypeStr = _data["residenceTypeStr"];
            this.divYear = _data["divYear"];
            this.accountId = _data["accountId"];
            this.accountName = _data["accountName"];
            this.appClientId = _data["appClientId"];
        }
    }

    static fromJS(data: any): AccountDivConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDivConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountType"] = this.accountType;
        data["accountTypeStr"] = this.accountTypeStr;
        data["persType"] = this.persType;
        data["persTypeStr"] = this.persTypeStr;
        data["residenceType"] = this.residenceType;
        data["residenceTypeStr"] = this.residenceTypeStr;
        data["divYear"] = this.divYear;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["appClientId"] = this.appClientId;
        return data;
    }

    clone(): AccountDivConfigDto {
        const json = this.toJSON();
        let result = new AccountDivConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAccountDivConfigDto {
    id: number;
    accountType: AccountDivConfigType;
    accountTypeStr: string | undefined;
    persType: AccountDivConfigPersType;
    persTypeStr: string | undefined;
    residenceType: AccountDivConfigResidenceType;
    residenceTypeStr: string | undefined;
    divYear: number | undefined;
    accountId: number;
    accountName: string | undefined;
    appClientId: number;
}

export class AccountRelationDto implements IAccountRelationDto {
    id: number;
    debitRoot: string | undefined;
    creditRoot: string | undefined;

    constructor(data?: IAccountRelationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.debitRoot = _data["debitRoot"];
            this.creditRoot = _data["creditRoot"];
        }
    }

    static fromJS(data: any): AccountRelationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountRelationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["debitRoot"] = this.debitRoot;
        data["creditRoot"] = this.creditRoot;
        return data;
    }

    clone(): AccountRelationDto {
        const json = this.toJSON();
        let result = new AccountRelationDto();
        result.init(json);
        return result;
    }
}

export interface IAccountRelationDto {
    id: number;
    debitRoot: string | undefined;
    creditRoot: string | undefined;
}

export class ActivityTypeDto implements IActivityTypeDto {
    id: number;
    name: string | undefined;
    mainActivity: boolean;

    constructor(data?: IActivityTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mainActivity = _data["mainActivity"];
        }
    }

    static fromJS(data: any): ActivityTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mainActivity"] = this.mainActivity;
        return data;
    }

    clone(): ActivityTypeDto {
        const json = this.toJSON();
        let result = new ActivityTypeDto();
        result.init(json);
        return result;
    }
}

export interface IActivityTypeDto {
    id: number;
    name: string | undefined;
    mainActivity: boolean;
}

export class UserToken implements IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;
}

export class UserLogin implements IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
    id: number;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data;
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
    id: number;
}

export class UserRole implements IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserClaim implements IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Setting implements ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class User implements IUser {
    angajatId: number;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    readonly fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.angajatId = _data["angajatId"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["angajatId"] = this.angajatId;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    angajatId: number;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Tokens implements ITokens {
    token: string | undefined;
    userId: number;
    user: User;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITokens) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Tokens {
        data = typeof data === 'object' ? data : {};
        let result = new Tokens();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Tokens {
        const json = this.toJSON();
        let result = new Tokens();
        result.init(json);
        return result;
    }
}

export interface ITokens {
    token: string | undefined;
    userId: number;
    user: User;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class GetAccountDto implements IGetAccountDto {
    symbol: string | undefined;
    accountName: string | undefined;

    constructor(data?: IGetAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["symbol"];
            this.accountName = _data["accountName"];
        }
    }

    static fromJS(data: any): GetAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol"] = this.symbol;
        data["accountName"] = this.accountName;
        return data;
    }

    clone(): GetAccountDto {
        const json = this.toJSON();
        let result = new GetAccountDto();
        result.init(json);
        return result;
    }
}

export interface IGetAccountDto {
    symbol: string | undefined;
    accountName: string | undefined;
}

export class ResultMessageIdDto implements IResultMessageIdDto {
    message: string | undefined;
    id: number | undefined;

    constructor(data?: IResultMessageIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ResultMessageIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultMessageIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["id"] = this.id;
        return data;
    }

    clone(): ResultMessageIdDto {
        const json = this.toJSON();
        let result = new ResultMessageIdDto();
        result.init(json);
        return result;
    }
}

export interface IResultMessageIdDto {
    message: string | undefined;
    id: number | undefined;
}

export class GetAccountListDto implements IGetAccountListDto {
    syntheticAccount: string | undefined;
    symbol: string | undefined;

    constructor(data?: IGetAccountListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.syntheticAccount = _data["syntheticAccount"];
            this.symbol = _data["symbol"];
        }
    }

    static fromJS(data: any): GetAccountListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syntheticAccount"] = this.syntheticAccount;
        data["symbol"] = this.symbol;
        return data;
    }

    clone(): GetAccountListDto {
        const json = this.toJSON();
        let result = new GetAccountListDto();
        result.init(json);
        return result;
    }
}

export interface IGetAccountListDto {
    syntheticAccount: string | undefined;
    symbol: string | undefined;
}

export class Decimal implements IDecimal {

    constructor(data?: IDecimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Decimal {
        data = typeof data === 'object' ? data : {};
        let result = new Decimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): Decimal {
        const json = this.toJSON();
        let result = new Decimal();
        result.init(json);
        return result;
    }
}

export interface IDecimal {
}

export class ResultMessageValueDto implements IResultMessageValueDto {
    message: string | undefined;
    value: number | undefined;

    constructor(data?: IResultMessageValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ResultMessageValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultMessageValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["value"] = this.value;
        return data;
    }

    clone(): ResultMessageValueDto {
        const json = this.toJSON();
        let result = new ResultMessageValueDto();
        result.init(json);
        return result;
    }
}

export interface IResultMessageValueDto {
    message: string | undefined;
    value: number | undefined;
}

export class OperationAutoDetailDirectDto implements IOperationAutoDetailDirectDto {
    debit: string | undefined;
    credit: string | undefined;
    value: number;
    explicatii: string | undefined;

    constructor(data?: IOperationAutoDetailDirectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debit = _data["debit"];
            this.credit = _data["credit"];
            this.value = _data["value"];
            this.explicatii = _data["explicatii"];
        }
    }

    static fromJS(data: any): OperationAutoDetailDirectDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationAutoDetailDirectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["value"] = this.value;
        data["explicatii"] = this.explicatii;
        return data;
    }

    clone(): OperationAutoDetailDirectDto {
        const json = this.toJSON();
        let result = new OperationAutoDetailDirectDto();
        result.init(json);
        return result;
    }
}

export interface IOperationAutoDetailDirectDto {
    debit: string | undefined;
    credit: string | undefined;
    value: number;
    explicatii: string | undefined;
}

export class OperationAutoDirectDto implements IOperationAutoDirectDto {
    operationDate: string | undefined;
    documentNr: string | undefined;
    documentDate: string | undefined;
    currency: string | undefined;
    documentType: string | undefined;
    details: OperationAutoDetailDirectDto[] | undefined;

    constructor(data?: IOperationAutoDirectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"];
            this.currency = _data["currency"];
            this.documentType = _data["documentType"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(OperationAutoDetailDirectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OperationAutoDirectDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationAutoDirectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate;
        data["currency"] = this.currency;
        data["documentType"] = this.documentType;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): OperationAutoDirectDto {
        const json = this.toJSON();
        let result = new OperationAutoDirectDto();
        result.init(json);
        return result;
    }
}

export interface IOperationAutoDirectDto {
    operationDate: string | undefined;
    documentNr: string | undefined;
    documentDate: string | undefined;
    currency: string | undefined;
    documentType: string | undefined;
    details: OperationAutoDetailDirectDto[] | undefined;
}

export class OperationAutoDetailDto implements IOperationAutoDetailDto {
    valueType: number;
    value: number;
    bank: string | undefined;
    explicatii: string | undefined;
    storno: boolean;

    constructor(data?: IOperationAutoDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valueType = _data["valueType"];
            this.value = _data["value"];
            this.bank = _data["bank"];
            this.explicatii = _data["explicatii"];
            this.storno = _data["storno"];
        }
    }

    static fromJS(data: any): OperationAutoDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationAutoDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueType"] = this.valueType;
        data["value"] = this.value;
        data["bank"] = this.bank;
        data["explicatii"] = this.explicatii;
        data["storno"] = this.storno;
        return data;
    }

    clone(): OperationAutoDetailDto {
        const json = this.toJSON();
        let result = new OperationAutoDetailDto();
        result.init(json);
        return result;
    }
}

export interface IOperationAutoDetailDto {
    valueType: number;
    value: number;
    bank: string | undefined;
    explicatii: string | undefined;
    storno: boolean;
}

export class OperationAutoDto implements IOperationAutoDto {
    operationDate: string | undefined;
    documentNr: string | undefined;
    documentDate: string | undefined;
    currency: string | undefined;
    activityType: string | undefined;
    operType: number;
    operationType: number;
    details: OperationAutoDetailDto[] | undefined;

    constructor(data?: IOperationAutoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"];
            this.currency = _data["currency"];
            this.activityType = _data["activityType"];
            this.operType = _data["operType"];
            this.operationType = _data["operationType"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(OperationAutoDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OperationAutoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationAutoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate;
        data["currency"] = this.currency;
        data["activityType"] = this.activityType;
        data["operType"] = this.operType;
        data["operationType"] = this.operationType;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): OperationAutoDto {
        const json = this.toJSON();
        let result = new OperationAutoDto();
        result.init(json);
        return result;
    }
}

export interface IOperationAutoDto {
    operationDate: string | undefined;
    documentNr: string | undefined;
    documentDate: string | undefined;
    currency: string | undefined;
    activityType: string | undefined;
    operType: number;
    operationType: number;
    details: OperationAutoDetailDto[] | undefined;
}

export class ResultMessageStringDto implements IResultMessageStringDto {
    message: string | undefined;
    value: string | undefined;

    constructor(data?: IResultMessageStringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ResultMessageStringDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultMessageStringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["value"] = this.value;
        return data;
    }

    clone(): ResultMessageStringDto {
        const json = this.toJSON();
        let result = new ResultMessageStringDto();
        result.init(json);
        return result;
    }
}

export interface IResultMessageStringDto {
    message: string | undefined;
    value: string | undefined;
}

export class ResultSitResurseDto implements IResultSitResurseDto {
    fGcuProfitCurent: number;
    fRcuProfitCurent: number;
    message: string | undefined;

    constructor(data?: IResultSitResurseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fGcuProfitCurent = _data["fGcuProfitCurent"];
            this.fRcuProfitCurent = _data["fRcuProfitCurent"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ResultSitResurseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultSitResurseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fGcuProfitCurent"] = this.fGcuProfitCurent;
        data["fRcuProfitCurent"] = this.fRcuProfitCurent;
        data["message"] = this.message;
        return data;
    }

    clone(): ResultSitResurseDto {
        const json = this.toJSON();
        let result = new ResultSitResurseDto();
        result.init(json);
        return result;
    }
}

export interface IResultSitResurseDto {
    fGcuProfitCurent: number;
    fRcuProfitCurent: number;
    message: string | undefined;
}

export class AutoOperationSummaryDetailDto implements IAutoOperationSummaryDetailDto {
    assetName: string | undefined;
    debitAccount: string | undefined;
    creditAccount: string | undefined;
    value: number;
    valueCurr: number;
    details: string | undefined;
    operationalId: number;
    operationDetailId: number | undefined;

    constructor(data?: IAutoOperationSummaryDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetName = _data["assetName"];
            this.debitAccount = _data["debitAccount"];
            this.creditAccount = _data["creditAccount"];
            this.value = _data["value"];
            this.valueCurr = _data["valueCurr"];
            this.details = _data["details"];
            this.operationalId = _data["operationalId"];
            this.operationDetailId = _data["operationDetailId"];
        }
    }

    static fromJS(data: any): AutoOperationSummaryDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoOperationSummaryDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetName"] = this.assetName;
        data["debitAccount"] = this.debitAccount;
        data["creditAccount"] = this.creditAccount;
        data["value"] = this.value;
        data["valueCurr"] = this.valueCurr;
        data["details"] = this.details;
        data["operationalId"] = this.operationalId;
        data["operationDetailId"] = this.operationDetailId;
        return data;
    }

    clone(): AutoOperationSummaryDetailDto {
        const json = this.toJSON();
        let result = new AutoOperationSummaryDetailDto();
        result.init(json);
        return result;
    }
}

export interface IAutoOperationSummaryDetailDto {
    assetName: string | undefined;
    debitAccount: string | undefined;
    creditAccount: string | undefined;
    value: number;
    valueCurr: number;
    details: string | undefined;
    operationalId: number;
    operationDetailId: number | undefined;
}

export class AutoOperationSummaryDto implements IAutoOperationSummaryDto {
    id: number;
    autoOperType: number;
    operationTypeId: number;
    operationType: string | undefined;
    operationDate: moment.Moment;
    currencyId: number;
    currency: string | undefined;
    documentType: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    showDetail: boolean;
    summaryDetail: AutoOperationSummaryDetailDto[] | undefined;

    constructor(data?: IAutoOperationSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.autoOperType = _data["autoOperType"];
            this.operationTypeId = _data["operationTypeId"];
            this.operationType = _data["operationType"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"];
            this.documentType = _data["documentType"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.showDetail = _data["showDetail"];
            if (Array.isArray(_data["summaryDetail"])) {
                this.summaryDetail = [] as any;
                for (let item of _data["summaryDetail"])
                    this.summaryDetail.push(AutoOperationSummaryDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AutoOperationSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoOperationSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["autoOperType"] = this.autoOperType;
        data["operationTypeId"] = this.operationTypeId;
        data["operationType"] = this.operationType;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency;
        data["documentType"] = this.documentType;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["showDetail"] = this.showDetail;
        if (Array.isArray(this.summaryDetail)) {
            data["summaryDetail"] = [];
            for (let item of this.summaryDetail)
                data["summaryDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): AutoOperationSummaryDto {
        const json = this.toJSON();
        let result = new AutoOperationSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IAutoOperationSummaryDto {
    id: number;
    autoOperType: number;
    operationTypeId: number;
    operationType: string | undefined;
    operationDate: moment.Moment;
    currencyId: number;
    currency: string | undefined;
    documentType: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    showDetail: boolean;
    summaryDetail: AutoOperationSummaryDetailDto[] | undefined;
}

export class AutoOperationComputeDto implements IAutoOperationComputeDto {
    operationId: number | undefined;
    operationDetailId: number | undefined;
    gestId: number | undefined;
    operationDate: moment.Moment;
    documentTypeId: number | undefined;
    documentType: string | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment | undefined;
    currencyId: number;
    currency: string | undefined;
    operationTypeId: number;
    operationType: string | undefined;
    itemId: number;
    itemName: string | undefined;
    storageOutId: number | undefined;
    storageOut: string | undefined;
    storageInId: number | undefined;
    storageIn: string | undefined;
    inventoryValue: number;
    depreciationValue: number;
    vatValue: number;
    depreciationVAT: number;
    accountSort: string | undefined;

    constructor(data?: IAutoOperationComputeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationId = _data["operationId"];
            this.operationDetailId = _data["operationDetailId"];
            this.gestId = _data["gestId"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"];
            this.operationTypeId = _data["operationTypeId"];
            this.operationType = _data["operationType"];
            this.itemId = _data["itemId"];
            this.itemName = _data["itemName"];
            this.storageOutId = _data["storageOutId"];
            this.storageOut = _data["storageOut"];
            this.storageInId = _data["storageInId"];
            this.storageIn = _data["storageIn"];
            this.inventoryValue = _data["inventoryValue"];
            this.depreciationValue = _data["depreciationValue"];
            this.vatValue = _data["vatValue"];
            this.depreciationVAT = _data["depreciationVAT"];
            this.accountSort = _data["accountSort"];
        }
    }

    static fromJS(data: any): AutoOperationComputeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoOperationComputeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationId"] = this.operationId;
        data["operationDetailId"] = this.operationDetailId;
        data["gestId"] = this.gestId;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency;
        data["operationTypeId"] = this.operationTypeId;
        data["operationType"] = this.operationType;
        data["itemId"] = this.itemId;
        data["itemName"] = this.itemName;
        data["storageOutId"] = this.storageOutId;
        data["storageOut"] = this.storageOut;
        data["storageInId"] = this.storageInId;
        data["storageIn"] = this.storageIn;
        data["inventoryValue"] = this.inventoryValue;
        data["depreciationValue"] = this.depreciationValue;
        data["vatValue"] = this.vatValue;
        data["depreciationVAT"] = this.depreciationVAT;
        data["accountSort"] = this.accountSort;
        return data;
    }

    clone(): AutoOperationComputeDto {
        const json = this.toJSON();
        let result = new AutoOperationComputeDto();
        result.init(json);
        return result;
    }
}

export interface IAutoOperationComputeDto {
    operationId: number | undefined;
    operationDetailId: number | undefined;
    gestId: number | undefined;
    operationDate: moment.Moment;
    documentTypeId: number | undefined;
    documentType: string | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment | undefined;
    currencyId: number;
    currency: string | undefined;
    operationTypeId: number;
    operationType: string | undefined;
    itemId: number;
    itemName: string | undefined;
    storageOutId: number | undefined;
    storageOut: string | undefined;
    storageInId: number | undefined;
    storageIn: string | undefined;
    inventoryValue: number;
    depreciationValue: number;
    vatValue: number;
    depreciationVAT: number;
    accountSort: string | undefined;
}

export class AutoOperationDto implements IAutoOperationDto {
    autoOperType: number | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    showSearchForm: boolean;
    showSummary: boolean;
    showResults: boolean;
    showCompute: boolean;
    showComputeDetails: boolean;
    addStartDate: moment.Moment;
    addEndDate: moment.Moment;
    summary: AutoOperationSummaryDto[] | undefined;
    prepareCompute: AutoOperationComputeDto[] | undefined;

    constructor(data?: IAutoOperationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoOperType = _data["autoOperType"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.showSearchForm = _data["showSearchForm"];
            this.showSummary = _data["showSummary"];
            this.showResults = _data["showResults"];
            this.showCompute = _data["showCompute"];
            this.showComputeDetails = _data["showComputeDetails"];
            this.addStartDate = _data["addStartDate"] ? moment(_data["addStartDate"].toString()) : <any>undefined;
            this.addEndDate = _data["addEndDate"] ? moment(_data["addEndDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["summary"])) {
                this.summary = [] as any;
                for (let item of _data["summary"])
                    this.summary.push(AutoOperationSummaryDto.fromJS(item));
            }
            if (Array.isArray(_data["prepareCompute"])) {
                this.prepareCompute = [] as any;
                for (let item of _data["prepareCompute"])
                    this.prepareCompute.push(AutoOperationComputeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AutoOperationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoOperationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoOperType"] = this.autoOperType;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["showSearchForm"] = this.showSearchForm;
        data["showSummary"] = this.showSummary;
        data["showResults"] = this.showResults;
        data["showCompute"] = this.showCompute;
        data["showComputeDetails"] = this.showComputeDetails;
        data["addStartDate"] = this.addStartDate ? this.addStartDate.toISOString() : <any>undefined;
        data["addEndDate"] = this.addEndDate ? this.addEndDate.toISOString() : <any>undefined;
        if (Array.isArray(this.summary)) {
            data["summary"] = [];
            for (let item of this.summary)
                data["summary"].push(item.toJSON());
        }
        if (Array.isArray(this.prepareCompute)) {
            data["prepareCompute"] = [];
            for (let item of this.prepareCompute)
                data["prepareCompute"].push(item.toJSON());
        }
        return data;
    }

    clone(): AutoOperationDto {
        const json = this.toJSON();
        let result = new AutoOperationDto();
        result.init(json);
        return result;
    }
}

export interface IAutoOperationDto {
    autoOperType: number | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    showSearchForm: boolean;
    showSummary: boolean;
    showResults: boolean;
    showCompute: boolean;
    showComputeDetails: boolean;
    addStartDate: moment.Moment;
    addEndDate: moment.Moment;
    summary: AutoOperationSummaryDto[] | undefined;
    prepareCompute: AutoOperationComputeDto[] | undefined;
}

export class AutoOperationConfigDetailsDto implements IAutoOperationConfigDetailsDto {
    id: number;
    autoOperType: number;
    operationType: number;
    valueSign: number;
    elementId: number;
    debitAccount: string | undefined;
    creditAccount: string | undefined;
    details: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    entryOrder: number;
    deleted: boolean;
    individualOperation: boolean;
    unreceiveInvoice: boolean;
    autoOperSearchConfigId: number;

    constructor(data?: IAutoOperationConfigDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.autoOperType = _data["autoOperType"];
            this.operationType = _data["operationType"];
            this.valueSign = _data["valueSign"];
            this.elementId = _data["elementId"];
            this.debitAccount = _data["debitAccount"];
            this.creditAccount = _data["creditAccount"];
            this.details = _data["details"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.entryOrder = _data["entryOrder"];
            this.deleted = _data["deleted"];
            this.individualOperation = _data["individualOperation"];
            this.unreceiveInvoice = _data["unreceiveInvoice"];
            this.autoOperSearchConfigId = _data["autoOperSearchConfigId"];
        }
    }

    static fromJS(data: any): AutoOperationConfigDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoOperationConfigDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["autoOperType"] = this.autoOperType;
        data["operationType"] = this.operationType;
        data["valueSign"] = this.valueSign;
        data["elementId"] = this.elementId;
        data["debitAccount"] = this.debitAccount;
        data["creditAccount"] = this.creditAccount;
        data["details"] = this.details;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["entryOrder"] = this.entryOrder;
        data["deleted"] = this.deleted;
        data["individualOperation"] = this.individualOperation;
        data["unreceiveInvoice"] = this.unreceiveInvoice;
        data["autoOperSearchConfigId"] = this.autoOperSearchConfigId;
        return data;
    }

    clone(): AutoOperationConfigDetailsDto {
        const json = this.toJSON();
        let result = new AutoOperationConfigDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IAutoOperationConfigDetailsDto {
    id: number;
    autoOperType: number;
    operationType: number;
    valueSign: number;
    elementId: number;
    debitAccount: string | undefined;
    creditAccount: string | undefined;
    details: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    entryOrder: number;
    deleted: boolean;
    individualOperation: boolean;
    unreceiveInvoice: boolean;
    autoOperSearchConfigId: number;
}

export class AutoOperationConfigDto implements IAutoOperationConfigDto {
    autoOperType: number;
    operationType: number;
    searchDate: moment.Moment;
    noDateSearch: boolean;
    showUnreceiveInvoice: boolean;
    showExternalIssuer: boolean;
    documentTypeId: number | undefined;
    autoOperSearchConfigId: number | undefined;
    details: AutoOperationConfigDetailsDto[] | undefined;

    constructor(data?: IAutoOperationConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoOperType = _data["autoOperType"];
            this.operationType = _data["operationType"];
            this.searchDate = _data["searchDate"] ? moment(_data["searchDate"].toString()) : <any>undefined;
            this.noDateSearch = _data["noDateSearch"];
            this.showUnreceiveInvoice = _data["showUnreceiveInvoice"];
            this.showExternalIssuer = _data["showExternalIssuer"];
            this.documentTypeId = _data["documentTypeId"];
            this.autoOperSearchConfigId = _data["autoOperSearchConfigId"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(AutoOperationConfigDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AutoOperationConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoOperationConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoOperType"] = this.autoOperType;
        data["operationType"] = this.operationType;
        data["searchDate"] = this.searchDate ? this.searchDate.toISOString() : <any>undefined;
        data["noDateSearch"] = this.noDateSearch;
        data["showUnreceiveInvoice"] = this.showUnreceiveInvoice;
        data["showExternalIssuer"] = this.showExternalIssuer;
        data["documentTypeId"] = this.documentTypeId;
        data["autoOperSearchConfigId"] = this.autoOperSearchConfigId;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): AutoOperationConfigDto {
        const json = this.toJSON();
        let result = new AutoOperationConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAutoOperationConfigDto {
    autoOperType: number;
    operationType: number;
    searchDate: moment.Moment;
    noDateSearch: boolean;
    showUnreceiveInvoice: boolean;
    showExternalIssuer: boolean;
    documentTypeId: number | undefined;
    autoOperSearchConfigId: number | undefined;
    details: AutoOperationConfigDetailsDto[] | undefined;
}

export class AccountConfigDDDto implements IAccountConfigDDDto {
    id: string | undefined;
    name: string | undefined;

    constructor(data?: IAccountConfigDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AccountConfigDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountConfigDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): AccountConfigDDDto {
        const json = this.toJSON();
        let result = new AccountConfigDDDto();
        result.init(json);
        return result;
    }
}

export interface IAccountConfigDDDto {
    id: string | undefined;
    name: string | undefined;
}

export class BalanceListDto implements IBalanceListDto {
    id: number;
    balanceDate: string | undefined;
    okDelete: boolean;
    okValid: boolean;

    constructor(data?: IBalanceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.balanceDate = _data["balanceDate"];
            this.okDelete = _data["okDelete"];
            this.okValid = _data["okValid"];
        }
    }

    static fromJS(data: any): BalanceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["balanceDate"] = this.balanceDate;
        data["okDelete"] = this.okDelete;
        data["okValid"] = this.okValid;
        return data;
    }

    clone(): BalanceListDto {
        const json = this.toJSON();
        let result = new BalanceListDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceListDto {
    id: number;
    balanceDate: string | undefined;
    okDelete: boolean;
    okValid: boolean;
}

export enum BalanceType {
    _0 = 0,
    _1 = 1,
}

export enum AccountTypes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class BalanceDetailDto implements IBalanceDetailDto {
    crValueI: number;
    dbValueI: number;
    crValueM: number;
    dbValueM: number;
    crValueY: number;
    dbValueY: number;
    crValueF: number;
    dbValueF: number;
    dbValueP: number;
    crValueP: number;
    dbValueT: number;
    crValueT: number;
    dbValueSum: number;
    crValueSum: number;
    id: number;
    symbol: string | undefined;
    name: string | undefined;
    currencyId: number;
    appClientId: number;
    totalSum: boolean;
    synthetic: string | undefined;
    analythic: string | undefined;
    accountType: AccountTypes;
    nivelRand: number | undefined;

    constructor(data?: IBalanceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.crValueI = _data["crValueI"];
            this.dbValueI = _data["dbValueI"];
            this.crValueM = _data["crValueM"];
            this.dbValueM = _data["dbValueM"];
            this.crValueY = _data["crValueY"];
            this.dbValueY = _data["dbValueY"];
            this.crValueF = _data["crValueF"];
            this.dbValueF = _data["dbValueF"];
            this.dbValueP = _data["dbValueP"];
            this.crValueP = _data["crValueP"];
            this.dbValueT = _data["dbValueT"];
            this.crValueT = _data["crValueT"];
            this.dbValueSum = _data["dbValueSum"];
            this.crValueSum = _data["crValueSum"];
            this.id = _data["id"];
            this.symbol = _data["symbol"];
            this.name = _data["name"];
            this.currencyId = _data["currencyId"];
            this.appClientId = _data["appClientId"];
            this.totalSum = _data["totalSum"];
            this.synthetic = _data["synthetic"];
            this.analythic = _data["analythic"];
            this.accountType = _data["accountType"];
            this.nivelRand = _data["nivelRand"];
        }
    }

    static fromJS(data: any): BalanceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["crValueI"] = this.crValueI;
        data["dbValueI"] = this.dbValueI;
        data["crValueM"] = this.crValueM;
        data["dbValueM"] = this.dbValueM;
        data["crValueY"] = this.crValueY;
        data["dbValueY"] = this.dbValueY;
        data["crValueF"] = this.crValueF;
        data["dbValueF"] = this.dbValueF;
        data["dbValueP"] = this.dbValueP;
        data["crValueP"] = this.crValueP;
        data["dbValueT"] = this.dbValueT;
        data["crValueT"] = this.crValueT;
        data["dbValueSum"] = this.dbValueSum;
        data["crValueSum"] = this.crValueSum;
        data["id"] = this.id;
        data["symbol"] = this.symbol;
        data["name"] = this.name;
        data["currencyId"] = this.currencyId;
        data["appClientId"] = this.appClientId;
        data["totalSum"] = this.totalSum;
        data["synthetic"] = this.synthetic;
        data["analythic"] = this.analythic;
        data["accountType"] = this.accountType;
        data["nivelRand"] = this.nivelRand;
        return data;
    }

    clone(): BalanceDetailDto {
        const json = this.toJSON();
        let result = new BalanceDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceDetailDto {
    crValueI: number;
    dbValueI: number;
    crValueM: number;
    dbValueM: number;
    crValueY: number;
    dbValueY: number;
    crValueF: number;
    dbValueF: number;
    dbValueP: number;
    crValueP: number;
    dbValueT: number;
    crValueT: number;
    dbValueSum: number;
    crValueSum: number;
    id: number;
    symbol: string | undefined;
    name: string | undefined;
    currencyId: number;
    appClientId: number;
    totalSum: boolean;
    synthetic: string | undefined;
    analythic: string | undefined;
    accountType: AccountTypes;
    nivelRand: number | undefined;
}

export class ViewBalanceDetailDto implements IViewBalanceDetailDto {
    id: number;
    currencyId: number;
    balanceDate: string | undefined;
    searchAccount: string | undefined;
    balanceTypeStr: string | undefined;
    balanceType: BalanceType;
    balanceDetail: BalanceDetailDto[] | undefined;

    constructor(data?: IViewBalanceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyId = _data["currencyId"];
            this.balanceDate = _data["balanceDate"];
            this.searchAccount = _data["searchAccount"];
            this.balanceTypeStr = _data["balanceTypeStr"];
            this.balanceType = _data["balanceType"];
            if (Array.isArray(_data["balanceDetail"])) {
                this.balanceDetail = [] as any;
                for (let item of _data["balanceDetail"])
                    this.balanceDetail.push(BalanceDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewBalanceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewBalanceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyId"] = this.currencyId;
        data["balanceDate"] = this.balanceDate;
        data["searchAccount"] = this.searchAccount;
        data["balanceTypeStr"] = this.balanceTypeStr;
        data["balanceType"] = this.balanceType;
        if (Array.isArray(this.balanceDetail)) {
            data["balanceDetail"] = [];
            for (let item of this.balanceDetail)
                data["balanceDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): ViewBalanceDetailDto {
        const json = this.toJSON();
        let result = new ViewBalanceDetailDto();
        result.init(json);
        return result;
    }
}

export interface IViewBalanceDetailDto {
    id: number;
    currencyId: number;
    balanceDate: string | undefined;
    searchAccount: string | undefined;
    balanceTypeStr: string | undefined;
    balanceType: BalanceType;
    balanceDetail: BalanceDetailDto[] | undefined;
}

export class BalanceInitDto implements IBalanceInitDto {
    searchStartDate: moment.Moment;
    searchEndDate: moment.Moment;
    calcDate: moment.Moment;
    closingMonthOper: boolean;
    showComputeForm: boolean;
    balanceList: BalanceListDto[] | undefined;
    showForm: number;
    viewBalanceDetail: ViewBalanceDetailDto;

    constructor(data?: IBalanceInitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchStartDate = _data["searchStartDate"] ? moment(_data["searchStartDate"].toString()) : <any>undefined;
            this.searchEndDate = _data["searchEndDate"] ? moment(_data["searchEndDate"].toString()) : <any>undefined;
            this.calcDate = _data["calcDate"] ? moment(_data["calcDate"].toString()) : <any>undefined;
            this.closingMonthOper = _data["closingMonthOper"];
            this.showComputeForm = _data["showComputeForm"];
            if (Array.isArray(_data["balanceList"])) {
                this.balanceList = [] as any;
                for (let item of _data["balanceList"])
                    this.balanceList.push(BalanceListDto.fromJS(item));
            }
            this.showForm = _data["showForm"];
            this.viewBalanceDetail = _data["viewBalanceDetail"] ? ViewBalanceDetailDto.fromJS(_data["viewBalanceDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BalanceInitDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceInitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchStartDate"] = this.searchStartDate ? this.searchStartDate.toISOString() : <any>undefined;
        data["searchEndDate"] = this.searchEndDate ? this.searchEndDate.toISOString() : <any>undefined;
        data["calcDate"] = this.calcDate ? this.calcDate.toISOString() : <any>undefined;
        data["closingMonthOper"] = this.closingMonthOper;
        data["showComputeForm"] = this.showComputeForm;
        if (Array.isArray(this.balanceList)) {
            data["balanceList"] = [];
            for (let item of this.balanceList)
                data["balanceList"].push(item.toJSON());
        }
        data["showForm"] = this.showForm;
        data["viewBalanceDetail"] = this.viewBalanceDetail ? this.viewBalanceDetail.toJSON() : <any>undefined;
        return data;
    }

    clone(): BalanceInitDto {
        const json = this.toJSON();
        let result = new BalanceInitDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceInitDto {
    searchStartDate: moment.Moment;
    searchEndDate: moment.Moment;
    calcDate: moment.Moment;
    closingMonthOper: boolean;
    showComputeForm: boolean;
    balanceList: BalanceListDto[] | undefined;
    showForm: number;
    viewBalanceDetail: ViewBalanceDetailDto;
}

export class BalanceDDDto implements IBalanceDDDto {
    id: number;
    balanceDate: string | undefined;

    constructor(data?: IBalanceDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.balanceDate = _data["balanceDate"];
        }
    }

    static fromJS(data: any): BalanceDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["balanceDate"] = this.balanceDate;
        return data;
    }

    clone(): BalanceDDDto {
        const json = this.toJSON();
        let result = new BalanceDDDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceDDDto {
    id: number;
    balanceDate: string | undefined;
}

export class BalanceCompSummaryDto implements IBalanceCompSummaryDto {
    module: string | undefined;
    summary: string | undefined;
    ok: boolean;

    constructor(data?: IBalanceCompSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.summary = _data["summary"];
            this.ok = _data["ok"];
        }
    }

    static fromJS(data: any): BalanceCompSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceCompSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["summary"] = this.summary;
        data["ok"] = this.ok;
        return data;
    }

    clone(): BalanceCompSummaryDto {
        const json = this.toJSON();
        let result = new BalanceCompSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceCompSummaryDto {
    module: string | undefined;
    summary: string | undefined;
    ok: boolean;
}

export class BalanceCompValidDto implements IBalanceCompValidDto {
    module: string | undefined;
    element: string | undefined;
    balanceValue: number;
    gestValue: number;
    ok: boolean;

    constructor(data?: IBalanceCompValidDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.module = _data["module"];
            this.element = _data["element"];
            this.balanceValue = _data["balanceValue"];
            this.gestValue = _data["gestValue"];
            this.ok = _data["ok"];
        }
    }

    static fromJS(data: any): BalanceCompValidDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceCompValidDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["element"] = this.element;
        data["balanceValue"] = this.balanceValue;
        data["gestValue"] = this.gestValue;
        data["ok"] = this.ok;
        return data;
    }

    clone(): BalanceCompValidDto {
        const json = this.toJSON();
        let result = new BalanceCompValidDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceCompValidDto {
    module: string | undefined;
    element: string | undefined;
    balanceValue: number;
    gestValue: number;
    ok: boolean;
}

export class BNR_AnexaDto implements IBNR_AnexaDto {
    id: number;
    denumire: string | undefined;

    constructor(data?: IBNR_AnexaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.denumire = _data["denumire"];
        }
    }

    static fromJS(data: any): BNR_AnexaDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_AnexaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["denumire"] = this.denumire;
        return data;
    }

    clone(): BNR_AnexaDto {
        const json = this.toJSON();
        let result = new BNR_AnexaDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_AnexaDto {
    id: number;
    denumire: string | undefined;
}

export class BNR_AnexaDetailDto implements IBNR_AnexaDetailDto {
    id: number;
    nrCrt: string | undefined;
    denumireRand: string | undefined;
    codRand: string | undefined;
    eDinConta: boolean;
    formulaConta: string | undefined;
    formulaTotal: string | undefined;
    formulaCresteri: string | undefined;
    formulaReduceri: string | undefined;
    tipTitlu: string | undefined;
    tipInstrument: string | undefined;
    sectorizare: boolean;
    anexaId: number | undefined;

    constructor(data?: IBNR_AnexaDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nrCrt = _data["nrCrt"];
            this.denumireRand = _data["denumireRand"];
            this.codRand = _data["codRand"];
            this.eDinConta = _data["eDinConta"];
            this.formulaConta = _data["formulaConta"];
            this.formulaTotal = _data["formulaTotal"];
            this.formulaCresteri = _data["formulaCresteri"];
            this.formulaReduceri = _data["formulaReduceri"];
            this.tipTitlu = _data["tipTitlu"];
            this.tipInstrument = _data["tipInstrument"];
            this.sectorizare = _data["sectorizare"];
            this.anexaId = _data["anexaId"];
        }
    }

    static fromJS(data: any): BNR_AnexaDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_AnexaDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nrCrt"] = this.nrCrt;
        data["denumireRand"] = this.denumireRand;
        data["codRand"] = this.codRand;
        data["eDinConta"] = this.eDinConta;
        data["formulaConta"] = this.formulaConta;
        data["formulaTotal"] = this.formulaTotal;
        data["formulaCresteri"] = this.formulaCresteri;
        data["formulaReduceri"] = this.formulaReduceri;
        data["tipTitlu"] = this.tipTitlu;
        data["tipInstrument"] = this.tipInstrument;
        data["sectorizare"] = this.sectorizare;
        data["anexaId"] = this.anexaId;
        return data;
    }

    clone(): BNR_AnexaDetailDto {
        const json = this.toJSON();
        let result = new BNR_AnexaDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_AnexaDetailDto {
    id: number;
    nrCrt: string | undefined;
    denumireRand: string | undefined;
    codRand: string | undefined;
    eDinConta: boolean;
    formulaConta: string | undefined;
    formulaTotal: string | undefined;
    formulaCresteri: string | undefined;
    formulaReduceri: string | undefined;
    tipTitlu: string | undefined;
    tipInstrument: string | undefined;
    sectorizare: boolean;
    anexaId: number | undefined;
}

export enum State {
    _0 = 0,
    _1 = 1,
}

export class AnexaBnrEditDto implements IAnexaBnrEditDto {
    id: number;
    nrCrt: string | undefined;
    denumireRand: string | undefined;
    eDinConta: boolean;
    formulaConta: string | undefined;
    formulaTotal: string | undefined;
    tipInstrument: string | undefined;
    durataMinima: number | undefined;
    durataMaxima: number | undefined;
    sectorizare: boolean;
    state: State;
    tenantId: number;

    constructor(data?: IAnexaBnrEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nrCrt = _data["nrCrt"];
            this.denumireRand = _data["denumireRand"];
            this.eDinConta = _data["eDinConta"];
            this.formulaConta = _data["formulaConta"];
            this.formulaTotal = _data["formulaTotal"];
            this.tipInstrument = _data["tipInstrument"];
            this.durataMinima = _data["durataMinima"];
            this.durataMaxima = _data["durataMaxima"];
            this.sectorizare = _data["sectorizare"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AnexaBnrEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnexaBnrEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nrCrt"] = this.nrCrt;
        data["denumireRand"] = this.denumireRand;
        data["eDinConta"] = this.eDinConta;
        data["formulaConta"] = this.formulaConta;
        data["formulaTotal"] = this.formulaTotal;
        data["tipInstrument"] = this.tipInstrument;
        data["durataMinima"] = this.durataMinima;
        data["durataMaxima"] = this.durataMaxima;
        data["sectorizare"] = this.sectorizare;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): AnexaBnrEditDto {
        const json = this.toJSON();
        let result = new AnexaBnrEditDto();
        result.init(json);
        return result;
    }
}

export interface IAnexaBnrEditDto {
    id: number;
    nrCrt: string | undefined;
    denumireRand: string | undefined;
    eDinConta: boolean;
    formulaConta: string | undefined;
    formulaTotal: string | undefined;
    tipInstrument: string | undefined;
    durataMinima: number | undefined;
    durataMaxima: number | undefined;
    sectorizare: boolean;
    state: State;
    tenantId: number;
}

export class BNR_RaportareDto implements IBNR_RaportareDto {
    id: number;
    savedBalanceId: number;
    savedDate: moment.Moment;
    balanceName: string | undefined;
    anexaId: number;
    tenantId: number;

    constructor(data?: IBNR_RaportareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.savedBalanceId = _data["savedBalanceId"];
            this.savedDate = _data["savedDate"] ? moment(_data["savedDate"].toString()) : <any>undefined;
            this.balanceName = _data["balanceName"];
            this.anexaId = _data["anexaId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BNR_RaportareDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_RaportareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["savedBalanceId"] = this.savedBalanceId;
        data["savedDate"] = this.savedDate ? this.savedDate.toISOString() : <any>undefined;
        data["balanceName"] = this.balanceName;
        data["anexaId"] = this.anexaId;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BNR_RaportareDto {
        const json = this.toJSON();
        let result = new BNR_RaportareDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_RaportareDto {
    id: number;
    savedBalanceId: number;
    savedDate: moment.Moment;
    balanceName: string | undefined;
    anexaId: number;
    tenantId: number;
}

export class BNR_RaportareRowDetailsDto implements IBNR_RaportareRowDetailsDto {
    id: number;
    bnR_RaportareRandId: number;
    descriere: string | undefined;
    valoare: number;

    constructor(data?: IBNR_RaportareRowDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bnR_RaportareRandId = _data["bnR_RaportareRandId"];
            this.descriere = _data["descriere"];
            this.valoare = _data["valoare"];
        }
    }

    static fromJS(data: any): BNR_RaportareRowDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_RaportareRowDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bnR_RaportareRandId"] = this.bnR_RaportareRandId;
        data["descriere"] = this.descriere;
        data["valoare"] = this.valoare;
        return data;
    }

    clone(): BNR_RaportareRowDetailsDto {
        const json = this.toJSON();
        let result = new BNR_RaportareRowDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_RaportareRowDetailsDto {
    id: number;
    bnR_RaportareRandId: number;
    descriere: string | undefined;
    valoare: number;
}

export class BNR_Detalii implements IBNR_Detalii {
    anexaDetailName: string | undefined;
    sectorName: string | undefined;
    descriere: string | undefined;
    valoare: number;
    orderView: number;

    constructor(data?: IBNR_Detalii) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.anexaDetailName = _data["anexaDetailName"];
            this.sectorName = _data["sectorName"];
            this.descriere = _data["descriere"];
            this.valoare = _data["valoare"];
            this.orderView = _data["orderView"];
        }
    }

    static fromJS(data: any): BNR_Detalii {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_Detalii();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["anexaDetailName"] = this.anexaDetailName;
        data["sectorName"] = this.sectorName;
        data["descriere"] = this.descriere;
        data["valoare"] = this.valoare;
        data["orderView"] = this.orderView;
        return data;
    }

    clone(): BNR_Detalii {
        const json = this.toJSON();
        let result = new BNR_Detalii();
        result.init(json);
        return result;
    }
}

export interface IBNR_Detalii {
    anexaDetailName: string | undefined;
    sectorName: string | undefined;
    descriere: string | undefined;
    valoare: number;
    orderView: number;
}

export class BNR_RaportareRowDto implements IBNR_RaportareRowDto {
    id: number;
    bnR_RaportareId: number;
    anexaDetailId: number;
    anexaDetailName: string | undefined;
    sectorId: number | undefined;
    sectorName: string | undefined;
    valoare: number;
    orderView: number;

    constructor(data?: IBNR_RaportareRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bnR_RaportareId = _data["bnR_RaportareId"];
            this.anexaDetailId = _data["anexaDetailId"];
            this.anexaDetailName = _data["anexaDetailName"];
            this.sectorId = _data["sectorId"];
            this.sectorName = _data["sectorName"];
            this.valoare = _data["valoare"];
            this.orderView = _data["orderView"];
        }
    }

    static fromJS(data: any): BNR_RaportareRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_RaportareRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bnR_RaportareId"] = this.bnR_RaportareId;
        data["anexaDetailId"] = this.anexaDetailId;
        data["anexaDetailName"] = this.anexaDetailName;
        data["sectorId"] = this.sectorId;
        data["sectorName"] = this.sectorName;
        data["valoare"] = this.valoare;
        data["orderView"] = this.orderView;
        return data;
    }

    clone(): BNR_RaportareRowDto {
        const json = this.toJSON();
        let result = new BNR_RaportareRowDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_RaportareRowDto {
    id: number;
    bnR_RaportareId: number;
    anexaDetailId: number;
    anexaDetailName: string | undefined;
    sectorId: number | undefined;
    sectorName: string | undefined;
    valoare: number;
    orderView: number;
}

export class BNR_SectorListDto implements IBNR_SectorListDto {
    id: number;
    sector: string | undefined;
    denumire: string | undefined;

    constructor(data?: IBNR_SectorListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sector = _data["sector"];
            this.denumire = _data["denumire"];
        }
    }

    static fromJS(data: any): BNR_SectorListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_SectorListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sector"] = this.sector;
        data["denumire"] = this.denumire;
        return data;
    }

    clone(): BNR_SectorListDto {
        const json = this.toJSON();
        let result = new BNR_SectorListDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_SectorListDto {
    id: number;
    sector: string | undefined;
    denumire: string | undefined;
}

export class BNR_SectorEditDto implements IBNR_SectorEditDto {
    id: number;
    sector: string | undefined;
    denumire: string | undefined;
    state: State;
    tenantId: number;

    constructor(data?: IBNR_SectorEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sector = _data["sector"];
            this.denumire = _data["denumire"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BNR_SectorEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_SectorEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sector"] = this.sector;
        data["denumire"] = this.denumire;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BNR_SectorEditDto {
        const json = this.toJSON();
        let result = new BNR_SectorEditDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_SectorEditDto {
    id: number;
    sector: string | undefined;
    denumire: string | undefined;
    state: State;
    tenantId: number;
}

export class BNR_SectorRowCalValDto implements IBNR_SectorRowCalValDto {
    rowId: number;
    sectorId: number | undefined;
    sectorCod: string | undefined;
    denumire: string | undefined;
    value: number;

    constructor(data?: IBNR_SectorRowCalValDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowId = _data["rowId"];
            this.sectorId = _data["sectorId"];
            this.sectorCod = _data["sectorCod"];
            this.denumire = _data["denumire"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BNR_SectorRowCalValDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_SectorRowCalValDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowId"] = this.rowId;
        data["sectorId"] = this.sectorId;
        data["sectorCod"] = this.sectorCod;
        data["denumire"] = this.denumire;
        data["value"] = this.value;
        return data;
    }

    clone(): BNR_SectorRowCalValDto {
        const json = this.toJSON();
        let result = new BNR_SectorRowCalValDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_SectorRowCalValDto {
    rowId: number;
    sectorId: number | undefined;
    sectorCod: string | undefined;
    denumire: string | undefined;
    value: number;
}

export class BNR_SectorRowCalcListDto implements IBNR_SectorRowCalcListDto {
    balanceId: number;
    id: number;
    nrCrt: string | undefined;
    anexaId: number;
    anexaDetailId: number;
    sectorizare: boolean;
    denumire: string | undefined;
    tenantId: number;
    readonly isSectored: boolean;
    bnR_RowDetails: BNR_SectorRowCalValDto[] | undefined;

    constructor(data?: IBNR_SectorRowCalcListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.balanceId = _data["balanceId"];
            this.id = _data["id"];
            this.nrCrt = _data["nrCrt"];
            this.anexaId = _data["anexaId"];
            this.anexaDetailId = _data["anexaDetailId"];
            this.sectorizare = _data["sectorizare"];
            this.denumire = _data["denumire"];
            this.tenantId = _data["tenantId"];
            (<any>this).isSectored = _data["isSectored"];
            if (Array.isArray(_data["bnR_RowDetails"])) {
                this.bnR_RowDetails = [] as any;
                for (let item of _data["bnR_RowDetails"])
                    this.bnR_RowDetails.push(BNR_SectorRowCalValDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BNR_SectorRowCalcListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_SectorRowCalcListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balanceId"] = this.balanceId;
        data["id"] = this.id;
        data["nrCrt"] = this.nrCrt;
        data["anexaId"] = this.anexaId;
        data["anexaDetailId"] = this.anexaDetailId;
        data["sectorizare"] = this.sectorizare;
        data["denumire"] = this.denumire;
        data["tenantId"] = this.tenantId;
        data["isSectored"] = this.isSectored;
        if (Array.isArray(this.bnR_RowDetails)) {
            data["bnR_RowDetails"] = [];
            for (let item of this.bnR_RowDetails)
                data["bnR_RowDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): BNR_SectorRowCalcListDto {
        const json = this.toJSON();
        let result = new BNR_SectorRowCalcListDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_SectorRowCalcListDto {
    balanceId: number;
    id: number;
    nrCrt: string | undefined;
    anexaId: number;
    anexaDetailId: number;
    sectorizare: boolean;
    denumire: string | undefined;
    tenantId: number;
    isSectored: boolean;
    bnR_RowDetails: BNR_SectorRowCalValDto[] | undefined;
}

export class BNR_SectorCalculatListDto implements IBNR_SectorCalculatListDto {
    id: number;
    balanceId: number;
    balanceDate: moment.Moment;
    balanceDesc: string | undefined;
    tenantId: number;
    allowCompute: boolean;
    bnR_Rows: BNR_SectorRowCalcListDto[] | undefined;

    constructor(data?: IBNR_SectorCalculatListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.balanceId = _data["balanceId"];
            this.balanceDate = _data["balanceDate"] ? moment(_data["balanceDate"].toString()) : <any>undefined;
            this.balanceDesc = _data["balanceDesc"];
            this.tenantId = _data["tenantId"];
            this.allowCompute = _data["allowCompute"];
            if (Array.isArray(_data["bnR_Rows"])) {
                this.bnR_Rows = [] as any;
                for (let item of _data["bnR_Rows"])
                    this.bnR_Rows.push(BNR_SectorRowCalcListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BNR_SectorCalculatListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_SectorCalculatListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["balanceId"] = this.balanceId;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        data["balanceDesc"] = this.balanceDesc;
        data["tenantId"] = this.tenantId;
        data["allowCompute"] = this.allowCompute;
        if (Array.isArray(this.bnR_Rows)) {
            data["bnR_Rows"] = [];
            for (let item of this.bnR_Rows)
                data["bnR_Rows"].push(item.toJSON());
        }
        return data;
    }

    clone(): BNR_SectorCalculatListDto {
        const json = this.toJSON();
        let result = new BNR_SectorCalculatListDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_SectorCalculatListDto {
    id: number;
    balanceId: number;
    balanceDate: moment.Moment;
    balanceDesc: string | undefined;
    tenantId: number;
    allowCompute: boolean;
    bnR_Rows: BNR_SectorRowCalcListDto[] | undefined;
}

export class BNR_SectorDetailDto implements IBNR_SectorDetailDto {
    savedBalanceId: number;
    anexaDetailId: number;
    account: string | undefined;
    denumire: string | undefined;
    sectorId: number | undefined;
    tenantId: number;
    soldDb: number;
    soldCr: number;
    value: number;

    constructor(data?: IBNR_SectorDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.savedBalanceId = _data["savedBalanceId"];
            this.anexaDetailId = _data["anexaDetailId"];
            this.account = _data["account"];
            this.denumire = _data["denumire"];
            this.sectorId = _data["sectorId"];
            this.tenantId = _data["tenantId"];
            this.soldDb = _data["soldDb"];
            this.soldCr = _data["soldCr"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BNR_SectorDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_SectorDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["savedBalanceId"] = this.savedBalanceId;
        data["anexaDetailId"] = this.anexaDetailId;
        data["account"] = this.account;
        data["denumire"] = this.denumire;
        data["sectorId"] = this.sectorId;
        data["tenantId"] = this.tenantId;
        data["soldDb"] = this.soldDb;
        data["soldCr"] = this.soldCr;
        data["value"] = this.value;
        return data;
    }

    clone(): BNR_SectorDetailDto {
        const json = this.toJSON();
        let result = new BNR_SectorDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_SectorDetailDto {
    savedBalanceId: number;
    anexaDetailId: number;
    account: string | undefined;
    denumire: string | undefined;
    sectorId: number | undefined;
    tenantId: number;
    soldDb: number;
    soldCr: number;
    value: number;
}

export class BugetCheltuieliEditDto implements IBugetCheltuieliEditDto {
    id: number;
    dataIncasare: moment.Moment;
    value: number;
    bvC_FormRandId: number;
    currencyId: number;
    activityTypeId: number;
    departamentId: number;
    descriere: string | undefined;

    constructor(data?: IBugetCheltuieliEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataIncasare = _data["dataIncasare"] ? moment(_data["dataIncasare"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.bvC_FormRandId = _data["bvC_FormRandId"];
            this.currencyId = _data["currencyId"];
            this.activityTypeId = _data["activityTypeId"];
            this.departamentId = _data["departamentId"];
            this.descriere = _data["descriere"];
        }
    }

    static fromJS(data: any): BugetCheltuieliEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetCheltuieliEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataIncasare"] = this.dataIncasare ? this.dataIncasare.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["bvC_FormRandId"] = this.bvC_FormRandId;
        data["currencyId"] = this.currencyId;
        data["activityTypeId"] = this.activityTypeId;
        data["departamentId"] = this.departamentId;
        data["descriere"] = this.descriere;
        return data;
    }

    clone(): BugetCheltuieliEditDto {
        const json = this.toJSON();
        let result = new BugetCheltuieliEditDto();
        result.init(json);
        return result;
    }
}

export interface IBugetCheltuieliEditDto {
    id: number;
    dataIncasare: moment.Moment;
    value: number;
    bvC_FormRandId: number;
    currencyId: number;
    activityTypeId: number;
    departamentId: number;
    descriere: string | undefined;
}

export enum BVC_RowType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum BVC_RowTypeIncome {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum BVC_RowTypeSalarizare {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
}

export class BugetFormRandDetailDto implements IBugetFormRandDetailDto {
    id: number;
    delete: boolean;
    formRandId: number | undefined;
    categoryId: number | undefined;
    tipRandCheltuialaId: number | undefined;
    tenantId: number;

    constructor(data?: IBugetFormRandDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.delete = _data["delete"];
            this.formRandId = _data["formRandId"];
            this.categoryId = _data["categoryId"];
            this.tipRandCheltuialaId = _data["tipRandCheltuialaId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BugetFormRandDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetFormRandDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["delete"] = this.delete;
        data["formRandId"] = this.formRandId;
        data["categoryId"] = this.categoryId;
        data["tipRandCheltuialaId"] = this.tipRandCheltuialaId;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BugetFormRandDetailDto {
        const json = this.toJSON();
        let result = new BugetFormRandDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBugetFormRandDetailDto {
    id: number;
    delete: boolean;
    formRandId: number | undefined;
    categoryId: number | undefined;
    tipRandCheltuialaId: number | undefined;
    tenantId: number;
}

export class BugetFormRandDto implements IBugetFormRandDto {
    id: number;
    formularId: number;
    codRand: number;
    descriere: string | undefined;
    tipRand: BVC_RowType;
    orderView: number;
    insert: boolean;
    categoryId: number;
    randParentId: number | undefined;
    nivelRand: number | undefined;
    isTotal: boolean;
    formulaBVC: string | undefined;
    formulaCashFlow: string | undefined;
    tipRandVenit: BVC_RowTypeIncome;
    tipRandSalarizare: BVC_RowTypeSalarizare;
    tipRandCheltuialaId: number | undefined;
    randParentIdFromUI: number | undefined;
    availableBVC: boolean;
    availableCashFlow: boolean;
    delete: boolean;
    tenantId: number;
    balIsTotal: boolean;
    balFormulaBVC: string | undefined;
    balFormulaCashFlow: string | undefined;
    detaliiRand: BugetFormRandDetailDto[] | undefined;

    constructor(data?: IBugetFormRandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formularId = _data["formularId"];
            this.codRand = _data["codRand"];
            this.descriere = _data["descriere"];
            this.tipRand = _data["tipRand"];
            this.orderView = _data["orderView"];
            this.insert = _data["insert"];
            this.categoryId = _data["categoryId"];
            this.randParentId = _data["randParentId"];
            this.nivelRand = _data["nivelRand"];
            this.isTotal = _data["isTotal"];
            this.formulaBVC = _data["formulaBVC"];
            this.formulaCashFlow = _data["formulaCashFlow"];
            this.tipRandVenit = _data["tipRandVenit"];
            this.tipRandSalarizare = _data["tipRandSalarizare"];
            this.tipRandCheltuialaId = _data["tipRandCheltuialaId"];
            this.randParentIdFromUI = _data["randParentIdFromUI"];
            this.availableBVC = _data["availableBVC"];
            this.availableCashFlow = _data["availableCashFlow"];
            this.delete = _data["delete"];
            this.tenantId = _data["tenantId"];
            this.balIsTotal = _data["balIsTotal"];
            this.balFormulaBVC = _data["balFormulaBVC"];
            this.balFormulaCashFlow = _data["balFormulaCashFlow"];
            if (Array.isArray(_data["detaliiRand"])) {
                this.detaliiRand = [] as any;
                for (let item of _data["detaliiRand"])
                    this.detaliiRand.push(BugetFormRandDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BugetFormRandDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetFormRandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formularId"] = this.formularId;
        data["codRand"] = this.codRand;
        data["descriere"] = this.descriere;
        data["tipRand"] = this.tipRand;
        data["orderView"] = this.orderView;
        data["insert"] = this.insert;
        data["categoryId"] = this.categoryId;
        data["randParentId"] = this.randParentId;
        data["nivelRand"] = this.nivelRand;
        data["isTotal"] = this.isTotal;
        data["formulaBVC"] = this.formulaBVC;
        data["formulaCashFlow"] = this.formulaCashFlow;
        data["tipRandVenit"] = this.tipRandVenit;
        data["tipRandSalarizare"] = this.tipRandSalarizare;
        data["tipRandCheltuialaId"] = this.tipRandCheltuialaId;
        data["randParentIdFromUI"] = this.randParentIdFromUI;
        data["availableBVC"] = this.availableBVC;
        data["availableCashFlow"] = this.availableCashFlow;
        data["delete"] = this.delete;
        data["tenantId"] = this.tenantId;
        data["balIsTotal"] = this.balIsTotal;
        data["balFormulaBVC"] = this.balFormulaBVC;
        data["balFormulaCashFlow"] = this.balFormulaCashFlow;
        if (Array.isArray(this.detaliiRand)) {
            data["detaliiRand"] = [];
            for (let item of this.detaliiRand)
                data["detaliiRand"].push(item.toJSON());
        }
        return data;
    }

    clone(): BugetFormRandDto {
        const json = this.toJSON();
        let result = new BugetFormRandDto();
        result.init(json);
        return result;
    }
}

export interface IBugetFormRandDto {
    id: number;
    formularId: number;
    codRand: number;
    descriere: string | undefined;
    tipRand: BVC_RowType;
    orderView: number;
    insert: boolean;
    categoryId: number;
    randParentId: number | undefined;
    nivelRand: number | undefined;
    isTotal: boolean;
    formulaBVC: string | undefined;
    formulaCashFlow: string | undefined;
    tipRandVenit: BVC_RowTypeIncome;
    tipRandSalarizare: BVC_RowTypeSalarizare;
    tipRandCheltuialaId: number | undefined;
    randParentIdFromUI: number | undefined;
    availableBVC: boolean;
    availableCashFlow: boolean;
    delete: boolean;
    tenantId: number;
    balIsTotal: boolean;
    balFormulaBVC: string | undefined;
    balFormulaCashFlow: string | undefined;
    detaliiRand: BugetFormRandDetailDto[] | undefined;
}

export class BugetCheltuieliDto implements IBugetCheltuieliDto {
    id: number;
    dataIncasare: moment.Moment;
    value: number;
    bvC_FormRand_Descriere: string | undefined;
    currency: string | undefined;
    activityTypeName: string | undefined;
    departamentName: string | undefined;
    descriere: string | undefined;

    constructor(data?: IBugetCheltuieliDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataIncasare = _data["dataIncasare"] ? moment(_data["dataIncasare"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.bvC_FormRand_Descriere = _data["bvC_FormRand_Descriere"];
            this.currency = _data["currency"];
            this.activityTypeName = _data["activityTypeName"];
            this.departamentName = _data["departamentName"];
            this.descriere = _data["descriere"];
        }
    }

    static fromJS(data: any): BugetCheltuieliDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetCheltuieliDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataIncasare"] = this.dataIncasare ? this.dataIncasare.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["bvC_FormRand_Descriere"] = this.bvC_FormRand_Descriere;
        data["currency"] = this.currency;
        data["activityTypeName"] = this.activityTypeName;
        data["departamentName"] = this.departamentName;
        data["descriere"] = this.descriere;
        return data;
    }

    clone(): BugetCheltuieliDto {
        const json = this.toJSON();
        let result = new BugetCheltuieliDto();
        result.init(json);
        return result;
    }
}

export interface IBugetCheltuieliDto {
    id: number;
    dataIncasare: moment.Moment;
    value: number;
    bvC_FormRand_Descriere: string | undefined;
    currency: string | undefined;
    activityTypeName: string | undefined;
    departamentName: string | undefined;
    descriere: string | undefined;
}

export class BugetConfigDto implements IBugetConfigDto {
    id: number;
    anBVC: number;

    constructor(data?: IBugetConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.anBVC = _data["anBVC"];
        }
    }

    static fromJS(data: any): BugetConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["anBVC"] = this.anBVC;
        return data;
    }

    clone(): BugetConfigDto {
        const json = this.toJSON();
        let result = new BugetConfigDto();
        result.init(json);
        return result;
    }
}

export interface IBugetConfigDto {
    id: number;
    anBVC: number;
}

export class BugetConfigEditDto implements IBugetConfigEditDto {
    id: number;
    anBVC: number;
    tenantId: number;
    state: State;

    constructor(data?: IBugetConfigEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.anBVC = _data["anBVC"];
            this.tenantId = _data["tenantId"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): BugetConfigEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetConfigEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["anBVC"] = this.anBVC;
        data["tenantId"] = this.tenantId;
        data["state"] = this.state;
        return data;
    }

    clone(): BugetConfigEditDto {
        const json = this.toJSON();
        let result = new BugetConfigEditDto();
        result.init(json);
        return result;
    }
}

export interface IBugetConfigEditDto {
    id: number;
    anBVC: number;
    tenantId: number;
    state: State;
}

export class PaapCheltListDto implements IPaapCheltListDto {
    paapId: number;
    departament: string | undefined;
    descriere: string | undefined;
    valoare: number;
    tipCheltuiala: string | undefined;

    constructor(data?: IPaapCheltListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paapId = _data["paapId"];
            this.departament = _data["departament"];
            this.descriere = _data["descriere"];
            this.valoare = _data["valoare"];
            this.tipCheltuiala = _data["tipCheltuiala"];
        }
    }

    static fromJS(data: any): PaapCheltListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapCheltListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paapId"] = this.paapId;
        data["departament"] = this.departament;
        data["descriere"] = this.descriere;
        data["valoare"] = this.valoare;
        data["tipCheltuiala"] = this.tipCheltuiala;
        return data;
    }

    clone(): PaapCheltListDto {
        const json = this.toJSON();
        let result = new PaapCheltListDto();
        result.init(json);
        return result;
    }
}

export interface IPaapCheltListDto {
    paapId: number;
    departament: string | undefined;
    descriere: string | undefined;
    valoare: number;
    tipCheltuiala: string | undefined;
}

export class BugetForm implements IBugetForm {
    formularId: number;
    randList: BugetFormRandDto[] | undefined;
    paapCheltList: PaapCheltListDto[] | undefined;

    constructor(data?: IBugetForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formularId = _data["formularId"];
            if (Array.isArray(_data["randList"])) {
                this.randList = [] as any;
                for (let item of _data["randList"])
                    this.randList.push(BugetFormRandDto.fromJS(item));
            }
            if (Array.isArray(_data["paapCheltList"])) {
                this.paapCheltList = [] as any;
                for (let item of _data["paapCheltList"])
                    this.paapCheltList.push(PaapCheltListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BugetForm {
        data = typeof data === 'object' ? data : {};
        let result = new BugetForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formularId"] = this.formularId;
        if (Array.isArray(this.randList)) {
            data["randList"] = [];
            for (let item of this.randList)
                data["randList"].push(item.toJSON());
        }
        if (Array.isArray(this.paapCheltList)) {
            data["paapCheltList"] = [];
            for (let item of this.paapCheltList)
                data["paapCheltList"].push(item.toJSON());
        }
        return data;
    }

    clone(): BugetForm {
        const json = this.toJSON();
        let result = new BugetForm();
        result.init(json);
        return result;
    }
}

export interface IBugetForm {
    formularId: number;
    randList: BugetFormRandDto[] | undefined;
    paapCheltList: PaapCheltListDto[] | undefined;
}

export class BugetPrevListDto implements IBugetPrevListDto {
    id: number;
    anBuget: number;
    formularId: number;
    dataBuget: moment.Moment;
    descriere: string | undefined;
    status: string | undefined;
    bvC_Tip: string | undefined;
    bvC_TipId: number;
    isValidated: boolean;

    constructor(data?: IBugetPrevListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.anBuget = _data["anBuget"];
            this.formularId = _data["formularId"];
            this.dataBuget = _data["dataBuget"] ? moment(_data["dataBuget"].toString()) : <any>undefined;
            this.descriere = _data["descriere"];
            this.status = _data["status"];
            this.bvC_Tip = _data["bvC_Tip"];
            this.bvC_TipId = _data["bvC_TipId"];
            this.isValidated = _data["isValidated"];
        }
    }

    static fromJS(data: any): BugetPrevListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["anBuget"] = this.anBuget;
        data["formularId"] = this.formularId;
        data["dataBuget"] = this.dataBuget ? this.dataBuget.toISOString() : <any>undefined;
        data["descriere"] = this.descriere;
        data["status"] = this.status;
        data["bvC_Tip"] = this.bvC_Tip;
        data["bvC_TipId"] = this.bvC_TipId;
        data["isValidated"] = this.isValidated;
        return data;
    }

    clone(): BugetPrevListDto {
        const json = this.toJSON();
        let result = new BugetPrevListDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevListDto {
    id: number;
    anBuget: number;
    formularId: number;
    dataBuget: moment.Moment;
    descriere: string | undefined;
    status: string | undefined;
    bvC_Tip: string | undefined;
    bvC_TipId: number;
    isValidated: boolean;
}

export class BugetPrevGenerateDto implements IBugetPrevGenerateDto {
    id: number;
    formularId: number | undefined;
    dataBuget: moment.Moment;
    descriere: string | undefined;
    bvC_Tip: number | undefined;
    monthStart: number;
    monthEnd: number;
    status: number;
    state: State;
    tenantId: number;

    constructor(data?: IBugetPrevGenerateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formularId = _data["formularId"];
            this.dataBuget = _data["dataBuget"] ? moment(_data["dataBuget"].toString()) : <any>undefined;
            this.descriere = _data["descriere"];
            this.bvC_Tip = _data["bvC_Tip"];
            this.monthStart = _data["monthStart"];
            this.monthEnd = _data["monthEnd"];
            this.status = _data["status"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BugetPrevGenerateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevGenerateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formularId"] = this.formularId;
        data["dataBuget"] = this.dataBuget ? this.dataBuget.toISOString() : <any>undefined;
        data["descriere"] = this.descriere;
        data["bvC_Tip"] = this.bvC_Tip;
        data["monthStart"] = this.monthStart;
        data["monthEnd"] = this.monthEnd;
        data["status"] = this.status;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BugetPrevGenerateDto {
        const json = this.toJSON();
        let result = new BugetPrevGenerateDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevGenerateDto {
    id: number;
    formularId: number | undefined;
    dataBuget: moment.Moment;
    descriere: string | undefined;
    bvC_Tip: number | undefined;
    monthStart: number;
    monthEnd: number;
    status: number;
    state: State;
    tenantId: number;
}

export class BugetPrevDetailRandValueDto implements IBugetPrevDetailRandValueDto {
    id: number;
    bugetPrevRandId: number;
    descriere: string | undefined;
    valoare: number;
    activityTypeName: string | undefined;
    activityTypeId: number | undefined;
    dataOper: moment.Moment;
    dataLuna: moment.Moment;
    valueType: number;

    constructor(data?: IBugetPrevDetailRandValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bugetPrevRandId = _data["bugetPrevRandId"];
            this.descriere = _data["descriere"];
            this.valoare = _data["valoare"];
            this.activityTypeName = _data["activityTypeName"];
            this.activityTypeId = _data["activityTypeId"];
            this.dataOper = _data["dataOper"] ? moment(_data["dataOper"].toString()) : <any>undefined;
            this.dataLuna = _data["dataLuna"] ? moment(_data["dataLuna"].toString()) : <any>undefined;
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): BugetPrevDetailRandValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevDetailRandValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bugetPrevRandId"] = this.bugetPrevRandId;
        data["descriere"] = this.descriere;
        data["valoare"] = this.valoare;
        data["activityTypeName"] = this.activityTypeName;
        data["activityTypeId"] = this.activityTypeId;
        data["dataOper"] = this.dataOper ? this.dataOper.toISOString() : <any>undefined;
        data["dataLuna"] = this.dataLuna ? this.dataLuna.toISOString() : <any>undefined;
        data["valueType"] = this.valueType;
        return data;
    }

    clone(): BugetPrevDetailRandValueDto {
        const json = this.toJSON();
        let result = new BugetPrevDetailRandValueDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevDetailRandValueDto {
    id: number;
    bugetPrevRandId: number;
    descriere: string | undefined;
    valoare: number;
    activityTypeName: string | undefined;
    activityTypeId: number | undefined;
    dataOper: moment.Moment;
    dataLuna: moment.Moment;
    valueType: number;
}

export class BugetPrevDetailDto implements IBugetPrevDetailDto {
    id: number;
    descriere: string | undefined;
    orderView: number;
    valoare: number;
    validat: boolean;
    isTotal: boolean;
    randValueDetails: BugetPrevDetailRandValueDto[] | undefined;

    constructor(data?: IBugetPrevDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descriere = _data["descriere"];
            this.orderView = _data["orderView"];
            this.valoare = _data["valoare"];
            this.validat = _data["validat"];
            this.isTotal = _data["isTotal"];
            if (Array.isArray(_data["randValueDetails"])) {
                this.randValueDetails = [] as any;
                for (let item of _data["randValueDetails"])
                    this.randValueDetails.push(BugetPrevDetailRandValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BugetPrevDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descriere"] = this.descriere;
        data["orderView"] = this.orderView;
        data["valoare"] = this.valoare;
        data["validat"] = this.validat;
        data["isTotal"] = this.isTotal;
        if (Array.isArray(this.randValueDetails)) {
            data["randValueDetails"] = [];
            for (let item of this.randValueDetails)
                data["randValueDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): BugetPrevDetailDto {
        const json = this.toJSON();
        let result = new BugetPrevDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevDetailDto {
    id: number;
    descriere: string | undefined;
    orderView: number;
    valoare: number;
    validat: boolean;
    isTotal: boolean;
    randValueDetails: BugetPrevDetailRandValueDto[] | undefined;
}

export class BugetPrevByDepartmentDto implements IBugetPrevByDepartmentDto {
    departamentName: string | undefined;
    departamentId: number;
    details: BugetPrevDetailDto[] | undefined;

    constructor(data?: IBugetPrevByDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departamentName = _data["departamentName"];
            this.departamentId = _data["departamentId"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(BugetPrevDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BugetPrevByDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevByDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departamentName"] = this.departamentName;
        data["departamentId"] = this.departamentId;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): BugetPrevByDepartmentDto {
        const json = this.toJSON();
        let result = new BugetPrevByDepartmentDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevByDepartmentDto {
    departamentName: string | undefined;
    departamentId: number;
    details: BugetPrevDetailDto[] | undefined;
}

export class BugetPrevAllDepartmentsDto implements IBugetPrevAllDepartmentsDto {
    formRandId: number;
    descriere: string | undefined;
    orderView: number;
    valoare: number;
    validat: boolean;

    constructor(data?: IBugetPrevAllDepartmentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formRandId = _data["formRandId"];
            this.descriere = _data["descriere"];
            this.orderView = _data["orderView"];
            this.valoare = _data["valoare"];
            this.validat = _data["validat"];
        }
    }

    static fromJS(data: any): BugetPrevAllDepartmentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevAllDepartmentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formRandId"] = this.formRandId;
        data["descriere"] = this.descriere;
        data["orderView"] = this.orderView;
        data["valoare"] = this.valoare;
        data["validat"] = this.validat;
        return data;
    }

    clone(): BugetPrevAllDepartmentsDto {
        const json = this.toJSON();
        let result = new BugetPrevAllDepartmentsDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevAllDepartmentsDto {
    formRandId: number;
    descriere: string | undefined;
    orderView: number;
    valoare: number;
    validat: boolean;
}

export class BugetPrevMonthsDto implements IBugetPrevMonthsDto {
    month: string | undefined;
    monthDisplay: string | undefined;

    constructor(data?: IBugetPrevMonthsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.monthDisplay = _data["monthDisplay"];
        }
    }

    static fromJS(data: any): BugetPrevMonthsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevMonthsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["monthDisplay"] = this.monthDisplay;
        return data;
    }

    clone(): BugetPrevMonthsDto {
        const json = this.toJSON();
        let result = new BugetPrevMonthsDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevMonthsDto {
    month: string | undefined;
    monthDisplay: string | undefined;
}

export class BugetPrevItemDto implements IBugetPrevItemDto {
    bugetPrevByDepartmentList: BugetPrevByDepartmentDto;
    bugetPrevAllDepartmentsList: BugetPrevAllDepartmentsDto[] | undefined;
    bugetPrevMonthsDtoList: BugetPrevMonthsDto[] | undefined;
    isValidated: boolean;
    status: string | undefined;

    constructor(data?: IBugetPrevItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bugetPrevByDepartmentList = _data["bugetPrevByDepartmentList"] ? BugetPrevByDepartmentDto.fromJS(_data["bugetPrevByDepartmentList"]) : <any>undefined;
            if (Array.isArray(_data["bugetPrevAllDepartmentsList"])) {
                this.bugetPrevAllDepartmentsList = [] as any;
                for (let item of _data["bugetPrevAllDepartmentsList"])
                    this.bugetPrevAllDepartmentsList.push(BugetPrevAllDepartmentsDto.fromJS(item));
            }
            if (Array.isArray(_data["bugetPrevMonthsDtoList"])) {
                this.bugetPrevMonthsDtoList = [] as any;
                for (let item of _data["bugetPrevMonthsDtoList"])
                    this.bugetPrevMonthsDtoList.push(BugetPrevMonthsDto.fromJS(item));
            }
            this.isValidated = _data["isValidated"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): BugetPrevItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bugetPrevByDepartmentList"] = this.bugetPrevByDepartmentList ? this.bugetPrevByDepartmentList.toJSON() : <any>undefined;
        if (Array.isArray(this.bugetPrevAllDepartmentsList)) {
            data["bugetPrevAllDepartmentsList"] = [];
            for (let item of this.bugetPrevAllDepartmentsList)
                data["bugetPrevAllDepartmentsList"].push(item.toJSON());
        }
        if (Array.isArray(this.bugetPrevMonthsDtoList)) {
            data["bugetPrevMonthsDtoList"] = [];
            for (let item of this.bugetPrevMonthsDtoList)
                data["bugetPrevMonthsDtoList"].push(item.toJSON());
        }
        data["isValidated"] = this.isValidated;
        data["status"] = this.status;
        return data;
    }

    clone(): BugetPrevItemDto {
        const json = this.toJSON();
        let result = new BugetPrevItemDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevItemDto {
    bugetPrevByDepartmentList: BugetPrevByDepartmentDto;
    bugetPrevAllDepartmentsList: BugetPrevAllDepartmentsDto[] | undefined;
    bugetPrevMonthsDtoList: BugetPrevMonthsDto[] | undefined;
    isValidated: boolean;
    status: string | undefined;
}

export class BugetPrevStatusDto implements IBugetPrevStatusDto {
    id: number;
    bugetPrevId: number;
    statusDate: moment.Moment;
    status: number;
    tenantId: number;

    constructor(data?: IBugetPrevStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bugetPrevId = _data["bugetPrevId"];
            this.statusDate = _data["statusDate"] ? moment(_data["statusDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BugetPrevStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bugetPrevId"] = this.bugetPrevId;
        data["statusDate"] = this.statusDate ? this.statusDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BugetPrevStatusDto {
        const json = this.toJSON();
        let result = new BugetPrevStatusDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevStatusDto {
    id: number;
    bugetPrevId: number;
    statusDate: moment.Moment;
    status: number;
    tenantId: number;
}

export class BugetPrevDDDto implements IBugetPrevDDDto {
    id: number;
    descriere: string | undefined;

    constructor(data?: IBugetPrevDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descriere = _data["descriere"];
        }
    }

    static fromJS(data: any): BugetPrevDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descriere"] = this.descriere;
        return data;
    }

    clone(): BugetPrevDDDto {
        const json = this.toJSON();
        let result = new BugetPrevDDDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevDDDto {
    id: number;
    descriere: string | undefined;
}

export enum BVC_BugetPrevElemCalc {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export class BugetPrevStatCalculDto implements IBugetPrevStatCalculDto {
    id: number;
    bugetPrevId: number;
    elemCalc: BVC_BugetPrevElemCalc;
    elemCalcStr: string | undefined;
    statusCalc: boolean;
    message: string | undefined;

    constructor(data?: IBugetPrevStatCalculDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bugetPrevId = _data["bugetPrevId"];
            this.elemCalc = _data["elemCalc"];
            this.elemCalcStr = _data["elemCalcStr"];
            this.statusCalc = _data["statusCalc"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): BugetPrevStatCalculDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevStatCalculDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bugetPrevId"] = this.bugetPrevId;
        data["elemCalc"] = this.elemCalc;
        data["elemCalcStr"] = this.elemCalcStr;
        data["statusCalc"] = this.statusCalc;
        data["message"] = this.message;
        return data;
    }

    clone(): BugetPrevStatCalculDto {
        const json = this.toJSON();
        let result = new BugetPrevStatCalculDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevStatCalculDto {
    id: number;
    bugetPrevId: number;
    elemCalc: BVC_BugetPrevElemCalc;
    elemCalcStr: string | undefined;
    statusCalc: boolean;
    message: string | undefined;
}

export class BugetPrevAutoValueListDto implements IBugetPrevAutoValueListDto {
    id: number;
    departamentName: string | undefined;
    tipRandName: string | undefined;
    tipRandVenitName: string | undefined;
    tenantId: number;

    constructor(data?: IBugetPrevAutoValueListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.departamentName = _data["departamentName"];
            this.tipRandName = _data["tipRandName"];
            this.tipRandVenitName = _data["tipRandVenitName"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BugetPrevAutoValueListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevAutoValueListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["departamentName"] = this.departamentName;
        data["tipRandName"] = this.tipRandName;
        data["tipRandVenitName"] = this.tipRandVenitName;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BugetPrevAutoValueListDto {
        const json = this.toJSON();
        let result = new BugetPrevAutoValueListDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevAutoValueListDto {
    id: number;
    departamentName: string | undefined;
    tipRandName: string | undefined;
    tipRandVenitName: string | undefined;
    tenantId: number;
}

export class BugetPrevAutoValueAddDto implements IBugetPrevAutoValueAddDto {
    id: number;
    departamentId: number | undefined;
    tipRandId: number | undefined;
    tipRandVenitId: number | undefined;
    tenantId: number;

    constructor(data?: IBugetPrevAutoValueAddDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.departamentId = _data["departamentId"];
            this.tipRandId = _data["tipRandId"];
            this.tipRandVenitId = _data["tipRandVenitId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BugetPrevAutoValueAddDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevAutoValueAddDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["departamentId"] = this.departamentId;
        data["tipRandId"] = this.tipRandId;
        data["tipRandVenitId"] = this.tipRandVenitId;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BugetPrevAutoValueAddDto {
        const json = this.toJSON();
        let result = new BugetPrevAutoValueAddDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevAutoValueAddDto {
    id: number;
    departamentId: number | undefined;
    tipRandId: number | undefined;
    tipRandVenitId: number | undefined;
    tenantId: number;
}

export enum BVC_BugetPrevContributieTipIncasare {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class BugetPrevContribAddDto implements IBugetPrevContribAddDto {
    id: number;
    dataIncasare: moment.Moment;
    tipIncasare: BVC_BugetPrevContributieTipIncasare;
    bankId: number | undefined;
    value: number;
    currencyId: number | undefined;
    activityTypeId: number | undefined;
    descriere: string | undefined;
    tenantId: number;

    constructor(data?: IBugetPrevContribAddDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataIncasare = _data["dataIncasare"] ? moment(_data["dataIncasare"].toString()) : <any>undefined;
            this.tipIncasare = _data["tipIncasare"];
            this.bankId = _data["bankId"];
            this.value = _data["value"];
            this.currencyId = _data["currencyId"];
            this.activityTypeId = _data["activityTypeId"];
            this.descriere = _data["descriere"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BugetPrevContribAddDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevContribAddDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataIncasare"] = this.dataIncasare ? this.dataIncasare.toISOString() : <any>undefined;
        data["tipIncasare"] = this.tipIncasare;
        data["bankId"] = this.bankId;
        data["value"] = this.value;
        data["currencyId"] = this.currencyId;
        data["activityTypeId"] = this.activityTypeId;
        data["descriere"] = this.descriere;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BugetPrevContribAddDto {
        const json = this.toJSON();
        let result = new BugetPrevContribAddDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevContribAddDto {
    id: number;
    dataIncasare: moment.Moment;
    tipIncasare: BVC_BugetPrevContributieTipIncasare;
    bankId: number | undefined;
    value: number;
    currencyId: number | undefined;
    activityTypeId: number | undefined;
    descriere: string | undefined;
    tenantId: number;
}

export class BugetPrevContribListDto implements IBugetPrevContribListDto {
    id: number;
    dataIncasare: moment.Moment;
    tipIncasare: string | undefined;
    bankName: string | undefined;
    value: number;
    currencyName: string | undefined;
    activityTypeName: string | undefined;
    descriere: string | undefined;
    tenantId: number;

    constructor(data?: IBugetPrevContribListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataIncasare = _data["dataIncasare"] ? moment(_data["dataIncasare"].toString()) : <any>undefined;
            this.tipIncasare = _data["tipIncasare"];
            this.bankName = _data["bankName"];
            this.value = _data["value"];
            this.currencyName = _data["currencyName"];
            this.activityTypeName = _data["activityTypeName"];
            this.descriere = _data["descriere"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BugetPrevContribListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevContribListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataIncasare"] = this.dataIncasare ? this.dataIncasare.toISOString() : <any>undefined;
        data["tipIncasare"] = this.tipIncasare;
        data["bankName"] = this.bankName;
        data["value"] = this.value;
        data["currencyName"] = this.currencyName;
        data["activityTypeName"] = this.activityTypeName;
        data["descriere"] = this.descriere;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BugetPrevContribListDto {
        const json = this.toJSON();
        let result = new BugetPrevContribListDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevContribListDto {
    id: number;
    dataIncasare: moment.Moment;
    tipIncasare: string | undefined;
    bankName: string | undefined;
    value: number;
    currencyName: string | undefined;
    activityTypeName: string | undefined;
    descriere: string | undefined;
    tenantId: number;
}

export class BugetPrevDobandaReferintaEditDto implements IBugetPrevDobandaReferintaEditDto {
    id: number;
    formularId: number;
    plasamentType: number | undefined;
    procent: number;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    tenantId: number;
    state: State;
    currencyId: number | undefined;
    activityTypeId: number | undefined;

    constructor(data?: IBugetPrevDobandaReferintaEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formularId = _data["formularId"];
            this.plasamentType = _data["plasamentType"];
            this.procent = _data["procent"];
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.state = _data["state"];
            this.currencyId = _data["currencyId"];
            this.activityTypeId = _data["activityTypeId"];
        }
    }

    static fromJS(data: any): BugetPrevDobandaReferintaEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevDobandaReferintaEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formularId"] = this.formularId;
        data["plasamentType"] = this.plasamentType;
        data["procent"] = this.procent;
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["state"] = this.state;
        data["currencyId"] = this.currencyId;
        data["activityTypeId"] = this.activityTypeId;
        return data;
    }

    clone(): BugetPrevDobandaReferintaEditDto {
        const json = this.toJSON();
        let result = new BugetPrevDobandaReferintaEditDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevDobandaReferintaEditDto {
    id: number;
    formularId: number;
    plasamentType: number | undefined;
    procent: number;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    tenantId: number;
    state: State;
    currencyId: number | undefined;
    activityTypeId: number | undefined;
}

export class BugetPrevDobandaReferintaListDto implements IBugetPrevDobandaReferintaListDto {
    id: number;
    formularId: number;
    an: number;
    plasamentName: string | undefined;
    procent: number;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    tenantId: number;
    state: State;
    currencyName: string | undefined;
    activityTypeName: string | undefined;

    constructor(data?: IBugetPrevDobandaReferintaListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formularId = _data["formularId"];
            this.an = _data["an"];
            this.plasamentName = _data["plasamentName"];
            this.procent = _data["procent"];
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.state = _data["state"];
            this.currencyName = _data["currencyName"];
            this.activityTypeName = _data["activityTypeName"];
        }
    }

    static fromJS(data: any): BugetPrevDobandaReferintaListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevDobandaReferintaListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formularId"] = this.formularId;
        data["an"] = this.an;
        data["plasamentName"] = this.plasamentName;
        data["procent"] = this.procent;
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["state"] = this.state;
        data["currencyName"] = this.currencyName;
        data["activityTypeName"] = this.activityTypeName;
        return data;
    }

    clone(): BugetPrevDobandaReferintaListDto {
        const json = this.toJSON();
        let result = new BugetPrevDobandaReferintaListDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevDobandaReferintaListDto {
    id: number;
    formularId: number;
    an: number;
    plasamentName: string | undefined;
    procent: number;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    tenantId: number;
    state: State;
    currencyName: string | undefined;
    activityTypeName: string | undefined;
}

export class BugetRealizatDto implements IBugetRealizatDto {
    id: number;
    bvC_BalRealizatId: number | undefined;
    savedBalanceDate: moment.Moment;
    savedBalanceDescription: string | undefined;
    bvC_Tip: number;
    bvC_TipStr: string | undefined;

    constructor(data?: IBugetRealizatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bvC_BalRealizatId = _data["bvC_BalRealizatId"];
            this.savedBalanceDate = _data["savedBalanceDate"] ? moment(_data["savedBalanceDate"].toString()) : <any>undefined;
            this.savedBalanceDescription = _data["savedBalanceDescription"];
            this.bvC_Tip = _data["bvC_Tip"];
            this.bvC_TipStr = _data["bvC_TipStr"];
        }
    }

    static fromJS(data: any): BugetRealizatDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetRealizatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bvC_BalRealizatId"] = this.bvC_BalRealizatId;
        data["savedBalanceDate"] = this.savedBalanceDate ? this.savedBalanceDate.toISOString() : <any>undefined;
        data["savedBalanceDescription"] = this.savedBalanceDescription;
        data["bvC_Tip"] = this.bvC_Tip;
        data["bvC_TipStr"] = this.bvC_TipStr;
        return data;
    }

    clone(): BugetRealizatDto {
        const json = this.toJSON();
        let result = new BugetRealizatDto();
        result.init(json);
        return result;
    }
}

export interface IBugetRealizatDto {
    id: number;
    bvC_BalRealizatId: number | undefined;
    savedBalanceDate: moment.Moment;
    savedBalanceDescription: string | undefined;
    bvC_Tip: number;
    bvC_TipStr: string | undefined;
}

export class RealizatAddDispoDto implements IRealizatAddDispoDto {
    id: number;
    descriere: string | undefined;

    constructor(data?: IRealizatAddDispoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descriere = _data["descriere"];
        }
    }

    static fromJS(data: any): RealizatAddDispoDto {
        data = typeof data === 'object' ? data : {};
        let result = new RealizatAddDispoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descriere"] = this.descriere;
        return data;
    }

    clone(): RealizatAddDispoDto {
        const json = this.toJSON();
        let result = new RealizatAddDispoDto();
        result.init(json);
        return result;
    }
}

export interface IRealizatAddDispoDto {
    id: number;
    descriere: string | undefined;
}

export class BugetRealizatRowDto implements IBugetRealizatRowDto {
    id: number;
    denumireRand: string | undefined;
    bold: boolean;
    valoareCuReferat: number;
    valoareFaraReferat: number;

    constructor(data?: IBugetRealizatRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.denumireRand = _data["denumireRand"];
            this.bold = _data["bold"];
            this.valoareCuReferat = _data["valoareCuReferat"];
            this.valoareFaraReferat = _data["valoareFaraReferat"];
        }
    }

    static fromJS(data: any): BugetRealizatRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetRealizatRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["denumireRand"] = this.denumireRand;
        data["bold"] = this.bold;
        data["valoareCuReferat"] = this.valoareCuReferat;
        data["valoareFaraReferat"] = this.valoareFaraReferat;
        return data;
    }

    clone(): BugetRealizatRowDto {
        const json = this.toJSON();
        let result = new BugetRealizatRowDto();
        result.init(json);
        return result;
    }
}

export interface IBugetRealizatRowDto {
    id: number;
    denumireRand: string | undefined;
    bold: boolean;
    valoareCuReferat: number;
    valoareFaraReferat: number;
}

export class BugetRealizatRowDetailDto implements IBugetRealizatRowDetailDto {
    descriere: string | undefined;
    valoare: number;
    currencyName: string | undefined;

    constructor(data?: IBugetRealizatRowDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.descriere = _data["descriere"];
            this.valoare = _data["valoare"];
            this.currencyName = _data["currencyName"];
        }
    }

    static fromJS(data: any): BugetRealizatRowDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetRealizatRowDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["descriere"] = this.descriere;
        data["valoare"] = this.valoare;
        data["currencyName"] = this.currencyName;
        return data;
    }

    clone(): BugetRealizatRowDetailDto {
        const json = this.toJSON();
        let result = new BugetRealizatRowDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBugetRealizatRowDetailDto {
    descriere: string | undefined;
    valoare: number;
    currencyName: string | undefined;
}

export class BugetBalRealizatRowDto implements IBugetBalRealizatRowDto {
    id: number;
    denumireRand: string | undefined;
    bold: boolean;
    valoare: number;
    activityTypeName: string | undefined;
    activityTypeId: number;

    constructor(data?: IBugetBalRealizatRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.denumireRand = _data["denumireRand"];
            this.bold = _data["bold"];
            this.valoare = _data["valoare"];
            this.activityTypeName = _data["activityTypeName"];
            this.activityTypeId = _data["activityTypeId"];
        }
    }

    static fromJS(data: any): BugetBalRealizatRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetBalRealizatRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["denumireRand"] = this.denumireRand;
        data["bold"] = this.bold;
        data["valoare"] = this.valoare;
        data["activityTypeName"] = this.activityTypeName;
        data["activityTypeId"] = this.activityTypeId;
        return data;
    }

    clone(): BugetBalRealizatRowDto {
        const json = this.toJSON();
        let result = new BugetBalRealizatRowDto();
        result.init(json);
        return result;
    }
}

export interface IBugetBalRealizatRowDto {
    id: number;
    denumireRand: string | undefined;
    bold: boolean;
    valoare: number;
    activityTypeName: string | undefined;
    activityTypeId: number;
}

export class BugetBalRealizatRowDetailDto implements IBugetBalRealizatRowDetailDto {
    descriere: string | undefined;
    valoare: number;
    currencyName: string | undefined;

    constructor(data?: IBugetBalRealizatRowDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.descriere = _data["descriere"];
            this.valoare = _data["valoare"];
            this.currencyName = _data["currencyName"];
        }
    }

    static fromJS(data: any): BugetBalRealizatRowDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetBalRealizatRowDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["descriere"] = this.descriere;
        data["valoare"] = this.valoare;
        data["currencyName"] = this.currencyName;
        return data;
    }

    clone(): BugetBalRealizatRowDetailDto {
        const json = this.toJSON();
        let result = new BugetBalRealizatRowDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBugetBalRealizatRowDetailDto {
    descriere: string | undefined;
    valoare: number;
    currencyName: string | undefined;
}

export class BugetBalRealizatSavedBalanceDateDto implements IBugetBalRealizatSavedBalanceDateDto {
    id: number;
    descriere: string | undefined;

    constructor(data?: IBugetBalRealizatSavedBalanceDateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descriere = _data["descriere"];
        }
    }

    static fromJS(data: any): BugetBalRealizatSavedBalanceDateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetBalRealizatSavedBalanceDateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descriere"] = this.descriere;
        return data;
    }

    clone(): BugetBalRealizatSavedBalanceDateDto {
        const json = this.toJSON();
        let result = new BugetBalRealizatSavedBalanceDateDto();
        result.init(json);
        return result;
    }
}

export interface IBugetBalRealizatSavedBalanceDateDto {
    id: number;
    descriere: string | undefined;
}

export class BugetRealizatSavedBalanceDateDto implements IBugetRealizatSavedBalanceDateDto {
    id: number;
    balRealizatId: number | undefined;
    descriere: string | undefined;

    constructor(data?: IBugetRealizatSavedBalanceDateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.balRealizatId = _data["balRealizatId"];
            this.descriere = _data["descriere"];
        }
    }

    static fromJS(data: any): BugetRealizatSavedBalanceDateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetRealizatSavedBalanceDateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["balRealizatId"] = this.balRealizatId;
        data["descriere"] = this.descriere;
        return data;
    }

    clone(): BugetRealizatSavedBalanceDateDto {
        const json = this.toJSON();
        let result = new BugetRealizatSavedBalanceDateDto();
        result.init(json);
        return result;
    }
}

export interface IBugetRealizatSavedBalanceDateDto {
    id: number;
    balRealizatId: number | undefined;
    descriere: string | undefined;
}

export class BugetPreliminatListDto implements IBugetPreliminatListDto {
    id: number;
    anBVC: number;
    formularId: number;
    preliminatCalculType: number;
    preliminatCalculTypeStr: string | undefined;
    dataUltBalanta: moment.Moment | undefined;
    bvC_BugetPrevStr: string | undefined;

    constructor(data?: IBugetPreliminatListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.anBVC = _data["anBVC"];
            this.formularId = _data["formularId"];
            this.preliminatCalculType = _data["preliminatCalculType"];
            this.preliminatCalculTypeStr = _data["preliminatCalculTypeStr"];
            this.dataUltBalanta = _data["dataUltBalanta"] ? moment(_data["dataUltBalanta"].toString()) : <any>undefined;
            this.bvC_BugetPrevStr = _data["bvC_BugetPrevStr"];
        }
    }

    static fromJS(data: any): BugetPreliminatListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPreliminatListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["anBVC"] = this.anBVC;
        data["formularId"] = this.formularId;
        data["preliminatCalculType"] = this.preliminatCalculType;
        data["preliminatCalculTypeStr"] = this.preliminatCalculTypeStr;
        data["dataUltBalanta"] = this.dataUltBalanta ? this.dataUltBalanta.toISOString() : <any>undefined;
        data["bvC_BugetPrevStr"] = this.bvC_BugetPrevStr;
        return data;
    }

    clone(): BugetPreliminatListDto {
        const json = this.toJSON();
        let result = new BugetPreliminatListDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPreliminatListDto {
    id: number;
    anBVC: number;
    formularId: number;
    preliminatCalculType: number;
    preliminatCalculTypeStr: string | undefined;
    dataUltBalanta: moment.Moment | undefined;
    bvC_BugetPrevStr: string | undefined;
}

export class BugetFormularListDto implements IBugetFormularListDto {
    id: number;
    anBVC: number;

    constructor(data?: IBugetFormularListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.anBVC = _data["anBVC"];
        }
    }

    static fromJS(data: any): BugetFormularListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetFormularListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["anBVC"] = this.anBVC;
        return data;
    }

    clone(): BugetFormularListDto {
        const json = this.toJSON();
        let result = new BugetFormularListDto();
        result.init(json);
        return result;
    }
}

export interface IBugetFormularListDto {
    id: number;
    anBVC: number;
}

export class BugetRepartizatDto implements IBugetRepartizatDto {
    id: number;
    formularId: number;
    activityTypeId: number;
    activityName: string | undefined;
    procRepartiz: number;
    venitRepartiz: number;
    venitRepartizBVC: number;

    constructor(data?: IBugetRepartizatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formularId = _data["formularId"];
            this.activityTypeId = _data["activityTypeId"];
            this.activityName = _data["activityName"];
            this.procRepartiz = _data["procRepartiz"];
            this.venitRepartiz = _data["venitRepartiz"];
            this.venitRepartizBVC = _data["venitRepartizBVC"];
        }
    }

    static fromJS(data: any): BugetRepartizatDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetRepartizatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formularId"] = this.formularId;
        data["activityTypeId"] = this.activityTypeId;
        data["activityName"] = this.activityName;
        data["procRepartiz"] = this.procRepartiz;
        data["venitRepartiz"] = this.venitRepartiz;
        data["venitRepartizBVC"] = this.venitRepartizBVC;
        return data;
    }

    clone(): BugetRepartizatDto {
        const json = this.toJSON();
        let result = new BugetRepartizatDto();
        result.init(json);
        return result;
    }
}

export interface IBugetRepartizatDto {
    id: number;
    formularId: number;
    activityTypeId: number;
    activityName: string | undefined;
    procRepartiz: number;
    venitRepartiz: number;
    venitRepartizBVC: number;
}

export class BugetTitluriDDDto implements IBugetTitluriDDDto {
    formularBVCId: number;
    anBVC: number;

    constructor(data?: IBugetTitluriDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formularBVCId = _data["formularBVCId"];
            this.anBVC = _data["anBVC"];
        }
    }

    static fromJS(data: any): BugetTitluriDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetTitluriDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formularBVCId"] = this.formularBVCId;
        data["anBVC"] = this.anBVC;
        return data;
    }

    clone(): BugetTitluriDDDto {
        const json = this.toJSON();
        let result = new BugetTitluriDDDto();
        result.init(json);
        return result;
    }
}

export interface IBugetTitluriDDDto {
    formularBVCId: number;
    anBVC: number;
}

export enum BVC_PlasamentType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum VenitType {
    _0 = 0,
    _1 = 1,
}

export class BugetTitluriViewDto implements IBugetTitluriViewDto {
    id: number;
    idPlasament: string | undefined;
    tipPlasament: BVC_PlasamentType;
    tipPlasamentStr: string | undefined;
    venitType: VenitType;
    venitTypeStr: string | undefined;
    activityTypeId: number;
    activityType: string | undefined;
    currencyId: number;
    currency: string | undefined;
    valoarePlasament: number;
    startDate: moment.Moment;
    maturityDate: moment.Moment;
    procentDobanda: number;
    selectat: boolean;
    reinvestit: boolean;

    constructor(data?: IBugetTitluriViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idPlasament = _data["idPlasament"];
            this.tipPlasament = _data["tipPlasament"];
            this.tipPlasamentStr = _data["tipPlasamentStr"];
            this.venitType = _data["venitType"];
            this.venitTypeStr = _data["venitTypeStr"];
            this.activityTypeId = _data["activityTypeId"];
            this.activityType = _data["activityType"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"];
            this.valoarePlasament = _data["valoarePlasament"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.maturityDate = _data["maturityDate"] ? moment(_data["maturityDate"].toString()) : <any>undefined;
            this.procentDobanda = _data["procentDobanda"];
            this.selectat = _data["selectat"];
            this.reinvestit = _data["reinvestit"];
        }
    }

    static fromJS(data: any): BugetTitluriViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetTitluriViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idPlasament"] = this.idPlasament;
        data["tipPlasament"] = this.tipPlasament;
        data["tipPlasamentStr"] = this.tipPlasamentStr;
        data["venitType"] = this.venitType;
        data["venitTypeStr"] = this.venitTypeStr;
        data["activityTypeId"] = this.activityTypeId;
        data["activityType"] = this.activityType;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency;
        data["valoarePlasament"] = this.valoarePlasament;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["maturityDate"] = this.maturityDate ? this.maturityDate.toISOString() : <any>undefined;
        data["procentDobanda"] = this.procentDobanda;
        data["selectat"] = this.selectat;
        data["reinvestit"] = this.reinvestit;
        return data;
    }

    clone(): BugetTitluriViewDto {
        const json = this.toJSON();
        let result = new BugetTitluriViewDto();
        result.init(json);
        return result;
    }
}

export interface IBugetTitluriViewDto {
    id: number;
    idPlasament: string | undefined;
    tipPlasament: BVC_PlasamentType;
    tipPlasamentStr: string | undefined;
    venitType: VenitType;
    venitTypeStr: string | undefined;
    activityTypeId: number;
    activityType: string | undefined;
    currencyId: number;
    currency: string | undefined;
    valoarePlasament: number;
    startDate: moment.Moment;
    maturityDate: moment.Moment;
    procentDobanda: number;
    selectat: boolean;
    reinvestit: boolean;
}

export class BugetTitluriBVCViewList implements IBugetTitluriBVCViewList {
    id: number;
    dataDobanda: moment.Moment;
    valoarePlasament: number;
    dobandaLuna: number;
    dobandaCumulataPrec: number;

    constructor(data?: IBugetTitluriBVCViewList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataDobanda = _data["dataDobanda"] ? moment(_data["dataDobanda"].toString()) : <any>undefined;
            this.valoarePlasament = _data["valoarePlasament"];
            this.dobandaLuna = _data["dobandaLuna"];
            this.dobandaCumulataPrec = _data["dobandaCumulataPrec"];
        }
    }

    static fromJS(data: any): BugetTitluriBVCViewList {
        data = typeof data === 'object' ? data : {};
        let result = new BugetTitluriBVCViewList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataDobanda"] = this.dataDobanda ? this.dataDobanda.toISOString() : <any>undefined;
        data["valoarePlasament"] = this.valoarePlasament;
        data["dobandaLuna"] = this.dobandaLuna;
        data["dobandaCumulataPrec"] = this.dobandaCumulataPrec;
        return data;
    }

    clone(): BugetTitluriBVCViewList {
        const json = this.toJSON();
        let result = new BugetTitluriBVCViewList();
        result.init(json);
        return result;
    }
}

export interface IBugetTitluriBVCViewList {
    id: number;
    dataDobanda: moment.Moment;
    valoarePlasament: number;
    dobandaLuna: number;
    dobandaCumulataPrec: number;
}

export class BugetTitluriCFViewList implements IBugetTitluriCFViewList {
    id: number;
    dataIncasare: moment.Moment;
    valoarePlasament: number;
    dobandaTotala: number;
    dataReinvestire: moment.Moment;
    sumaReinvestita: number;

    constructor(data?: IBugetTitluriCFViewList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataIncasare = _data["dataIncasare"] ? moment(_data["dataIncasare"].toString()) : <any>undefined;
            this.valoarePlasament = _data["valoarePlasament"];
            this.dobandaTotala = _data["dobandaTotala"];
            this.dataReinvestire = _data["dataReinvestire"] ? moment(_data["dataReinvestire"].toString()) : <any>undefined;
            this.sumaReinvestita = _data["sumaReinvestita"];
        }
    }

    static fromJS(data: any): BugetTitluriCFViewList {
        data = typeof data === 'object' ? data : {};
        let result = new BugetTitluriCFViewList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataIncasare"] = this.dataIncasare ? this.dataIncasare.toISOString() : <any>undefined;
        data["valoarePlasament"] = this.valoarePlasament;
        data["dobandaTotala"] = this.dobandaTotala;
        data["dataReinvestire"] = this.dataReinvestire ? this.dataReinvestire.toISOString() : <any>undefined;
        data["sumaReinvestita"] = this.sumaReinvestita;
        return data;
    }

    clone(): BugetTitluriCFViewList {
        const json = this.toJSON();
        let result = new BugetTitluriCFViewList();
        result.init(json);
        return result;
    }
}

export interface IBugetTitluriCFViewList {
    id: number;
    dataIncasare: moment.Moment;
    valoarePlasament: number;
    dobandaTotala: number;
    dataReinvestire: moment.Moment;
    sumaReinvestita: number;
}

export class BugetReinvest implements IBugetReinvest {
    startDate: moment.Moment;
    endDate: moment.Moment;

    constructor(data?: IBugetReinvest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BugetReinvest {
        data = typeof data === 'object' ? data : {};
        let result = new BugetReinvest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): BugetReinvest {
        const json = this.toJSON();
        let result = new BugetReinvest();
        result.init(json);
        return result;
    }
}

export interface IBugetReinvest {
    startDate: moment.Moment;
    endDate: moment.Moment;
}

export class BVC_VenitTitluCFReinvDto implements IBVC_VenitTitluCFReinvDto {
    id: number;
    bvC_VenitTitluCFId: number;
    dataReinvestire: moment.Moment;
    sumaReinvestita: number;
    procDobanda: number;
    mainValue: boolean;
    sumaIncasata: number;
    currencyId: number;
    currencyName: string | undefined;
    cursValutar: number;
    delete: boolean;

    constructor(data?: IBVC_VenitTitluCFReinvDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bvC_VenitTitluCFId = _data["bvC_VenitTitluCFId"];
            this.dataReinvestire = _data["dataReinvestire"] ? moment(_data["dataReinvestire"].toString()) : <any>undefined;
            this.sumaReinvestita = _data["sumaReinvestita"];
            this.procDobanda = _data["procDobanda"];
            this.mainValue = _data["mainValue"];
            this.sumaIncasata = _data["sumaIncasata"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.cursValutar = _data["cursValutar"];
            this.delete = _data["delete"];
        }
    }

    static fromJS(data: any): BVC_VenitTitluCFReinvDto {
        data = typeof data === 'object' ? data : {};
        let result = new BVC_VenitTitluCFReinvDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bvC_VenitTitluCFId"] = this.bvC_VenitTitluCFId;
        data["dataReinvestire"] = this.dataReinvestire ? this.dataReinvestire.toISOString() : <any>undefined;
        data["sumaReinvestita"] = this.sumaReinvestita;
        data["procDobanda"] = this.procDobanda;
        data["mainValue"] = this.mainValue;
        data["sumaIncasata"] = this.sumaIncasata;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["cursValutar"] = this.cursValutar;
        data["delete"] = this.delete;
        return data;
    }

    clone(): BVC_VenitTitluCFReinvDto {
        const json = this.toJSON();
        let result = new BVC_VenitTitluCFReinvDto();
        result.init(json);
        return result;
    }
}

export interface IBVC_VenitTitluCFReinvDto {
    id: number;
    bvC_VenitTitluCFId: number;
    dataReinvestire: moment.Moment;
    sumaReinvestita: number;
    procDobanda: number;
    mainValue: boolean;
    sumaIncasata: number;
    currencyId: number;
    currencyName: string | undefined;
    cursValutar: number;
    delete: boolean;
}

export class BugetReinvestIncasari implements IBugetReinvestIncasari {
    id: number;
    idPlasament: string | undefined;
    tipPlasamentStr: string | undefined;
    tipPlasament: BVC_PlasamentType;
    activityType: string | undefined;
    activityTypeId: number;
    venitType: VenitType;
    venitTypeStr: string | undefined;
    currencyId: number;
    currency: string | undefined;
    dataIncasare: moment.Moment;
    valoarePlasament: number;
    dobandaTotala: number;
    valoareIncasata: number;
    valoareIncasataRon: number;
    dataReinvestire: moment.Moment;
    sumaReinvestita: number;
    bvC_VenitTitluCFReinv: BVC_VenitTitluCFReinvDto[] | undefined;

    constructor(data?: IBugetReinvestIncasari) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idPlasament = _data["idPlasament"];
            this.tipPlasamentStr = _data["tipPlasamentStr"];
            this.tipPlasament = _data["tipPlasament"];
            this.activityType = _data["activityType"];
            this.activityTypeId = _data["activityTypeId"];
            this.venitType = _data["venitType"];
            this.venitTypeStr = _data["venitTypeStr"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"];
            this.dataIncasare = _data["dataIncasare"] ? moment(_data["dataIncasare"].toString()) : <any>undefined;
            this.valoarePlasament = _data["valoarePlasament"];
            this.dobandaTotala = _data["dobandaTotala"];
            this.valoareIncasata = _data["valoareIncasata"];
            this.valoareIncasataRon = _data["valoareIncasataRon"];
            this.dataReinvestire = _data["dataReinvestire"] ? moment(_data["dataReinvestire"].toString()) : <any>undefined;
            this.sumaReinvestita = _data["sumaReinvestita"];
            if (Array.isArray(_data["bvC_VenitTitluCFReinv"])) {
                this.bvC_VenitTitluCFReinv = [] as any;
                for (let item of _data["bvC_VenitTitluCFReinv"])
                    this.bvC_VenitTitluCFReinv.push(BVC_VenitTitluCFReinvDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BugetReinvestIncasari {
        data = typeof data === 'object' ? data : {};
        let result = new BugetReinvestIncasari();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idPlasament"] = this.idPlasament;
        data["tipPlasamentStr"] = this.tipPlasamentStr;
        data["tipPlasament"] = this.tipPlasament;
        data["activityType"] = this.activityType;
        data["activityTypeId"] = this.activityTypeId;
        data["venitType"] = this.venitType;
        data["venitTypeStr"] = this.venitTypeStr;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency;
        data["dataIncasare"] = this.dataIncasare ? this.dataIncasare.toISOString() : <any>undefined;
        data["valoarePlasament"] = this.valoarePlasament;
        data["dobandaTotala"] = this.dobandaTotala;
        data["valoareIncasata"] = this.valoareIncasata;
        data["valoareIncasataRon"] = this.valoareIncasataRon;
        data["dataReinvestire"] = this.dataReinvestire ? this.dataReinvestire.toISOString() : <any>undefined;
        data["sumaReinvestita"] = this.sumaReinvestita;
        if (Array.isArray(this.bvC_VenitTitluCFReinv)) {
            data["bvC_VenitTitluCFReinv"] = [];
            for (let item of this.bvC_VenitTitluCFReinv)
                data["bvC_VenitTitluCFReinv"].push(item.toJSON());
        }
        return data;
    }

    clone(): BugetReinvestIncasari {
        const json = this.toJSON();
        let result = new BugetReinvestIncasari();
        result.init(json);
        return result;
    }
}

export interface IBugetReinvestIncasari {
    id: number;
    idPlasament: string | undefined;
    tipPlasamentStr: string | undefined;
    tipPlasament: BVC_PlasamentType;
    activityType: string | undefined;
    activityTypeId: number;
    venitType: VenitType;
    venitTypeStr: string | undefined;
    currencyId: number;
    currency: string | undefined;
    dataIncasare: moment.Moment;
    valoarePlasament: number;
    dobandaTotala: number;
    valoareIncasata: number;
    valoareIncasataRon: number;
    dataReinvestire: moment.Moment;
    sumaReinvestita: number;
    bvC_VenitTitluCFReinv: BVC_VenitTitluCFReinvDto[] | undefined;
}

export class TabelIncasari implements ITabelIncasari {
    date: moment.Moment;
    reinvestit: boolean;
    venitTypeStr: string | undefined;
    idPlasament: string | undefined;
    activityType: string | undefined;
    currency: string | undefined;
    tipPlasamentStr: string | undefined;
    valoareIncasata: number;
    valoareReinvestita: number;
    procDobanda: number;

    constructor(data?: ITabelIncasari) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.reinvestit = _data["reinvestit"];
            this.venitTypeStr = _data["venitTypeStr"];
            this.idPlasament = _data["idPlasament"];
            this.activityType = _data["activityType"];
            this.currency = _data["currency"];
            this.tipPlasamentStr = _data["tipPlasamentStr"];
            this.valoareIncasata = _data["valoareIncasata"];
            this.valoareReinvestita = _data["valoareReinvestita"];
            this.procDobanda = _data["procDobanda"];
        }
    }

    static fromJS(data: any): TabelIncasari {
        data = typeof data === 'object' ? data : {};
        let result = new TabelIncasari();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["reinvestit"] = this.reinvestit;
        data["venitTypeStr"] = this.venitTypeStr;
        data["idPlasament"] = this.idPlasament;
        data["activityType"] = this.activityType;
        data["currency"] = this.currency;
        data["tipPlasamentStr"] = this.tipPlasamentStr;
        data["valoareIncasata"] = this.valoareIncasata;
        data["valoareReinvestita"] = this.valoareReinvestita;
        data["procDobanda"] = this.procDobanda;
        return data;
    }

    clone(): TabelIncasari {
        const json = this.toJSON();
        let result = new TabelIncasari();
        result.init(json);
        return result;
    }
}

export interface ITabelIncasari {
    date: moment.Moment;
    reinvestit: boolean;
    venitTypeStr: string | undefined;
    idPlasament: string | undefined;
    activityType: string | undefined;
    currency: string | undefined;
    tipPlasamentStr: string | undefined;
    valoareIncasata: number;
    valoareReinvestita: number;
    procDobanda: number;
}

export class BugetReinvestPlati implements IBugetReinvestPlati {
    id: number;
    dataPlatii: moment.Moment;
    descriere: string | undefined;
    valoarePlata: number;
    valoarePlatita: number;

    constructor(data?: IBugetReinvestPlati) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataPlatii = _data["dataPlatii"] ? moment(_data["dataPlatii"].toString()) : <any>undefined;
            this.descriere = _data["descriere"];
            this.valoarePlata = _data["valoarePlata"];
            this.valoarePlatita = _data["valoarePlatita"];
        }
    }

    static fromJS(data: any): BugetReinvestPlati {
        data = typeof data === 'object' ? data : {};
        let result = new BugetReinvestPlati();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataPlatii"] = this.dataPlatii ? this.dataPlatii.toISOString() : <any>undefined;
        data["descriere"] = this.descriere;
        data["valoarePlata"] = this.valoarePlata;
        data["valoarePlatita"] = this.valoarePlatita;
        return data;
    }

    clone(): BugetReinvestPlati {
        const json = this.toJSON();
        let result = new BugetReinvestPlati();
        result.init(json);
        return result;
    }
}

export interface IBugetReinvestPlati {
    id: number;
    dataPlatii: moment.Moment;
    descriere: string | undefined;
    valoarePlata: number;
    valoarePlatita: number;
}

export class BugetTitluriCFViewCurrenciesList implements IBugetTitluriCFViewCurrenciesList {
    id: number;
    currencyId: number;
    currency: string | undefined;
    valoareIncasata: number;
    valoareReinvestita: number;
    valoarePlasament: number;
    activityType: string | undefined;
    activityTypeId: number;
    valoareIncasataLei: number;
    valoareReinvestitaLei: number;
    valoarePlasamentLei: number;

    constructor(data?: IBugetTitluriCFViewCurrenciesList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"];
            this.valoareIncasata = _data["valoareIncasata"];
            this.valoareReinvestita = _data["valoareReinvestita"];
            this.valoarePlasament = _data["valoarePlasament"];
            this.activityType = _data["activityType"];
            this.activityTypeId = _data["activityTypeId"];
            this.valoareIncasataLei = _data["valoareIncasataLei"];
            this.valoareReinvestitaLei = _data["valoareReinvestitaLei"];
            this.valoarePlasamentLei = _data["valoarePlasamentLei"];
        }
    }

    static fromJS(data: any): BugetTitluriCFViewCurrenciesList {
        data = typeof data === 'object' ? data : {};
        let result = new BugetTitluriCFViewCurrenciesList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency;
        data["valoareIncasata"] = this.valoareIncasata;
        data["valoareReinvestita"] = this.valoareReinvestita;
        data["valoarePlasament"] = this.valoarePlasament;
        data["activityType"] = this.activityType;
        data["activityTypeId"] = this.activityTypeId;
        data["valoareIncasataLei"] = this.valoareIncasataLei;
        data["valoareReinvestitaLei"] = this.valoareReinvestitaLei;
        data["valoarePlasamentLei"] = this.valoarePlasamentLei;
        return data;
    }

    clone(): BugetTitluriCFViewCurrenciesList {
        const json = this.toJSON();
        let result = new BugetTitluriCFViewCurrenciesList();
        result.init(json);
        return result;
    }
}

export interface IBugetTitluriCFViewCurrenciesList {
    id: number;
    currencyId: number;
    currency: string | undefined;
    valoareIncasata: number;
    valoareReinvestita: number;
    valoarePlasament: number;
    activityType: string | undefined;
    activityTypeId: number;
    valoareIncasataLei: number;
    valoareReinvestitaLei: number;
    valoarePlasamentLei: number;
}

export class ComisionDto implements IComisionDto {
    id: number;
    imprumutId: number | undefined;
    tipComision: string | undefined;
    description: string | undefined;
    tipValoareComision: string | undefined;
    valoareComision: number;
    modCalculComision: string | undefined;
    tipSumaComision: string | undefined;
    bazaDeCalcul: number;

    constructor(data?: IComisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imprumutId = _data["imprumutId"];
            this.tipComision = _data["tipComision"];
            this.description = _data["description"];
            this.tipValoareComision = _data["tipValoareComision"];
            this.valoareComision = _data["valoareComision"];
            this.modCalculComision = _data["modCalculComision"];
            this.tipSumaComision = _data["tipSumaComision"];
            this.bazaDeCalcul = _data["bazaDeCalcul"];
        }
    }

    static fromJS(data: any): ComisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imprumutId"] = this.imprumutId;
        data["tipComision"] = this.tipComision;
        data["description"] = this.description;
        data["tipValoareComision"] = this.tipValoareComision;
        data["valoareComision"] = this.valoareComision;
        data["modCalculComision"] = this.modCalculComision;
        data["tipSumaComision"] = this.tipSumaComision;
        data["bazaDeCalcul"] = this.bazaDeCalcul;
        return data;
    }

    clone(): ComisionDto {
        const json = this.toJSON();
        let result = new ComisionDto();
        result.init(json);
        return result;
    }
}

export interface IComisionDto {
    id: number;
    imprumutId: number | undefined;
    tipComision: string | undefined;
    description: string | undefined;
    tipValoareComision: string | undefined;
    valoareComision: number;
    modCalculComision: string | undefined;
    tipSumaComision: string | undefined;
    bazaDeCalcul: number;
}

export class ComisionV2Dto implements IComisionV2Dto {
    id: number;
    imprumutId: number | undefined;
    tipComision: string | undefined;
    descriere: string | undefined;
    tipValoareComision: string | undefined;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    valoareComision: number;
    modCalculComision: string | undefined;
    tipSumaComision: string | undefined;
    bazaDeCalcul: number;

    constructor(data?: IComisionV2Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imprumutId = _data["imprumutId"];
            this.tipComision = _data["tipComision"];
            this.descriere = _data["descriere"];
            this.tipValoareComision = _data["tipValoareComision"];
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.valoareComision = _data["valoareComision"];
            this.modCalculComision = _data["modCalculComision"];
            this.tipSumaComision = _data["tipSumaComision"];
            this.bazaDeCalcul = _data["bazaDeCalcul"];
        }
    }

    static fromJS(data: any): ComisionV2Dto {
        data = typeof data === 'object' ? data : {};
        let result = new ComisionV2Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imprumutId"] = this.imprumutId;
        data["tipComision"] = this.tipComision;
        data["descriere"] = this.descriere;
        data["tipValoareComision"] = this.tipValoareComision;
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["valoareComision"] = this.valoareComision;
        data["modCalculComision"] = this.modCalculComision;
        data["tipSumaComision"] = this.tipSumaComision;
        data["bazaDeCalcul"] = this.bazaDeCalcul;
        return data;
    }

    clone(): ComisionV2Dto {
        const json = this.toJSON();
        let result = new ComisionV2Dto();
        result.init(json);
        return result;
    }
}

export interface IComisionV2Dto {
    id: number;
    imprumutId: number | undefined;
    tipComision: string | undefined;
    descriere: string | undefined;
    tipValoareComision: string | undefined;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    valoareComision: number;
    modCalculComision: string | undefined;
    tipSumaComision: string | undefined;
    bazaDeCalcul: number;
}

export enum TipComision {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum TipValoareComision {
    _0 = 0,
    _1 = 1,
}

export enum ModCalculComision {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum TipSumaComision {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class ComisionEditDto implements IComisionEditDto {
    id: number;
    imprumutId: number | undefined;
    tipComision: TipComision;
    description: string | undefined;
    tipValoareComision: TipValoareComision;
    valoareComision: number;
    modCalculComision: ModCalculComision;
    tipSumaComision: TipSumaComision;
    bazaDeCalcul: number;
    okDelete: boolean;

    constructor(data?: IComisionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imprumutId = _data["imprumutId"];
            this.tipComision = _data["tipComision"];
            this.description = _data["description"];
            this.tipValoareComision = _data["tipValoareComision"];
            this.valoareComision = _data["valoareComision"];
            this.modCalculComision = _data["modCalculComision"];
            this.tipSumaComision = _data["tipSumaComision"];
            this.bazaDeCalcul = _data["bazaDeCalcul"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): ComisionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComisionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imprumutId"] = this.imprumutId;
        data["tipComision"] = this.tipComision;
        data["description"] = this.description;
        data["tipValoareComision"] = this.tipValoareComision;
        data["valoareComision"] = this.valoareComision;
        data["modCalculComision"] = this.modCalculComision;
        data["tipSumaComision"] = this.tipSumaComision;
        data["bazaDeCalcul"] = this.bazaDeCalcul;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): ComisionEditDto {
        const json = this.toJSON();
        let result = new ComisionEditDto();
        result.init(json);
        return result;
    }
}

export interface IComisionEditDto {
    id: number;
    imprumutId: number | undefined;
    tipComision: TipComision;
    description: string | undefined;
    tipValoareComision: TipValoareComision;
    valoareComision: number;
    modCalculComision: ModCalculComision;
    tipSumaComision: TipSumaComision;
    bazaDeCalcul: number;
    okDelete: boolean;
}

export enum TipComisionV2 {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class ComisionV2EditDto implements IComisionV2EditDto {
    id: number;
    imprumutId: number | undefined;
    tipComision: TipComisionV2;
    descriere: string | undefined;
    tipValoareComision: TipValoareComision;
    valoareComision: number;
    modCalculComision: ModCalculComision;
    tipSumaComision: TipSumaComision;
    bazaDeCalcul: number;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    state: State;
    tenantId: number;
    okDelete: boolean;

    constructor(data?: IComisionV2EditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imprumutId = _data["imprumutId"];
            this.tipComision = _data["tipComision"];
            this.descriere = _data["descriere"];
            this.tipValoareComision = _data["tipValoareComision"];
            this.valoareComision = _data["valoareComision"];
            this.modCalculComision = _data["modCalculComision"];
            this.tipSumaComision = _data["tipSumaComision"];
            this.bazaDeCalcul = _data["bazaDeCalcul"];
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): ComisionV2EditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComisionV2EditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imprumutId"] = this.imprumutId;
        data["tipComision"] = this.tipComision;
        data["descriere"] = this.descriere;
        data["tipValoareComision"] = this.tipValoareComision;
        data["valoareComision"] = this.valoareComision;
        data["modCalculComision"] = this.modCalculComision;
        data["tipSumaComision"] = this.tipSumaComision;
        data["bazaDeCalcul"] = this.bazaDeCalcul;
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): ComisionV2EditDto {
        const json = this.toJSON();
        let result = new ComisionV2EditDto();
        result.init(json);
        return result;
    }
}

export interface IComisionV2EditDto {
    id: number;
    imprumutId: number | undefined;
    tipComision: TipComisionV2;
    descriere: string | undefined;
    tipValoareComision: TipValoareComision;
    valoareComision: number;
    modCalculComision: ModCalculComision;
    tipSumaComision: TipSumaComision;
    bazaDeCalcul: number;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    state: State;
    tenantId: number;
    okDelete: boolean;
}

export class DataComisionEditDto implements IDataComisionEditDto {
    id: number;
    comisionId: number | undefined;
    imprumutId: number | undefined;
    tragereId: number | undefined;
    contaOperationId: number | undefined;
    contaOperationDetailId: number | undefined;
    index: number;
    dataPlataComision: moment.Moment;
    sumaComision: number;
    tipValoareComision: TipValoareComision;
    tipSumaComision: TipSumaComision;
    valoareComision: number;
    isValid: boolean;
    okDelete: boolean;

    constructor(data?: IDataComisionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.comisionId = _data["comisionId"];
            this.imprumutId = _data["imprumutId"];
            this.tragereId = _data["tragereId"];
            this.contaOperationId = _data["contaOperationId"];
            this.contaOperationDetailId = _data["contaOperationDetailId"];
            this.index = _data["index"];
            this.dataPlataComision = _data["dataPlataComision"] ? moment(_data["dataPlataComision"].toString()) : <any>undefined;
            this.sumaComision = _data["sumaComision"];
            this.tipValoareComision = _data["tipValoareComision"];
            this.tipSumaComision = _data["tipSumaComision"];
            this.valoareComision = _data["valoareComision"];
            this.isValid = _data["isValid"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): DataComisionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataComisionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["comisionId"] = this.comisionId;
        data["imprumutId"] = this.imprumutId;
        data["tragereId"] = this.tragereId;
        data["contaOperationId"] = this.contaOperationId;
        data["contaOperationDetailId"] = this.contaOperationDetailId;
        data["index"] = this.index;
        data["dataPlataComision"] = this.dataPlataComision ? this.dataPlataComision.toISOString() : <any>undefined;
        data["sumaComision"] = this.sumaComision;
        data["tipValoareComision"] = this.tipValoareComision;
        data["tipSumaComision"] = this.tipSumaComision;
        data["valoareComision"] = this.valoareComision;
        data["isValid"] = this.isValid;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): DataComisionEditDto {
        const json = this.toJSON();
        let result = new DataComisionEditDto();
        result.init(json);
        return result;
    }
}

export interface IDataComisionEditDto {
    id: number;
    comisionId: number | undefined;
    imprumutId: number | undefined;
    tragereId: number | undefined;
    contaOperationId: number | undefined;
    contaOperationDetailId: number | undefined;
    index: number;
    dataPlataComision: moment.Moment;
    sumaComision: number;
    tipValoareComision: TipValoareComision;
    tipSumaComision: TipSumaComision;
    valoareComision: number;
    isValid: boolean;
    okDelete: boolean;
}

export class DocumentType implements IDocumentType {
    typeName: string;
    typeNameShort: string;
    editable: boolean;
    autoNumber: boolean;
    closingMonth: boolean;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDocumentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeName = _data["typeName"];
            this.typeNameShort = _data["typeNameShort"];
            this.editable = _data["editable"];
            this.autoNumber = _data["autoNumber"];
            this.closingMonth = _data["closingMonth"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DocumentType {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["typeNameShort"] = this.typeNameShort;
        data["editable"] = this.editable;
        data["autoNumber"] = this.autoNumber;
        data["closingMonth"] = this.closingMonth;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): DocumentType {
        const json = this.toJSON();
        let result = new DocumentType();
        result.init(json);
        return result;
    }
}

export interface IDocumentType {
    typeName: string;
    typeNameShort: string;
    editable: boolean;
    autoNumber: boolean;
    closingMonth: boolean;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ImprumutTip implements IImprumutTip {
    description: string | undefined;
    state: State;
    tenantId: number;
    id: number;

    constructor(data?: IImprumutTip) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImprumutTip {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumutTip();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): ImprumutTip {
        const json = this.toJSON();
        let result = new ImprumutTip();
        result.init(json);
        return result;
    }
}

export interface IImprumutTip {
    description: string | undefined;
    state: State;
    tenantId: number;
    id: number;
}

export class Locality implements ILocality {
    id: number;
    name: string | undefined;
    region: Region;

    constructor(data?: ILocality) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.region = _data["region"] ? Region.fromJS(_data["region"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Locality {
        data = typeof data === 'object' ? data : {};
        let result = new Locality();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        return data;
    }

    clone(): Locality {
        const json = this.toJSON();
        let result = new Locality();
        result.init(json);
        return result;
    }
}

export interface ILocality {
    id: number;
    name: string | undefined;
    region: Region;
}

export class Country implements ICountry {
    id: number;
    countryAbrv: string | undefined;
    countryName: string | undefined;
    region: Region[] | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryAbrv = _data["countryAbrv"];
            this.countryName = _data["countryName"];
            if (Array.isArray(_data["region"])) {
                this.region = [] as any;
                for (let item of _data["region"])
                    this.region.push(Region.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryAbrv"] = this.countryAbrv;
        data["countryName"] = this.countryName;
        if (Array.isArray(this.region)) {
            data["region"] = [];
            for (let item of this.region)
                data["region"].push(item.toJSON());
        }
        return data;
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    id: number;
    countryAbrv: string | undefined;
    countryName: string | undefined;
    region: Region[] | undefined;
}

export class Region implements IRegion {
    regionName: string | undefined;
    regionAbrv: string | undefined;
    locality: Locality[] | undefined;
    country: Country;
    id: number;

    constructor(data?: IRegion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regionName = _data["regionName"];
            this.regionAbrv = _data["regionAbrv"];
            if (Array.isArray(_data["locality"])) {
                this.locality = [] as any;
                for (let item of _data["locality"])
                    this.locality.push(Locality.fromJS(item));
            }
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Region {
        data = typeof data === 'object' ? data : {};
        let result = new Region();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionName"] = this.regionName;
        data["regionAbrv"] = this.regionAbrv;
        if (Array.isArray(this.locality)) {
            data["locality"] = [];
            for (let item of this.locality)
                data["locality"].push(item.toJSON());
        }
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): Region {
        const json = this.toJSON();
        let result = new Region();
        result.init(json);
        return result;
    }
}

export interface IRegion {
    regionName: string | undefined;
    regionAbrv: string | undefined;
    locality: Locality[] | undefined;
    country: Country;
    id: number;
}

export class LegalPerson implements ILegalPerson {
    name: string | undefined;
    bank: Issuer;
    readonly fullName: string | undefined;
    readonly fullNameLastFirst: string | undefined;
    isVATPayer: boolean;
    startDateVATPayment: moment.Moment | undefined;
    isVATCollector: boolean;
    vatCollectedStartDate: moment.Moment | undefined;
    id1: string | undefined;
    id2: string | undefined;
    addressStreet: string | undefined;
    addressNo: string | undefined;
    addressBlock: string | undefined;
    addressFloor: string | undefined;
    addressApartment: string | undefined;
    addressZipCode: string | undefined;
    addressLocality: string | undefined;
    addressRegionId: number | undefined;
    addressRegion: Region;
    addressCountryId: number | undefined;
    addressCountry: Country;
    bankAccount: BankAccount[] | undefined;
    isEmployee: boolean;
    idPersonal: number | undefined;
    idBanci: number | undefined;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILegalPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.bank = _data["bank"] ? Issuer.fromJS(_data["bank"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).fullNameLastFirst = _data["fullNameLastFirst"];
            this.isVATPayer = _data["isVATPayer"];
            this.startDateVATPayment = _data["startDateVATPayment"] ? moment(_data["startDateVATPayment"].toString()) : <any>undefined;
            this.isVATCollector = _data["isVATCollector"];
            this.vatCollectedStartDate = _data["vatCollectedStartDate"] ? moment(_data["vatCollectedStartDate"].toString()) : <any>undefined;
            this.id1 = _data["id1"];
            this.id2 = _data["id2"];
            this.addressStreet = _data["addressStreet"];
            this.addressNo = _data["addressNo"];
            this.addressBlock = _data["addressBlock"];
            this.addressFloor = _data["addressFloor"];
            this.addressApartment = _data["addressApartment"];
            this.addressZipCode = _data["addressZipCode"];
            this.addressLocality = _data["addressLocality"];
            this.addressRegionId = _data["addressRegionId"];
            this.addressRegion = _data["addressRegion"] ? Region.fromJS(_data["addressRegion"]) : <any>undefined;
            this.addressCountryId = _data["addressCountryId"];
            this.addressCountry = _data["addressCountry"] ? Country.fromJS(_data["addressCountry"]) : <any>undefined;
            if (Array.isArray(_data["bankAccount"])) {
                this.bankAccount = [] as any;
                for (let item of _data["bankAccount"])
                    this.bankAccount.push(BankAccount.fromJS(item));
            }
            this.isEmployee = _data["isEmployee"];
            this.idPersonal = _data["idPersonal"];
            this.idBanci = _data["idBanci"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LegalPerson {
        data = typeof data === 'object' ? data : {};
        let result = new LegalPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["fullNameLastFirst"] = this.fullNameLastFirst;
        data["isVATPayer"] = this.isVATPayer;
        data["startDateVATPayment"] = this.startDateVATPayment ? this.startDateVATPayment.toISOString() : <any>undefined;
        data["isVATCollector"] = this.isVATCollector;
        data["vatCollectedStartDate"] = this.vatCollectedStartDate ? this.vatCollectedStartDate.toISOString() : <any>undefined;
        data["id1"] = this.id1;
        data["id2"] = this.id2;
        data["addressStreet"] = this.addressStreet;
        data["addressNo"] = this.addressNo;
        data["addressBlock"] = this.addressBlock;
        data["addressFloor"] = this.addressFloor;
        data["addressApartment"] = this.addressApartment;
        data["addressZipCode"] = this.addressZipCode;
        data["addressLocality"] = this.addressLocality;
        data["addressRegionId"] = this.addressRegionId;
        data["addressRegion"] = this.addressRegion ? this.addressRegion.toJSON() : <any>undefined;
        data["addressCountryId"] = this.addressCountryId;
        data["addressCountry"] = this.addressCountry ? this.addressCountry.toJSON() : <any>undefined;
        if (Array.isArray(this.bankAccount)) {
            data["bankAccount"] = [];
            for (let item of this.bankAccount)
                data["bankAccount"].push(item.toJSON());
        }
        data["isEmployee"] = this.isEmployee;
        data["idPersonal"] = this.idPersonal;
        data["idBanci"] = this.idBanci;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): LegalPerson {
        const json = this.toJSON();
        let result = new LegalPerson();
        result.init(json);
        return result;
    }
}

export interface ILegalPerson {
    name: string | undefined;
    bank: Issuer;
    fullName: string | undefined;
    fullNameLastFirst: string | undefined;
    isVATPayer: boolean;
    startDateVATPayment: moment.Moment | undefined;
    isVATCollector: boolean;
    vatCollectedStartDate: moment.Moment | undefined;
    id1: string | undefined;
    id2: string | undefined;
    addressStreet: string | undefined;
    addressNo: string | undefined;
    addressBlock: string | undefined;
    addressFloor: string | undefined;
    addressApartment: string | undefined;
    addressZipCode: string | undefined;
    addressLocality: string | undefined;
    addressRegionId: number | undefined;
    addressRegion: Region;
    addressCountryId: number | undefined;
    addressCountry: Country;
    bankAccount: BankAccount[] | undefined;
    isEmployee: boolean;
    idPersonal: number | undefined;
    idBanci: number | undefined;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum IssuerType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class BNR_Sector implements IBNR_Sector {
    sector: string | undefined;
    denumire: string | undefined;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IBNR_Sector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sector = _data["sector"];
            this.denumire = _data["denumire"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BNR_Sector {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_Sector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sector"] = this.sector;
        data["denumire"] = this.denumire;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): BNR_Sector {
        const json = this.toJSON();
        let result = new BNR_Sector();
        result.init(json);
        return result;
    }
}

export interface IBNR_Sector {
    sector: string | undefined;
    denumire: string | undefined;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Issuer implements IIssuer {
    legalPersonId: number;
    legalPerson: LegalPerson;
    ibanAbrv: string | undefined;
    bic: string | undefined;
    issuerType: IssuerType;
    bnR_SectorId: number | undefined;
    bnR_Sector: BNR_Sector;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IIssuer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalPersonId = _data["legalPersonId"];
            this.legalPerson = _data["legalPerson"] ? LegalPerson.fromJS(_data["legalPerson"]) : <any>undefined;
            this.ibanAbrv = _data["ibanAbrv"];
            this.bic = _data["bic"];
            this.issuerType = _data["issuerType"];
            this.bnR_SectorId = _data["bnR_SectorId"];
            this.bnR_Sector = _data["bnR_Sector"] ? BNR_Sector.fromJS(_data["bnR_Sector"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Issuer {
        data = typeof data === 'object' ? data : {};
        let result = new Issuer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalPersonId"] = this.legalPersonId;
        data["legalPerson"] = this.legalPerson ? this.legalPerson.toJSON() : <any>undefined;
        data["ibanAbrv"] = this.ibanAbrv;
        data["bic"] = this.bic;
        data["issuerType"] = this.issuerType;
        data["bnR_SectorId"] = this.bnR_SectorId;
        data["bnR_Sector"] = this.bnR_Sector ? this.bnR_Sector.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Issuer {
        const json = this.toJSON();
        let result = new Issuer();
        result.init(json);
        return result;
    }
}

export interface IIssuer {
    legalPersonId: number;
    legalPerson: LegalPerson;
    ibanAbrv: string | undefined;
    bic: string | undefined;
    issuerType: IssuerType;
    bnR_SectorId: number | undefined;
    bnR_Sector: BNR_Sector;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Person implements IPerson {
    id1: string | undefined;
    id2: string | undefined;
    addressStreet: string | undefined;
    addressNo: string | undefined;
    addressBlock: string | undefined;
    addressFloor: string | undefined;
    addressApartment: string | undefined;
    addressZipCode: string | undefined;
    addressLocality: string | undefined;
    addressRegionId: number | undefined;
    addressRegion: Region;
    addressCountryId: number | undefined;
    addressCountry: Country;
    readonly fullName: string | undefined;
    readonly fullNameLastFirst: string | undefined;
    bankAccount: BankAccount[] | undefined;
    isEmployee: boolean;
    idPersonal: number | undefined;
    idBanci: number | undefined;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id1 = _data["id1"];
            this.id2 = _data["id2"];
            this.addressStreet = _data["addressStreet"];
            this.addressNo = _data["addressNo"];
            this.addressBlock = _data["addressBlock"];
            this.addressFloor = _data["addressFloor"];
            this.addressApartment = _data["addressApartment"];
            this.addressZipCode = _data["addressZipCode"];
            this.addressLocality = _data["addressLocality"];
            this.addressRegionId = _data["addressRegionId"];
            this.addressRegion = _data["addressRegion"] ? Region.fromJS(_data["addressRegion"]) : <any>undefined;
            this.addressCountryId = _data["addressCountryId"];
            this.addressCountry = _data["addressCountry"] ? Country.fromJS(_data["addressCountry"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).fullNameLastFirst = _data["fullNameLastFirst"];
            if (Array.isArray(_data["bankAccount"])) {
                this.bankAccount = [] as any;
                for (let item of _data["bankAccount"])
                    this.bankAccount.push(BankAccount.fromJS(item));
            }
            this.isEmployee = _data["isEmployee"];
            this.idPersonal = _data["idPersonal"];
            this.idBanci = _data["idBanci"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id1"] = this.id1;
        data["id2"] = this.id2;
        data["addressStreet"] = this.addressStreet;
        data["addressNo"] = this.addressNo;
        data["addressBlock"] = this.addressBlock;
        data["addressFloor"] = this.addressFloor;
        data["addressApartment"] = this.addressApartment;
        data["addressZipCode"] = this.addressZipCode;
        data["addressLocality"] = this.addressLocality;
        data["addressRegionId"] = this.addressRegionId;
        data["addressRegion"] = this.addressRegion ? this.addressRegion.toJSON() : <any>undefined;
        data["addressCountryId"] = this.addressCountryId;
        data["addressCountry"] = this.addressCountry ? this.addressCountry.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["fullNameLastFirst"] = this.fullNameLastFirst;
        if (Array.isArray(this.bankAccount)) {
            data["bankAccount"] = [];
            for (let item of this.bankAccount)
                data["bankAccount"].push(item.toJSON());
        }
        data["isEmployee"] = this.isEmployee;
        data["idPersonal"] = this.idPersonal;
        data["idBanci"] = this.idBanci;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Person {
        const json = this.toJSON();
        let result = new Person();
        result.init(json);
        return result;
    }
}

export interface IPerson {
    id1: string | undefined;
    id2: string | undefined;
    addressStreet: string | undefined;
    addressNo: string | undefined;
    addressBlock: string | undefined;
    addressFloor: string | undefined;
    addressApartment: string | undefined;
    addressZipCode: string | undefined;
    addressLocality: string | undefined;
    addressRegionId: number | undefined;
    addressRegion: Region;
    addressCountryId: number | undefined;
    addressCountry: Country;
    fullName: string | undefined;
    fullNameLastFirst: string | undefined;
    bankAccount: BankAccount[] | undefined;
    isEmployee: boolean;
    idPersonal: number | undefined;
    idBanci: number | undefined;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class BankAccount implements IBankAccount {
    iban: string | undefined;
    currencyId: number;
    currency: Currency;
    bankId: number;
    bank: Issuer;
    personId: number;
    person: Person;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IBankAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iban = _data["iban"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.bankId = _data["bankId"];
            this.bank = _data["bank"] ? Issuer.fromJS(_data["bank"]) : <any>undefined;
            this.personId = _data["personId"];
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iban"] = this.iban;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["bankId"] = this.bankId;
        data["bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["personId"] = this.personId;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): BankAccount {
        const json = this.toJSON();
        let result = new BankAccount();
        result.init(json);
        return result;
    }
}

export interface IBankAccount {
    iban: string | undefined;
    currencyId: number;
    currency: Currency;
    bankId: number;
    bank: Issuer;
    personId: number;
    person: Person;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ActivityType implements IActivityType {
    activityName: string;
    status: State;
    tenantId: number;
    mainActivity: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IActivityType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityName = _data["activityName"];
            this.status = _data["status"];
            this.tenantId = _data["tenantId"];
            this.mainActivity = _data["mainActivity"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityType {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityName"] = this.activityName;
        data["status"] = this.status;
        data["tenantId"] = this.tenantId;
        data["mainActivity"] = this.mainActivity;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): ActivityType {
        const json = this.toJSON();
        let result = new ActivityType();
        result.init(json);
        return result;
    }
}

export interface IActivityType {
    activityName: string;
    status: State;
    tenantId: number;
    mainActivity: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CotaTVA implements ICotaTVA {
    vat: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ICotaTVA) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vat = _data["vat"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CotaTVA {
        data = typeof data === 'object' ? data : {};
        let result = new CotaTVA();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vat"] = this.vat;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): CotaTVA {
        const json = this.toJSON();
        let result = new CotaTVA();
        result.init(json);
        return result;
    }
}

export interface ICotaTVA {
    vat: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum InvoiceElementsType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum CategoryType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class InvoiceElementsDetailsCategory implements IInvoiceElementsDetailsCategory {
    categoryElementDetName: string | undefined;
    state: State;
    categoryType: CategoryType;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IInvoiceElementsDetailsCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryElementDetName = _data["categoryElementDetName"];
            this.state = _data["state"];
            this.categoryType = _data["categoryType"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InvoiceElementsDetailsCategory {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceElementsDetailsCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryElementDetName"] = this.categoryElementDetName;
        data["state"] = this.state;
        data["categoryType"] = this.categoryType;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): InvoiceElementsDetailsCategory {
        const json = this.toJSON();
        let result = new InvoiceElementsDetailsCategory();
        result.init(json);
        return result;
    }
}

export interface IInvoiceElementsDetailsCategory {
    categoryElementDetName: string | undefined;
    state: State;
    categoryType: CategoryType;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class InvoiceElementsDetails implements IInvoiceElementsDetails {
    description: string | undefined;
    invoiceElementsType: InvoiceElementsType;
    thirdPartyAccount: string | undefined;
    amortizationAccount: string | undefined;
    expenseAmortizAccount: string | undefined;
    correspondentAccount: string | undefined;
    state: State;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsCategory: InvoiceElementsDetailsCategory;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IInvoiceElementsDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.invoiceElementsType = _data["invoiceElementsType"];
            this.thirdPartyAccount = _data["thirdPartyAccount"];
            this.amortizationAccount = _data["amortizationAccount"];
            this.expenseAmortizAccount = _data["expenseAmortizAccount"];
            this.correspondentAccount = _data["correspondentAccount"];
            this.state = _data["state"];
            this.invoiceElementsDetailsCategoryId = _data["invoiceElementsDetailsCategoryId"];
            this.invoiceElementsDetailsCategory = _data["invoiceElementsDetailsCategory"] ? InvoiceElementsDetailsCategory.fromJS(_data["invoiceElementsDetailsCategory"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InvoiceElementsDetails {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceElementsDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["invoiceElementsType"] = this.invoiceElementsType;
        data["thirdPartyAccount"] = this.thirdPartyAccount;
        data["amortizationAccount"] = this.amortizationAccount;
        data["expenseAmortizAccount"] = this.expenseAmortizAccount;
        data["correspondentAccount"] = this.correspondentAccount;
        data["state"] = this.state;
        data["invoiceElementsDetailsCategoryId"] = this.invoiceElementsDetailsCategoryId;
        data["invoiceElementsDetailsCategory"] = this.invoiceElementsDetailsCategory ? this.invoiceElementsDetailsCategory.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): InvoiceElementsDetails {
        const json = this.toJSON();
        let result = new InvoiceElementsDetails();
        result.init(json);
        return result;
    }
}

export interface IInvoiceElementsDetails {
    description: string | undefined;
    invoiceElementsType: InvoiceElementsType;
    thirdPartyAccount: string | undefined;
    amortizationAccount: string | undefined;
    expenseAmortizAccount: string | undefined;
    correspondentAccount: string | undefined;
    state: State;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsCategory: InvoiceElementsDetailsCategory;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum AccountFuncType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
    _19 = 19,
    _20 = 20,
    _21 = 21,
    _22 = 22,
    _23 = 23,
    _24 = 24,
}

export enum TaxStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Account implements IAccount {
    symbol: string | undefined;
    syntheticAccountId: number | undefined;
    syntheticAccount: Account;
    analyticAccounts: Account[] | undefined;
    accountName: string;
    externalCode: string | undefined;
    currencyId: number;
    currency: Currency;
    activityTypeId: number | undefined;
    activityType: ActivityType;
    thirdPartyId: number | undefined;
    thirdParty: Person;
    status: State;
    accountTypes: AccountTypes;
    accountFuncType: AccountFuncType;
    computingAccount: boolean;
    accountStatus: boolean;
    taxStatus: TaxStatus;
    bankAccountId: number | undefined;
    bankAccount: BankAccount;
    readonly isSynthethic: boolean;
    tenantId: number;
    sectorBnrId: number | undefined;
    bnR_Sector: BNR_Sector;
    nivelRand: number | undefined;
    dataValabilitate: moment.Moment;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["symbol"];
            this.syntheticAccountId = _data["syntheticAccountId"];
            this.syntheticAccount = _data["syntheticAccount"] ? Account.fromJS(_data["syntheticAccount"]) : <any>undefined;
            if (Array.isArray(_data["analyticAccounts"])) {
                this.analyticAccounts = [] as any;
                for (let item of _data["analyticAccounts"])
                    this.analyticAccounts.push(Account.fromJS(item));
            }
            this.accountName = _data["accountName"];
            this.externalCode = _data["externalCode"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.activityTypeId = _data["activityTypeId"];
            this.activityType = _data["activityType"] ? ActivityType.fromJS(_data["activityType"]) : <any>undefined;
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdParty = _data["thirdParty"] ? Person.fromJS(_data["thirdParty"]) : <any>undefined;
            this.status = _data["status"];
            this.accountTypes = _data["accountTypes"];
            this.accountFuncType = _data["accountFuncType"];
            this.computingAccount = _data["computingAccount"];
            this.accountStatus = _data["accountStatus"];
            this.taxStatus = _data["taxStatus"];
            this.bankAccountId = _data["bankAccountId"];
            this.bankAccount = _data["bankAccount"] ? BankAccount.fromJS(_data["bankAccount"]) : <any>undefined;
            (<any>this).isSynthethic = _data["isSynthethic"];
            this.tenantId = _data["tenantId"];
            this.sectorBnrId = _data["sectorBnrId"];
            this.bnR_Sector = _data["bnR_Sector"] ? BNR_Sector.fromJS(_data["bnR_Sector"]) : <any>undefined;
            this.nivelRand = _data["nivelRand"];
            this.dataValabilitate = _data["dataValabilitate"] ? moment(_data["dataValabilitate"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol"] = this.symbol;
        data["syntheticAccountId"] = this.syntheticAccountId;
        data["syntheticAccount"] = this.syntheticAccount ? this.syntheticAccount.toJSON() : <any>undefined;
        if (Array.isArray(this.analyticAccounts)) {
            data["analyticAccounts"] = [];
            for (let item of this.analyticAccounts)
                data["analyticAccounts"].push(item.toJSON());
        }
        data["accountName"] = this.accountName;
        data["externalCode"] = this.externalCode;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["activityTypeId"] = this.activityTypeId;
        data["activityType"] = this.activityType ? this.activityType.toJSON() : <any>undefined;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdParty"] = this.thirdParty ? this.thirdParty.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["accountTypes"] = this.accountTypes;
        data["accountFuncType"] = this.accountFuncType;
        data["computingAccount"] = this.computingAccount;
        data["accountStatus"] = this.accountStatus;
        data["taxStatus"] = this.taxStatus;
        data["bankAccountId"] = this.bankAccountId;
        data["bankAccount"] = this.bankAccount ? this.bankAccount.toJSON() : <any>undefined;
        data["isSynthethic"] = this.isSynthethic;
        data["tenantId"] = this.tenantId;
        data["sectorBnrId"] = this.sectorBnrId;
        data["bnR_Sector"] = this.bnR_Sector ? this.bnR_Sector.toJSON() : <any>undefined;
        data["nivelRand"] = this.nivelRand;
        data["dataValabilitate"] = this.dataValabilitate ? this.dataValabilitate.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Account {
        const json = this.toJSON();
        let result = new Account();
        result.init(json);
        return result;
    }
}

export interface IAccount {
    symbol: string | undefined;
    syntheticAccountId: number | undefined;
    syntheticAccount: Account;
    analyticAccounts: Account[] | undefined;
    accountName: string;
    externalCode: string | undefined;
    currencyId: number;
    currency: Currency;
    activityTypeId: number | undefined;
    activityType: ActivityType;
    thirdPartyId: number | undefined;
    thirdParty: Person;
    status: State;
    accountTypes: AccountTypes;
    accountFuncType: AccountFuncType;
    computingAccount: boolean;
    accountStatus: boolean;
    taxStatus: TaxStatus;
    bankAccountId: number | undefined;
    bankAccount: BankAccount;
    isSynthethic: boolean;
    tenantId: number;
    sectorBnrId: number | undefined;
    bnR_Sector: BNR_Sector;
    nivelRand: number | undefined;
    dataValabilitate: moment.Moment;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class OperationTypes implements IOperationTypes {
    name: string;
    tenantId: number;
    state: State;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOperationTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.state = _data["state"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OperationTypes {
        data = typeof data === 'object' ? data : {};
        let result = new OperationTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["state"] = this.state;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): OperationTypes {
        const json = this.toJSON();
        let result = new OperationTypes();
        result.init(json);
        return result;
    }
}

export interface IOperationTypes {
    name: string;
    tenantId: number;
    state: State;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum OperationStatus {
    _0 = 0,
    _1 = 1,
}

export class OperationDefinitionDetails implements IOperationDefinitionDetails {
    observations: string | undefined;
    debitId: number;
    debit: Account;
    creditId: number;
    credit: Account;
    tenantId: number;
    operationDefinitionId: number;
    operationDefinition: OperationDefinition;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOperationDefinitionDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.observations = _data["observations"];
            this.debitId = _data["debitId"];
            this.debit = _data["debit"] ? Account.fromJS(_data["debit"]) : <any>undefined;
            this.creditId = _data["creditId"];
            this.credit = _data["credit"] ? Account.fromJS(_data["credit"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.operationDefinitionId = _data["operationDefinitionId"];
            this.operationDefinition = _data["operationDefinition"] ? OperationDefinition.fromJS(_data["operationDefinition"]) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OperationDefinitionDetails {
        data = typeof data === 'object' ? data : {};
        let result = new OperationDefinitionDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["observations"] = this.observations;
        data["debitId"] = this.debitId;
        data["debit"] = this.debit ? this.debit.toJSON() : <any>undefined;
        data["creditId"] = this.creditId;
        data["credit"] = this.credit ? this.credit.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["operationDefinitionId"] = this.operationDefinitionId;
        data["operationDefinition"] = this.operationDefinition ? this.operationDefinition.toJSON() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): OperationDefinitionDetails {
        const json = this.toJSON();
        let result = new OperationDefinitionDetails();
        result.init(json);
        return result;
    }
}

export interface IOperationDefinitionDetails {
    observations: string | undefined;
    debitId: number;
    debit: Account;
    creditId: number;
    credit: Account;
    tenantId: number;
    operationDefinitionId: number;
    operationDefinition: OperationDefinition;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class OperationDefinition implements IOperationDefinition {
    name: string | undefined;
    status: State;
    documentTypeId: number;
    documentType: DocumentType;
    currencyId: number;
    currency: Currency;
    operationDefinitionDetails: OperationDefinitionDetails[] | undefined;
    tenantId: number;
    id: number;

    constructor(data?: IOperationDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.status = _data["status"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"] ? DocumentType.fromJS(_data["documentType"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            if (Array.isArray(_data["operationDefinitionDetails"])) {
                this.operationDefinitionDetails = [] as any;
                for (let item of _data["operationDefinitionDetails"])
                    this.operationDefinitionDetails.push(OperationDefinitionDetails.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OperationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new OperationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["status"] = this.status;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        if (Array.isArray(this.operationDefinitionDetails)) {
            data["operationDefinitionDetails"] = [];
            for (let item of this.operationDefinitionDetails)
                data["operationDefinitionDetails"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): OperationDefinition {
        const json = this.toJSON();
        let result = new OperationDefinition();
        result.init(json);
        return result;
    }
}

export interface IOperationDefinition {
    name: string | undefined;
    status: State;
    documentTypeId: number;
    documentType: DocumentType;
    currencyId: number;
    currency: Currency;
    operationDefinitionDetails: OperationDefinitionDetails[] | undefined;
    tenantId: number;
    id: number;
}

export class OperGenerateCateg implements IOperGenerateCateg {
    categTypeShort: string | undefined;
    categType: string | undefined;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOperGenerateCateg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categTypeShort = _data["categTypeShort"];
            this.categType = _data["categType"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OperGenerateCateg {
        data = typeof data === 'object' ? data : {};
        let result = new OperGenerateCateg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categTypeShort"] = this.categTypeShort;
        data["categType"] = this.categType;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): OperGenerateCateg {
        const json = this.toJSON();
        let result = new OperGenerateCateg();
        result.init(json);
        return result;
    }
}

export interface IOperGenerateCateg {
    categTypeShort: string | undefined;
    categType: string | undefined;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class OperGenerateTipuri implements IOperGenerateTipuri {
    tip: string | undefined;
    descriere: string | undefined;
    sfarsitLuna: boolean;
    categId: number;
    categ: OperGenerateCateg;
    state: State;
    execOrder: number;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOperGenerateTipuri) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tip = _data["tip"];
            this.descriere = _data["descriere"];
            this.sfarsitLuna = _data["sfarsitLuna"];
            this.categId = _data["categId"];
            this.categ = _data["categ"] ? OperGenerateCateg.fromJS(_data["categ"]) : <any>undefined;
            this.state = _data["state"];
            this.execOrder = _data["execOrder"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OperGenerateTipuri {
        data = typeof data === 'object' ? data : {};
        let result = new OperGenerateTipuri();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tip"] = this.tip;
        data["descriere"] = this.descriere;
        data["sfarsitLuna"] = this.sfarsitLuna;
        data["categId"] = this.categId;
        data["categ"] = this.categ ? this.categ.toJSON() : <any>undefined;
        data["state"] = this.state;
        data["execOrder"] = this.execOrder;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): OperGenerateTipuri {
        const json = this.toJSON();
        let result = new OperGenerateTipuri();
        result.init(json);
        return result;
    }
}

export interface IOperGenerateTipuri {
    tip: string | undefined;
    descriere: string | undefined;
    sfarsitLuna: boolean;
    categId: number;
    categ: OperGenerateCateg;
    state: State;
    execOrder: number;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class OperGenerate implements IOperGenerate {
    dataOperatie: moment.Moment;
    tipOperatieId: number;
    tipOperatie: OperGenerateTipuri;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOperGenerate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataOperatie = _data["dataOperatie"] ? moment(_data["dataOperatie"].toString()) : <any>undefined;
            this.tipOperatieId = _data["tipOperatieId"];
            this.tipOperatie = _data["tipOperatie"] ? OperGenerateTipuri.fromJS(_data["tipOperatie"]) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OperGenerate {
        data = typeof data === 'object' ? data : {};
        let result = new OperGenerate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataOperatie"] = this.dataOperatie ? this.dataOperatie.toISOString() : <any>undefined;
        data["tipOperatieId"] = this.tipOperatieId;
        data["tipOperatie"] = this.tipOperatie ? this.tipOperatie.toJSON() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): OperGenerate {
        const json = this.toJSON();
        let result = new OperGenerate();
        result.init(json);
        return result;
    }
}

export interface IOperGenerate {
    dataOperatie: moment.Moment;
    tipOperatieId: number;
    tipOperatie: OperGenerateTipuri;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Operation implements IOperation {
    operationDate: moment.Moment;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    closingMonth: boolean;
    operationsDetails: OperationDetails[] | undefined;
    documentTypeId: number;
    documentType: DocumentType;
    operationTypeId: number | undefined;
    operationType: OperationTypes;
    currencyId: number;
    currency: Currency;
    operationStatus: OperationStatus;
    externalOperation: boolean;
    state: State;
    operationDefinitionId: number | undefined;
    operationDefinition: OperationDefinition;
    operGenerateId: number | undefined;
    operGenerate: OperGenerate;
    operationParentId: number | undefined;
    operationParent: Operation;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.closingMonth = _data["closingMonth"];
            if (Array.isArray(_data["operationsDetails"])) {
                this.operationsDetails = [] as any;
                for (let item of _data["operationsDetails"])
                    this.operationsDetails.push(OperationDetails.fromJS(item));
            }
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"] ? DocumentType.fromJS(_data["documentType"]) : <any>undefined;
            this.operationTypeId = _data["operationTypeId"];
            this.operationType = _data["operationType"] ? OperationTypes.fromJS(_data["operationType"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.operationStatus = _data["operationStatus"];
            this.externalOperation = _data["externalOperation"];
            this.state = _data["state"];
            this.operationDefinitionId = _data["operationDefinitionId"];
            this.operationDefinition = _data["operationDefinition"] ? OperationDefinition.fromJS(_data["operationDefinition"]) : <any>undefined;
            this.operGenerateId = _data["operGenerateId"];
            this.operGenerate = _data["operGenerate"] ? OperGenerate.fromJS(_data["operGenerate"]) : <any>undefined;
            this.operationParentId = _data["operationParentId"];
            this.operationParent = _data["operationParent"] ? Operation.fromJS(_data["operationParent"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Operation {
        data = typeof data === 'object' ? data : {};
        let result = new Operation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["closingMonth"] = this.closingMonth;
        if (Array.isArray(this.operationsDetails)) {
            data["operationsDetails"] = [];
            for (let item of this.operationsDetails)
                data["operationsDetails"].push(item.toJSON());
        }
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["operationTypeId"] = this.operationTypeId;
        data["operationType"] = this.operationType ? this.operationType.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["operationStatus"] = this.operationStatus;
        data["externalOperation"] = this.externalOperation;
        data["state"] = this.state;
        data["operationDefinitionId"] = this.operationDefinitionId;
        data["operationDefinition"] = this.operationDefinition ? this.operationDefinition.toJSON() : <any>undefined;
        data["operGenerateId"] = this.operGenerateId;
        data["operGenerate"] = this.operGenerate ? this.operGenerate.toJSON() : <any>undefined;
        data["operationParentId"] = this.operationParentId;
        data["operationParent"] = this.operationParent ? this.operationParent.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Operation {
        const json = this.toJSON();
        let result = new Operation();
        result.init(json);
        return result;
    }
}

export interface IOperation {
    operationDate: moment.Moment;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    closingMonth: boolean;
    operationsDetails: OperationDetails[] | undefined;
    documentTypeId: number;
    documentType: DocumentType;
    operationTypeId: number | undefined;
    operationType: OperationTypes;
    currencyId: number;
    currency: Currency;
    operationStatus: OperationStatus;
    externalOperation: boolean;
    state: State;
    operationDefinitionId: number | undefined;
    operationDefinition: OperationDefinition;
    operGenerateId: number | undefined;
    operGenerate: OperGenerate;
    operationParentId: number | undefined;
    operationParent: Operation;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class OperationDetails implements IOperationDetails {
    value: number;
    valueCurr: number;
    vat: number;
    details: string | undefined;
    debitId: number;
    debit: Account;
    creditId: number;
    credit: Account;
    operationId: number;
    operation: Operation;
    detailNr: number | undefined;
    debitValueDeduct: number;
    creditValueDeduct: number;
    readonly debitValueNededuct: number;
    readonly creditValueNededuct: number;
    operGenerateId: number | undefined;
    operGenerate: OperGenerate;
    invoiceElementsDetailsId: number | undefined;
    invoiceElementsDetails: InvoiceElementsDetails;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsCategory: InvoiceElementsDetailsCategory;
    id: number;

    constructor(data?: IOperationDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.valueCurr = _data["valueCurr"];
            this.vat = _data["vat"];
            this.details = _data["details"];
            this.debitId = _data["debitId"];
            this.debit = _data["debit"] ? Account.fromJS(_data["debit"]) : <any>undefined;
            this.creditId = _data["creditId"];
            this.credit = _data["credit"] ? Account.fromJS(_data["credit"]) : <any>undefined;
            this.operationId = _data["operationId"];
            this.operation = _data["operation"] ? Operation.fromJS(_data["operation"]) : <any>undefined;
            this.detailNr = _data["detailNr"];
            this.debitValueDeduct = _data["debitValueDeduct"];
            this.creditValueDeduct = _data["creditValueDeduct"];
            (<any>this).debitValueNededuct = _data["debitValueNededuct"];
            (<any>this).creditValueNededuct = _data["creditValueNededuct"];
            this.operGenerateId = _data["operGenerateId"];
            this.operGenerate = _data["operGenerate"] ? OperGenerate.fromJS(_data["operGenerate"]) : <any>undefined;
            this.invoiceElementsDetailsId = _data["invoiceElementsDetailsId"];
            this.invoiceElementsDetails = _data["invoiceElementsDetails"] ? InvoiceElementsDetails.fromJS(_data["invoiceElementsDetails"]) : <any>undefined;
            this.invoiceElementsDetailsCategoryId = _data["invoiceElementsDetailsCategoryId"];
            this.invoiceElementsDetailsCategory = _data["invoiceElementsDetailsCategory"] ? InvoiceElementsDetailsCategory.fromJS(_data["invoiceElementsDetailsCategory"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OperationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new OperationDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["valueCurr"] = this.valueCurr;
        data["vat"] = this.vat;
        data["details"] = this.details;
        data["debitId"] = this.debitId;
        data["debit"] = this.debit ? this.debit.toJSON() : <any>undefined;
        data["creditId"] = this.creditId;
        data["credit"] = this.credit ? this.credit.toJSON() : <any>undefined;
        data["operationId"] = this.operationId;
        data["operation"] = this.operation ? this.operation.toJSON() : <any>undefined;
        data["detailNr"] = this.detailNr;
        data["debitValueDeduct"] = this.debitValueDeduct;
        data["creditValueDeduct"] = this.creditValueDeduct;
        data["debitValueNededuct"] = this.debitValueNededuct;
        data["creditValueNededuct"] = this.creditValueNededuct;
        data["operGenerateId"] = this.operGenerateId;
        data["operGenerate"] = this.operGenerate ? this.operGenerate.toJSON() : <any>undefined;
        data["invoiceElementsDetailsId"] = this.invoiceElementsDetailsId;
        data["invoiceElementsDetails"] = this.invoiceElementsDetails ? this.invoiceElementsDetails.toJSON() : <any>undefined;
        data["invoiceElementsDetailsCategoryId"] = this.invoiceElementsDetailsCategoryId;
        data["invoiceElementsDetailsCategory"] = this.invoiceElementsDetailsCategory ? this.invoiceElementsDetailsCategory.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): OperationDetails {
        const json = this.toJSON();
        let result = new OperationDetails();
        result.init(json);
        return result;
    }
}

export interface IOperationDetails {
    value: number;
    valueCurr: number;
    vat: number;
    details: string | undefined;
    debitId: number;
    debit: Account;
    creditId: number;
    credit: Account;
    operationId: number;
    operation: Operation;
    detailNr: number | undefined;
    debitValueDeduct: number;
    creditValueDeduct: number;
    debitValueNededuct: number;
    creditValueNededuct: number;
    operGenerateId: number | undefined;
    operGenerate: OperGenerate;
    invoiceElementsDetailsId: number | undefined;
    invoiceElementsDetails: InvoiceElementsDetails;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsCategory: InvoiceElementsDetailsCategory;
    id: number;
}

export class InvoiceDetails implements IInvoiceDetails {
    element: string | undefined;
    quantity: number;
    value: number;
    vat: number;
    procVAT: number;
    cotaTVA_Id: number | undefined;
    cotaTVA: CotaTVA;
    durationInMonths: number | undefined;
    state: State;
    invoiceElementsDetailsId: number;
    invoiceElementsDetails: InvoiceElementsDetails;
    debitorAccountId: number | undefined;
    debitorAccount: Account;
    creditorAccountId: number | undefined;
    creditorAccount: Account;
    invoicesId: number;
    invoices: Invoices;
    contaOperationDetailId: number | undefined;
    contaOperationDetail: OperationDetails;
    usedInGest: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    valoareTotalaDetaliu: number | undefined;
    dataStartAmortizare: moment.Moment | undefined;
    id: number;

    constructor(data?: IInvoiceDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.element = _data["element"];
            this.quantity = _data["quantity"];
            this.value = _data["value"];
            this.vat = _data["vat"];
            this.procVAT = _data["procVAT"];
            this.cotaTVA_Id = _data["cotaTVA_Id"];
            this.cotaTVA = _data["cotaTVA"] ? CotaTVA.fromJS(_data["cotaTVA"]) : <any>undefined;
            this.durationInMonths = _data["durationInMonths"];
            this.state = _data["state"];
            this.invoiceElementsDetailsId = _data["invoiceElementsDetailsId"];
            this.invoiceElementsDetails = _data["invoiceElementsDetails"] ? InvoiceElementsDetails.fromJS(_data["invoiceElementsDetails"]) : <any>undefined;
            this.debitorAccountId = _data["debitorAccountId"];
            this.debitorAccount = _data["debitorAccount"] ? Account.fromJS(_data["debitorAccount"]) : <any>undefined;
            this.creditorAccountId = _data["creditorAccountId"];
            this.creditorAccount = _data["creditorAccount"] ? Account.fromJS(_data["creditorAccount"]) : <any>undefined;
            this.invoicesId = _data["invoicesId"];
            this.invoices = _data["invoices"] ? Invoices.fromJS(_data["invoices"]) : <any>undefined;
            this.contaOperationDetailId = _data["contaOperationDetailId"];
            this.contaOperationDetail = _data["contaOperationDetail"] ? OperationDetails.fromJS(_data["contaOperationDetail"]) : <any>undefined;
            this.usedInGest = _data["usedInGest"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.valoareTotalaDetaliu = _data["valoareTotalaDetaliu"];
            this.dataStartAmortizare = _data["dataStartAmortizare"] ? moment(_data["dataStartAmortizare"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InvoiceDetails {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["element"] = this.element;
        data["quantity"] = this.quantity;
        data["value"] = this.value;
        data["vat"] = this.vat;
        data["procVAT"] = this.procVAT;
        data["cotaTVA_Id"] = this.cotaTVA_Id;
        data["cotaTVA"] = this.cotaTVA ? this.cotaTVA.toJSON() : <any>undefined;
        data["durationInMonths"] = this.durationInMonths;
        data["state"] = this.state;
        data["invoiceElementsDetailsId"] = this.invoiceElementsDetailsId;
        data["invoiceElementsDetails"] = this.invoiceElementsDetails ? this.invoiceElementsDetails.toJSON() : <any>undefined;
        data["debitorAccountId"] = this.debitorAccountId;
        data["debitorAccount"] = this.debitorAccount ? this.debitorAccount.toJSON() : <any>undefined;
        data["creditorAccountId"] = this.creditorAccountId;
        data["creditorAccount"] = this.creditorAccount ? this.creditorAccount.toJSON() : <any>undefined;
        data["invoicesId"] = this.invoicesId;
        data["invoices"] = this.invoices ? this.invoices.toJSON() : <any>undefined;
        data["contaOperationDetailId"] = this.contaOperationDetailId;
        data["contaOperationDetail"] = this.contaOperationDetail ? this.contaOperationDetail.toJSON() : <any>undefined;
        data["usedInGest"] = this.usedInGest;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["valoareTotalaDetaliu"] = this.valoareTotalaDetaliu;
        data["dataStartAmortizare"] = this.dataStartAmortizare ? this.dataStartAmortizare.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): InvoiceDetails {
        const json = this.toJSON();
        let result = new InvoiceDetails();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetails {
    element: string | undefined;
    quantity: number;
    value: number;
    vat: number;
    procVAT: number;
    cotaTVA_Id: number | undefined;
    cotaTVA: CotaTVA;
    durationInMonths: number | undefined;
    state: State;
    invoiceElementsDetailsId: number;
    invoiceElementsDetails: InvoiceElementsDetails;
    debitorAccountId: number | undefined;
    debitorAccount: Account;
    creditorAccountId: number | undefined;
    creditorAccount: Account;
    invoicesId: number;
    invoices: Invoices;
    contaOperationDetailId: number | undefined;
    contaOperationDetail: OperationDetails;
    usedInGest: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    valoareTotalaDetaliu: number | undefined;
    dataStartAmortizare: moment.Moment | undefined;
    id: number;
}

export enum ThirdPartyQuality {
    _0 = 0,
    _1 = 1,
}

export enum ContractsType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum ContractsPaymentInstalmentFreq {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ContractsInstalments implements IContractsInstalments {
    value: number;
    vat: number;
    instalmentDate: moment.Moment;
    currency: Currency;
    contracts: Contracts;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IContractsInstalments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.vat = _data["vat"];
            this.instalmentDate = _data["instalmentDate"] ? moment(_data["instalmentDate"].toString()) : <any>undefined;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.contracts = _data["contracts"] ? Contracts.fromJS(_data["contracts"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractsInstalments {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsInstalments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["vat"] = this.vat;
        data["instalmentDate"] = this.instalmentDate ? this.instalmentDate.toISOString() : <any>undefined;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["contracts"] = this.contracts ? this.contracts.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractsInstalments {
        const json = this.toJSON();
        let result = new ContractsInstalments();
        result.init(json);
        return result;
    }
}

export interface IContractsInstalments {
    value: number;
    vat: number;
    instalmentDate: moment.Moment;
    currency: Currency;
    contracts: Contracts;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Departament implements IDepartament {
    name: string | undefined;
    state: State;
    idExtern: number | undefined;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDepartament) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.state = _data["state"];
            this.idExtern = _data["idExtern"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Departament {
        data = typeof data === 'object' ? data : {};
        let result = new Departament();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["state"] = this.state;
        data["idExtern"] = this.idExtern;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Departament {
        const json = this.toJSON();
        let result = new Departament();
        result.init(json);
        return result;
    }
}

export interface IDepartament {
    name: string | undefined;
    state: State;
    idExtern: number | undefined;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum Contract_State {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class Contracts_State implements IContracts_State {
    contractsId: number;
    contracts: Contracts;
    operationDate: moment.Moment;
    comentarii: string | undefined;
    contract_State: Contract_State;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IContracts_State) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractsId = _data["contractsId"];
            this.contracts = _data["contracts"] ? Contracts.fromJS(_data["contracts"]) : <any>undefined;
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.comentarii = _data["comentarii"];
            this.contract_State = _data["contract_State"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Contracts_State {
        data = typeof data === 'object' ? data : {};
        let result = new Contracts_State();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractsId"] = this.contractsId;
        data["contracts"] = this.contracts ? this.contracts.toJSON() : <any>undefined;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["comentarii"] = this.comentarii;
        data["contract_State"] = this.contract_State;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Contracts_State {
        const json = this.toJSON();
        let result = new Contracts_State();
        result.init(json);
        return result;
    }
}

export interface IContracts_State {
    contractsId: number;
    contracts: Contracts;
    operationDate: moment.Moment;
    comentarii: string | undefined;
    contract_State: Contract_State;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ContractsCategory implements IContractsCategory {
    categoryName: string | undefined;
    state: State;
    tenantId: number;
    contract: Contracts;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IContractsCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryName = _data["categoryName"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.contract = _data["contract"] ? Contracts.fromJS(_data["contract"]) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractsCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryName"] = this.categoryName;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractsCategory {
        const json = this.toJSON();
        let result = new ContractsCategory();
        result.init(json);
        return result;
    }
}

export interface IContractsCategory {
    categoryName: string | undefined;
    state: State;
    tenantId: number;
    contract: Contracts;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Contracts implements IContracts {
    contractObject: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    value: number | undefined;
    firstInstalmentDate: moment.Moment;
    thirdPartyContractNr: string | undefined;
    thirdPartyContractDate: moment.Moment;
    contractNr: string | undefined;
    contractDate: moment.Moment;
    cotaTVA_Id: number | undefined;
    cotaTVA: CotaTVA;
    monthlyValue: number | undefined;
    isMonthlyValue: boolean;
    contractsType: ContractsType;
    currency_Id: number | undefined;
    currency: Currency;
    contractsPaymentInstalmentFreq: ContractsPaymentInstalmentFreq;
    thirdPartyId: number | undefined;
    thirdParty: Person;
    thirdPartyQuality: ThirdPartyQuality;
    contractsInstalments: ContractsInstalments[] | undefined;
    masterContract: Contracts;
    aditionalContracts: Contracts[] | undefined;
    state: State;
    departamentId: number | undefined;
    departament: Departament;
    contractsStateList: Contracts_State[] | undefined;
    getContractState: Contract_State;
    contractsCategory: ContractsCategory;
    contractsCategoryId: number | undefined;
    masterContractId: number | undefined;
    prelungireAutomata: boolean;
    nrLuniPrelungire: number | undefined;
    fileDocId: number;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IContracts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractObject = _data["contractObject"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.firstInstalmentDate = _data["firstInstalmentDate"] ? moment(_data["firstInstalmentDate"].toString()) : <any>undefined;
            this.thirdPartyContractNr = _data["thirdPartyContractNr"];
            this.thirdPartyContractDate = _data["thirdPartyContractDate"] ? moment(_data["thirdPartyContractDate"].toString()) : <any>undefined;
            this.contractNr = _data["contractNr"];
            this.contractDate = _data["contractDate"] ? moment(_data["contractDate"].toString()) : <any>undefined;
            this.cotaTVA_Id = _data["cotaTVA_Id"];
            this.cotaTVA = _data["cotaTVA"] ? CotaTVA.fromJS(_data["cotaTVA"]) : <any>undefined;
            this.monthlyValue = _data["monthlyValue"];
            this.isMonthlyValue = _data["isMonthlyValue"];
            this.contractsType = _data["contractsType"];
            this.currency_Id = _data["currency_Id"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.contractsPaymentInstalmentFreq = _data["contractsPaymentInstalmentFreq"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdParty = _data["thirdParty"] ? Person.fromJS(_data["thirdParty"]) : <any>undefined;
            this.thirdPartyQuality = _data["thirdPartyQuality"];
            if (Array.isArray(_data["contractsInstalments"])) {
                this.contractsInstalments = [] as any;
                for (let item of _data["contractsInstalments"])
                    this.contractsInstalments.push(ContractsInstalments.fromJS(item));
            }
            this.masterContract = _data["masterContract"] ? Contracts.fromJS(_data["masterContract"]) : <any>undefined;
            if (Array.isArray(_data["aditionalContracts"])) {
                this.aditionalContracts = [] as any;
                for (let item of _data["aditionalContracts"])
                    this.aditionalContracts.push(Contracts.fromJS(item));
            }
            this.state = _data["state"];
            this.departamentId = _data["departamentId"];
            this.departament = _data["departament"] ? Departament.fromJS(_data["departament"]) : <any>undefined;
            if (Array.isArray(_data["contractsStateList"])) {
                this.contractsStateList = [] as any;
                for (let item of _data["contractsStateList"])
                    this.contractsStateList.push(Contracts_State.fromJS(item));
            }
            this.getContractState = _data["getContractState"];
            this.contractsCategory = _data["contractsCategory"] ? ContractsCategory.fromJS(_data["contractsCategory"]) : <any>undefined;
            this.contractsCategoryId = _data["contractsCategoryId"];
            this.masterContractId = _data["masterContractId"];
            this.prelungireAutomata = _data["prelungireAutomata"];
            this.nrLuniPrelungire = _data["nrLuniPrelungire"];
            this.fileDocId = _data["fileDocId"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Contracts {
        data = typeof data === 'object' ? data : {};
        let result = new Contracts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractObject"] = this.contractObject;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["firstInstalmentDate"] = this.firstInstalmentDate ? this.firstInstalmentDate.toISOString() : <any>undefined;
        data["thirdPartyContractNr"] = this.thirdPartyContractNr;
        data["thirdPartyContractDate"] = this.thirdPartyContractDate ? this.thirdPartyContractDate.toISOString() : <any>undefined;
        data["contractNr"] = this.contractNr;
        data["contractDate"] = this.contractDate ? this.contractDate.toISOString() : <any>undefined;
        data["cotaTVA_Id"] = this.cotaTVA_Id;
        data["cotaTVA"] = this.cotaTVA ? this.cotaTVA.toJSON() : <any>undefined;
        data["monthlyValue"] = this.monthlyValue;
        data["isMonthlyValue"] = this.isMonthlyValue;
        data["contractsType"] = this.contractsType;
        data["currency_Id"] = this.currency_Id;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["contractsPaymentInstalmentFreq"] = this.contractsPaymentInstalmentFreq;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdParty"] = this.thirdParty ? this.thirdParty.toJSON() : <any>undefined;
        data["thirdPartyQuality"] = this.thirdPartyQuality;
        if (Array.isArray(this.contractsInstalments)) {
            data["contractsInstalments"] = [];
            for (let item of this.contractsInstalments)
                data["contractsInstalments"].push(item.toJSON());
        }
        data["masterContract"] = this.masterContract ? this.masterContract.toJSON() : <any>undefined;
        if (Array.isArray(this.aditionalContracts)) {
            data["aditionalContracts"] = [];
            for (let item of this.aditionalContracts)
                data["aditionalContracts"].push(item.toJSON());
        }
        data["state"] = this.state;
        data["departamentId"] = this.departamentId;
        data["departament"] = this.departament ? this.departament.toJSON() : <any>undefined;
        if (Array.isArray(this.contractsStateList)) {
            data["contractsStateList"] = [];
            for (let item of this.contractsStateList)
                data["contractsStateList"].push(item.toJSON());
        }
        data["getContractState"] = this.getContractState;
        data["contractsCategory"] = this.contractsCategory ? this.contractsCategory.toJSON() : <any>undefined;
        data["contractsCategoryId"] = this.contractsCategoryId;
        data["masterContractId"] = this.masterContractId;
        data["prelungireAutomata"] = this.prelungireAutomata;
        data["nrLuniPrelungire"] = this.nrLuniPrelungire;
        data["fileDocId"] = this.fileDocId;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Contracts {
        const json = this.toJSON();
        let result = new Contracts();
        result.init(json);
        return result;
    }
}

export interface IContracts {
    contractObject: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    value: number | undefined;
    firstInstalmentDate: moment.Moment;
    thirdPartyContractNr: string | undefined;
    thirdPartyContractDate: moment.Moment;
    contractNr: string | undefined;
    contractDate: moment.Moment;
    cotaTVA_Id: number | undefined;
    cotaTVA: CotaTVA;
    monthlyValue: number | undefined;
    isMonthlyValue: boolean;
    contractsType: ContractsType;
    currency_Id: number | undefined;
    currency: Currency;
    contractsPaymentInstalmentFreq: ContractsPaymentInstalmentFreq;
    thirdPartyId: number | undefined;
    thirdParty: Person;
    thirdPartyQuality: ThirdPartyQuality;
    contractsInstalments: ContractsInstalments[] | undefined;
    masterContract: Contracts;
    aditionalContracts: Contracts[] | undefined;
    state: State;
    departamentId: number | undefined;
    departament: Departament;
    contractsStateList: Contracts_State[] | undefined;
    getContractState: Contract_State;
    contractsCategory: ContractsCategory;
    contractsCategoryId: number | undefined;
    masterContractId: number | undefined;
    prelungireAutomata: boolean;
    nrLuniPrelungire: number | undefined;
    fileDocId: number;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum DecontType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum DiurnaType {
    _0 = 0,
    _1 = 1,
}

export enum ScopDeplasareType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class DiurnaLegala implements IDiurnaLegala {
    countryId: number;
    country: Country;
    currencyId: number;
    currency: Currency;
    value: number;
    dataValabilitate: moment.Moment;
    diurnaType: DiurnaType;
    scopDeplasareType: ScopDeplasareType;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDiurnaLegala) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.value = _data["value"];
            this.dataValabilitate = _data["dataValabilitate"] ? moment(_data["dataValabilitate"].toString()) : <any>undefined;
            this.diurnaType = _data["diurnaType"];
            this.scopDeplasareType = _data["scopDeplasareType"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DiurnaLegala {
        data = typeof data === 'object' ? data : {};
        let result = new DiurnaLegala();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["value"] = this.value;
        data["dataValabilitate"] = this.dataValabilitate ? this.dataValabilitate.toISOString() : <any>undefined;
        data["diurnaType"] = this.diurnaType;
        data["scopDeplasareType"] = this.scopDeplasareType;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): DiurnaLegala {
        const json = this.toJSON();
        let result = new DiurnaLegala();
        result.init(json);
        return result;
    }
}

export interface IDiurnaLegala {
    countryId: number;
    country: Country;
    currencyId: number;
    currency: Currency;
    value: number;
    dataValabilitate: moment.Moment;
    diurnaType: DiurnaType;
    scopDeplasareType: ScopDeplasareType;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Decont implements IDecont {
    currencyId: number;
    currency: Currency;
    decontDate: moment.Moment;
    description: string | undefined;
    decontNumber: number;
    dateStart: moment.Moment | undefined;
    dateEnd: moment.Moment | undefined;
    diurnaLegalaValue: number | undefined;
    diurnaZi: number | undefined;
    diurnaImpozabila: number | undefined;
    nrZile: number | undefined;
    totalDiurnaAcordata: number;
    totalDiurnaImpozabila: number;
    decontType: DecontType;
    thirdPartyId: number | undefined;
    thirdParty: Person;
    diurnaLegalaId: number | undefined;
    diurnaLegala: DiurnaLegala;
    state: State;
    invoiceDetails: InvoiceDetails[] | undefined;
    tenantId: number;
    scopDeplasareType: ScopDeplasareType;
    documentTypeId: number | undefined;
    documentType: DocumentType;
    fileDocId: number;
    totalDiurnaAcordataFileDoc: number;
    operationId: number | undefined;
    operation: Operation;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDecont) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.decontDate = _data["decontDate"] ? moment(_data["decontDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.decontNumber = _data["decontNumber"];
            this.dateStart = _data["dateStart"] ? moment(_data["dateStart"].toString()) : <any>undefined;
            this.dateEnd = _data["dateEnd"] ? moment(_data["dateEnd"].toString()) : <any>undefined;
            this.diurnaLegalaValue = _data["diurnaLegalaValue"];
            this.diurnaZi = _data["diurnaZi"];
            this.diurnaImpozabila = _data["diurnaImpozabila"];
            this.nrZile = _data["nrZile"];
            this.totalDiurnaAcordata = _data["totalDiurnaAcordata"];
            this.totalDiurnaImpozabila = _data["totalDiurnaImpozabila"];
            this.decontType = _data["decontType"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdParty = _data["thirdParty"] ? Person.fromJS(_data["thirdParty"]) : <any>undefined;
            this.diurnaLegalaId = _data["diurnaLegalaId"];
            this.diurnaLegala = _data["diurnaLegala"] ? DiurnaLegala.fromJS(_data["diurnaLegala"]) : <any>undefined;
            this.state = _data["state"];
            if (Array.isArray(_data["invoiceDetails"])) {
                this.invoiceDetails = [] as any;
                for (let item of _data["invoiceDetails"])
                    this.invoiceDetails.push(InvoiceDetails.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.scopDeplasareType = _data["scopDeplasareType"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"] ? DocumentType.fromJS(_data["documentType"]) : <any>undefined;
            this.fileDocId = _data["fileDocId"];
            this.totalDiurnaAcordataFileDoc = _data["totalDiurnaAcordataFileDoc"];
            this.operationId = _data["operationId"];
            this.operation = _data["operation"] ? Operation.fromJS(_data["operation"]) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Decont {
        data = typeof data === 'object' ? data : {};
        let result = new Decont();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["decontDate"] = this.decontDate ? this.decontDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["decontNumber"] = this.decontNumber;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        data["dateEnd"] = this.dateEnd ? this.dateEnd.toISOString() : <any>undefined;
        data["diurnaLegalaValue"] = this.diurnaLegalaValue;
        data["diurnaZi"] = this.diurnaZi;
        data["diurnaImpozabila"] = this.diurnaImpozabila;
        data["nrZile"] = this.nrZile;
        data["totalDiurnaAcordata"] = this.totalDiurnaAcordata;
        data["totalDiurnaImpozabila"] = this.totalDiurnaImpozabila;
        data["decontType"] = this.decontType;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdParty"] = this.thirdParty ? this.thirdParty.toJSON() : <any>undefined;
        data["diurnaLegalaId"] = this.diurnaLegalaId;
        data["diurnaLegala"] = this.diurnaLegala ? this.diurnaLegala.toJSON() : <any>undefined;
        data["state"] = this.state;
        if (Array.isArray(this.invoiceDetails)) {
            data["invoiceDetails"] = [];
            for (let item of this.invoiceDetails)
                data["invoiceDetails"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["scopDeplasareType"] = this.scopDeplasareType;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["fileDocId"] = this.fileDocId;
        data["totalDiurnaAcordataFileDoc"] = this.totalDiurnaAcordataFileDoc;
        data["operationId"] = this.operationId;
        data["operation"] = this.operation ? this.operation.toJSON() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Decont {
        const json = this.toJSON();
        let result = new Decont();
        result.init(json);
        return result;
    }
}

export interface IDecont {
    currencyId: number;
    currency: Currency;
    decontDate: moment.Moment;
    description: string | undefined;
    decontNumber: number;
    dateStart: moment.Moment | undefined;
    dateEnd: moment.Moment | undefined;
    diurnaLegalaValue: number | undefined;
    diurnaZi: number | undefined;
    diurnaImpozabila: number | undefined;
    nrZile: number | undefined;
    totalDiurnaAcordata: number;
    totalDiurnaImpozabila: number;
    decontType: DecontType;
    thirdPartyId: number | undefined;
    thirdParty: Person;
    diurnaLegalaId: number | undefined;
    diurnaLegala: DiurnaLegala;
    state: State;
    invoiceDetails: InvoiceDetails[] | undefined;
    tenantId: number;
    scopDeplasareType: ScopDeplasareType;
    documentTypeId: number | undefined;
    documentType: DocumentType;
    fileDocId: number;
    totalDiurnaAcordataFileDoc: number;
    operationId: number | undefined;
    operation: Operation;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum OperationType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class Disposition implements IDisposition {
    thirdPartyId: number | undefined;
    thirdParty: Person;
    operationType: OperationType;
    dispositionNumber: number;
    dispositionDate: moment.Moment;
    value: number;
    invoiceElementsDetailsId: number | undefined;
    invoiceElementsDetails: InvoiceElementsDetails;
    currencyId: number;
    currency: Currency;
    description: string | undefined;
    documentTypeId: number | undefined;
    documentType: DocumentType;
    documentNumber: string | undefined;
    documentDate: moment.Moment | undefined;
    dispositionInvoices: DispositionInvoice[] | undefined;
    sumOper: number;
    bankAccountId: number | undefined;
    bankAccount: BankAccount;
    operationId: number | undefined;
    operation: Operation;
    tenantId: number;
    state: State;
    nrChitanta: number | undefined;
    numePrenume: string | undefined;
    tipDoc: string | undefined;
    actIdentitate: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDisposition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdParty = _data["thirdParty"] ? Person.fromJS(_data["thirdParty"]) : <any>undefined;
            this.operationType = _data["operationType"];
            this.dispositionNumber = _data["dispositionNumber"];
            this.dispositionDate = _data["dispositionDate"] ? moment(_data["dispositionDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.invoiceElementsDetailsId = _data["invoiceElementsDetailsId"];
            this.invoiceElementsDetails = _data["invoiceElementsDetails"] ? InvoiceElementsDetails.fromJS(_data["invoiceElementsDetails"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.description = _data["description"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"] ? DocumentType.fromJS(_data["documentType"]) : <any>undefined;
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["dispositionInvoices"])) {
                this.dispositionInvoices = [] as any;
                for (let item of _data["dispositionInvoices"])
                    this.dispositionInvoices.push(DispositionInvoice.fromJS(item));
            }
            this.sumOper = _data["sumOper"];
            this.bankAccountId = _data["bankAccountId"];
            this.bankAccount = _data["bankAccount"] ? BankAccount.fromJS(_data["bankAccount"]) : <any>undefined;
            this.operationId = _data["operationId"];
            this.operation = _data["operation"] ? Operation.fromJS(_data["operation"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.state = _data["state"];
            this.nrChitanta = _data["nrChitanta"];
            this.numePrenume = _data["numePrenume"];
            this.tipDoc = _data["tipDoc"];
            this.actIdentitate = _data["actIdentitate"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Disposition {
        data = typeof data === 'object' ? data : {};
        let result = new Disposition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdParty"] = this.thirdParty ? this.thirdParty.toJSON() : <any>undefined;
        data["operationType"] = this.operationType;
        data["dispositionNumber"] = this.dispositionNumber;
        data["dispositionDate"] = this.dispositionDate ? this.dispositionDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["invoiceElementsDetailsId"] = this.invoiceElementsDetailsId;
        data["invoiceElementsDetails"] = this.invoiceElementsDetails ? this.invoiceElementsDetails.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        if (Array.isArray(this.dispositionInvoices)) {
            data["dispositionInvoices"] = [];
            for (let item of this.dispositionInvoices)
                data["dispositionInvoices"].push(item.toJSON());
        }
        data["sumOper"] = this.sumOper;
        data["bankAccountId"] = this.bankAccountId;
        data["bankAccount"] = this.bankAccount ? this.bankAccount.toJSON() : <any>undefined;
        data["operationId"] = this.operationId;
        data["operation"] = this.operation ? this.operation.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["state"] = this.state;
        data["nrChitanta"] = this.nrChitanta;
        data["numePrenume"] = this.numePrenume;
        data["tipDoc"] = this.tipDoc;
        data["actIdentitate"] = this.actIdentitate;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Disposition {
        const json = this.toJSON();
        let result = new Disposition();
        result.init(json);
        return result;
    }
}

export interface IDisposition {
    thirdPartyId: number | undefined;
    thirdParty: Person;
    operationType: OperationType;
    dispositionNumber: number;
    dispositionDate: moment.Moment;
    value: number;
    invoiceElementsDetailsId: number | undefined;
    invoiceElementsDetails: InvoiceElementsDetails;
    currencyId: number;
    currency: Currency;
    description: string | undefined;
    documentTypeId: number | undefined;
    documentType: DocumentType;
    documentNumber: string | undefined;
    documentDate: moment.Moment | undefined;
    dispositionInvoices: DispositionInvoice[] | undefined;
    sumOper: number;
    bankAccountId: number | undefined;
    bankAccount: BankAccount;
    operationId: number | undefined;
    operation: Operation;
    tenantId: number;
    state: State;
    nrChitanta: number | undefined;
    numePrenume: string | undefined;
    tipDoc: string | undefined;
    actIdentitate: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DispositionInvoice implements IDispositionInvoice {
    dispositionId: number;
    disposition: Disposition;
    invoiceId: number;
    invoice: Invoices;
    payedValue: number;
    operationDate: moment.Moment;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDispositionInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispositionId = _data["dispositionId"];
            this.disposition = _data["disposition"] ? Disposition.fromJS(_data["disposition"]) : <any>undefined;
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoices.fromJS(_data["invoice"]) : <any>undefined;
            this.payedValue = _data["payedValue"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DispositionInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new DispositionInvoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispositionId"] = this.dispositionId;
        data["disposition"] = this.disposition ? this.disposition.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["payedValue"] = this.payedValue;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): DispositionInvoice {
        const json = this.toJSON();
        let result = new DispositionInvoice();
        result.init(json);
        return result;
    }
}

export interface IDispositionInvoice {
    dispositionId: number;
    disposition: Disposition;
    invoiceId: number;
    invoice: Invoices;
    payedValue: number;
    operationDate: moment.Moment;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ForeignOperation implements IForeignOperation {
    bankAccountId: number;
    bankAccount: BankAccount;
    documentDate: moment.Moment;
    documentNumber: string | undefined;
    operationDate: moment.Moment;
    foreignOperationsDetails: ForeignOperationsDetails[] | undefined;
    documentTypeId: number;
    documentType: DocumentType;
    currencyId: number;
    currency: Currency;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IForeignOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankAccountId = _data["bankAccountId"];
            this.bankAccount = _data["bankAccount"] ? BankAccount.fromJS(_data["bankAccount"]) : <any>undefined;
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.documentNumber = _data["documentNumber"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["foreignOperationsDetails"])) {
                this.foreignOperationsDetails = [] as any;
                for (let item of _data["foreignOperationsDetails"])
                    this.foreignOperationsDetails.push(ForeignOperationsDetails.fromJS(item));
            }
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"] ? DocumentType.fromJS(_data["documentType"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ForeignOperation {
        data = typeof data === 'object' ? data : {};
        let result = new ForeignOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["bankAccount"] = this.bankAccount ? this.bankAccount.toJSON() : <any>undefined;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["documentNumber"] = this.documentNumber;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.foreignOperationsDetails)) {
            data["foreignOperationsDetails"] = [];
            for (let item of this.foreignOperationsDetails)
                data["foreignOperationsDetails"].push(item.toJSON());
        }
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): ForeignOperation {
        const json = this.toJSON();
        let result = new ForeignOperation();
        result.init(json);
        return result;
    }
}

export interface IForeignOperation {
    bankAccountId: number;
    bankAccount: BankAccount;
    documentDate: moment.Moment;
    documentNumber: string | undefined;
    operationDate: moment.Moment;
    foreignOperationsDetails: ForeignOperationsDetails[] | undefined;
    documentTypeId: number;
    documentType: DocumentType;
    currencyId: number;
    currency: Currency;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ForeignOperationsAccounting implements IForeignOperationsAccounting {
    details: string | undefined;
    value: number;
    valueCurr: number;
    debitId: number | undefined;
    debit: Account;
    creditId: number | undefined;
    credit: Account;
    fgnOperationsDetailId: number;
    fgnOperationsDetail: ForeignOperationsDetails;
    operationsDetailId: number | undefined;
    operationsDetail: OperationDetails;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IForeignOperationsAccounting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"];
            this.value = _data["value"];
            this.valueCurr = _data["valueCurr"];
            this.debitId = _data["debitId"];
            this.debit = _data["debit"] ? Account.fromJS(_data["debit"]) : <any>undefined;
            this.creditId = _data["creditId"];
            this.credit = _data["credit"] ? Account.fromJS(_data["credit"]) : <any>undefined;
            this.fgnOperationsDetailId = _data["fgnOperationsDetailId"];
            this.fgnOperationsDetail = _data["fgnOperationsDetail"] ? ForeignOperationsDetails.fromJS(_data["fgnOperationsDetail"]) : <any>undefined;
            this.operationsDetailId = _data["operationsDetailId"];
            this.operationsDetail = _data["operationsDetail"] ? OperationDetails.fromJS(_data["operationsDetail"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ForeignOperationsAccounting {
        data = typeof data === 'object' ? data : {};
        let result = new ForeignOperationsAccounting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details;
        data["value"] = this.value;
        data["valueCurr"] = this.valueCurr;
        data["debitId"] = this.debitId;
        data["debit"] = this.debit ? this.debit.toJSON() : <any>undefined;
        data["creditId"] = this.creditId;
        data["credit"] = this.credit ? this.credit.toJSON() : <any>undefined;
        data["fgnOperationsDetailId"] = this.fgnOperationsDetailId;
        data["fgnOperationsDetail"] = this.fgnOperationsDetail ? this.fgnOperationsDetail.toJSON() : <any>undefined;
        data["operationsDetailId"] = this.operationsDetailId;
        data["operationsDetail"] = this.operationsDetail ? this.operationsDetail.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): ForeignOperationsAccounting {
        const json = this.toJSON();
        let result = new ForeignOperationsAccounting();
        result.init(json);
        return result;
    }
}

export interface IForeignOperationsAccounting {
    details: string | undefined;
    value: number;
    valueCurr: number;
    debitId: number | undefined;
    debit: Account;
    creditId: number | undefined;
    credit: Account;
    fgnOperationsDetailId: number;
    fgnOperationsDetail: ForeignOperationsDetails;
    operationsDetailId: number | undefined;
    operationsDetail: OperationDetails;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ForeignOperationsDetails implements IForeignOperationsDetails {
    documentTypeId: number;
    documentType: DocumentType;
    documentDate: moment.Moment;
    documentNumber: string | undefined;
    originalDetails: string | undefined;
    value: number;
    valueCurr: number;
    foreignOperationId: number;
    foreignOperation: ForeignOperation;
    paymentOrderId: number | undefined;
    paymentOrder: PaymentOrders;
    operationsAccounting: ForeignOperationsAccounting[] | undefined;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IForeignOperationsDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"] ? DocumentType.fromJS(_data["documentType"]) : <any>undefined;
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.documentNumber = _data["documentNumber"];
            this.originalDetails = _data["originalDetails"];
            this.value = _data["value"];
            this.valueCurr = _data["valueCurr"];
            this.foreignOperationId = _data["foreignOperationId"];
            this.foreignOperation = _data["foreignOperation"] ? ForeignOperation.fromJS(_data["foreignOperation"]) : <any>undefined;
            this.paymentOrderId = _data["paymentOrderId"];
            this.paymentOrder = _data["paymentOrder"] ? PaymentOrders.fromJS(_data["paymentOrder"]) : <any>undefined;
            if (Array.isArray(_data["operationsAccounting"])) {
                this.operationsAccounting = [] as any;
                for (let item of _data["operationsAccounting"])
                    this.operationsAccounting.push(ForeignOperationsAccounting.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ForeignOperationsDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ForeignOperationsDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["documentNumber"] = this.documentNumber;
        data["originalDetails"] = this.originalDetails;
        data["value"] = this.value;
        data["valueCurr"] = this.valueCurr;
        data["foreignOperationId"] = this.foreignOperationId;
        data["foreignOperation"] = this.foreignOperation ? this.foreignOperation.toJSON() : <any>undefined;
        data["paymentOrderId"] = this.paymentOrderId;
        data["paymentOrder"] = this.paymentOrder ? this.paymentOrder.toJSON() : <any>undefined;
        if (Array.isArray(this.operationsAccounting)) {
            data["operationsAccounting"] = [];
            for (let item of this.operationsAccounting)
                data["operationsAccounting"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): ForeignOperationsDetails {
        const json = this.toJSON();
        let result = new ForeignOperationsDetails();
        result.init(json);
        return result;
    }
}

export interface IForeignOperationsDetails {
    documentTypeId: number;
    documentType: DocumentType;
    documentDate: moment.Moment;
    documentNumber: string | undefined;
    originalDetails: string | undefined;
    value: number;
    valueCurr: number;
    foreignOperationId: number;
    foreignOperation: ForeignOperation;
    paymentOrderId: number | undefined;
    paymentOrder: PaymentOrders;
    operationsAccounting: ForeignOperationsAccounting[] | undefined;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PaymentOrders implements IPaymentOrders {
    orderNr: number;
    orderDate: moment.Moment;
    value: number;
    writtenValue: string | undefined;
    payerBankAccountId: number;
    payerBankAccount: BankAccount;
    beneficiaryId: number;
    beneficiary: Person;
    benefAccountId: number;
    benefAccount: BankAccount;
    paymentDetails: string | undefined;
    paymentOrderInvoices: PaymentOrderInvoice[] | undefined;
    currencyId: number;
    currency: Currency;
    fgnOperDetailId: number | undefined;
    fgnOperationsDetail: ForeignOperationsDetails;
    div: number | undefined;
    status: OperationStatus;
    statusDate: moment.Moment;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPaymentOrders) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNr = _data["orderNr"];
            this.orderDate = _data["orderDate"] ? moment(_data["orderDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.writtenValue = _data["writtenValue"];
            this.payerBankAccountId = _data["payerBankAccountId"];
            this.payerBankAccount = _data["payerBankAccount"] ? BankAccount.fromJS(_data["payerBankAccount"]) : <any>undefined;
            this.beneficiaryId = _data["beneficiaryId"];
            this.beneficiary = _data["beneficiary"] ? Person.fromJS(_data["beneficiary"]) : <any>undefined;
            this.benefAccountId = _data["benefAccountId"];
            this.benefAccount = _data["benefAccount"] ? BankAccount.fromJS(_data["benefAccount"]) : <any>undefined;
            this.paymentDetails = _data["paymentDetails"];
            if (Array.isArray(_data["paymentOrderInvoices"])) {
                this.paymentOrderInvoices = [] as any;
                for (let item of _data["paymentOrderInvoices"])
                    this.paymentOrderInvoices.push(PaymentOrderInvoice.fromJS(item));
            }
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.fgnOperDetailId = _data["fgnOperDetailId"];
            this.fgnOperationsDetail = _data["fgnOperationsDetail"] ? ForeignOperationsDetails.fromJS(_data["fgnOperationsDetail"]) : <any>undefined;
            this.div = _data["div"];
            this.status = _data["status"];
            this.statusDate = _data["statusDate"] ? moment(_data["statusDate"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentOrders {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentOrders();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNr"] = this.orderNr;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["writtenValue"] = this.writtenValue;
        data["payerBankAccountId"] = this.payerBankAccountId;
        data["payerBankAccount"] = this.payerBankAccount ? this.payerBankAccount.toJSON() : <any>undefined;
        data["beneficiaryId"] = this.beneficiaryId;
        data["beneficiary"] = this.beneficiary ? this.beneficiary.toJSON() : <any>undefined;
        data["benefAccountId"] = this.benefAccountId;
        data["benefAccount"] = this.benefAccount ? this.benefAccount.toJSON() : <any>undefined;
        data["paymentDetails"] = this.paymentDetails;
        if (Array.isArray(this.paymentOrderInvoices)) {
            data["paymentOrderInvoices"] = [];
            for (let item of this.paymentOrderInvoices)
                data["paymentOrderInvoices"].push(item.toJSON());
        }
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["fgnOperDetailId"] = this.fgnOperDetailId;
        data["fgnOperationsDetail"] = this.fgnOperationsDetail ? this.fgnOperationsDetail.toJSON() : <any>undefined;
        data["div"] = this.div;
        data["status"] = this.status;
        data["statusDate"] = this.statusDate ? this.statusDate.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): PaymentOrders {
        const json = this.toJSON();
        let result = new PaymentOrders();
        result.init(json);
        return result;
    }
}

export interface IPaymentOrders {
    orderNr: number;
    orderDate: moment.Moment;
    value: number;
    writtenValue: string | undefined;
    payerBankAccountId: number;
    payerBankAccount: BankAccount;
    beneficiaryId: number;
    beneficiary: Person;
    benefAccountId: number;
    benefAccount: BankAccount;
    paymentDetails: string | undefined;
    paymentOrderInvoices: PaymentOrderInvoice[] | undefined;
    currencyId: number;
    currency: Currency;
    fgnOperDetailId: number | undefined;
    fgnOperationsDetail: ForeignOperationsDetails;
    div: number | undefined;
    status: OperationStatus;
    statusDate: moment.Moment;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PaymentOrderInvoice implements IPaymentOrderInvoice {
    paymentOrderId: number;
    paymentOrder: PaymentOrders;
    invoiceId: number;
    invoice: Invoices;
    payedValue: number;
    operationDate: moment.Moment;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPaymentOrderInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentOrderId = _data["paymentOrderId"];
            this.paymentOrder = _data["paymentOrder"] ? PaymentOrders.fromJS(_data["paymentOrder"]) : <any>undefined;
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoices.fromJS(_data["invoice"]) : <any>undefined;
            this.payedValue = _data["payedValue"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentOrderInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentOrderInvoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentOrderId"] = this.paymentOrderId;
        data["paymentOrder"] = this.paymentOrder ? this.paymentOrder.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["payedValue"] = this.payedValue;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): PaymentOrderInvoice {
        const json = this.toJSON();
        let result = new PaymentOrderInvoice();
        result.init(json);
        return result;
    }
}

export interface IPaymentOrderInvoice {
    paymentOrderId: number;
    paymentOrder: PaymentOrders;
    invoiceId: number;
    invoice: Invoices;
    payedValue: number;
    operationDate: moment.Moment;
    state: State;
    tenantId: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Invoices implements IInvoices {
    operationDate: moment.Moment;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    activityTypeId: number | undefined;
    activityType: ActivityType;
    value: number;
    valueLocalCurr: number;
    vat: number;
    vatLocalCurr: number;
    dueDate: moment.Moment | undefined;
    description: string | undefined;
    regNumber: string | undefined;
    regDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
    thirdParty: Person;
    startDatePeriod: moment.Moment | undefined;
    endDatePeriod: moment.Moment | undefined;
    invoiceDetails: InvoiceDetails[] | undefined;
    state: State;
    thirdPartyQuality: ThirdPartyQuality;
    contaOperationId: number | undefined;
    contaOperation: Operation;
    currencyId: number;
    currency: Currency;
    contractsId: number | undefined;
    contracts: Contracts;
    documentTypeId: number;
    documentType: DocumentType;
    decontId: number | undefined;
    decont: Decont;
    hasDecont: boolean;
    fileDocValue: number;
    fileDocId: number;
    dispositionInvoices: DispositionInvoice[] | undefined;
    paymentOrderInvoices: PaymentOrderInvoice[] | undefined;
    tenantId: number;
    readonly totalPlatit: number;
    readonly restPlata: number;
    decontareInLei: boolean;
    cursValutar: number | undefined;
    monedaFacturaId: number | undefined;
    monedaFactura: Currency;
    valoareTotalaFactura: number | undefined;
    forcePaid: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IInvoices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceSeries = _data["invoiceSeries"];
            this.activityTypeId = _data["activityTypeId"];
            this.activityType = _data["activityType"] ? ActivityType.fromJS(_data["activityType"]) : <any>undefined;
            this.value = _data["value"];
            this.valueLocalCurr = _data["valueLocalCurr"];
            this.vat = _data["vat"];
            this.vatLocalCurr = _data["vatLocalCurr"];
            this.dueDate = _data["dueDate"] ? moment(_data["dueDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.regNumber = _data["regNumber"];
            this.regDate = _data["regDate"] ? moment(_data["regDate"].toString()) : <any>undefined;
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdParty = _data["thirdParty"] ? Person.fromJS(_data["thirdParty"]) : <any>undefined;
            this.startDatePeriod = _data["startDatePeriod"] ? moment(_data["startDatePeriod"].toString()) : <any>undefined;
            this.endDatePeriod = _data["endDatePeriod"] ? moment(_data["endDatePeriod"].toString()) : <any>undefined;
            if (Array.isArray(_data["invoiceDetails"])) {
                this.invoiceDetails = [] as any;
                for (let item of _data["invoiceDetails"])
                    this.invoiceDetails.push(InvoiceDetails.fromJS(item));
            }
            this.state = _data["state"];
            this.thirdPartyQuality = _data["thirdPartyQuality"];
            this.contaOperationId = _data["contaOperationId"];
            this.contaOperation = _data["contaOperation"] ? Operation.fromJS(_data["contaOperation"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.contractsId = _data["contractsId"];
            this.contracts = _data["contracts"] ? Contracts.fromJS(_data["contracts"]) : <any>undefined;
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"] ? DocumentType.fromJS(_data["documentType"]) : <any>undefined;
            this.decontId = _data["decontId"];
            this.decont = _data["decont"] ? Decont.fromJS(_data["decont"]) : <any>undefined;
            this.hasDecont = _data["hasDecont"];
            this.fileDocValue = _data["fileDocValue"];
            this.fileDocId = _data["fileDocId"];
            if (Array.isArray(_data["dispositionInvoices"])) {
                this.dispositionInvoices = [] as any;
                for (let item of _data["dispositionInvoices"])
                    this.dispositionInvoices.push(DispositionInvoice.fromJS(item));
            }
            if (Array.isArray(_data["paymentOrderInvoices"])) {
                this.paymentOrderInvoices = [] as any;
                for (let item of _data["paymentOrderInvoices"])
                    this.paymentOrderInvoices.push(PaymentOrderInvoice.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            (<any>this).totalPlatit = _data["totalPlatit"];
            (<any>this).restPlata = _data["restPlata"];
            this.decontareInLei = _data["decontareInLei"];
            this.cursValutar = _data["cursValutar"];
            this.monedaFacturaId = _data["monedaFacturaId"];
            this.monedaFactura = _data["monedaFactura"] ? Currency.fromJS(_data["monedaFactura"]) : <any>undefined;
            this.valoareTotalaFactura = _data["valoareTotalaFactura"];
            this.forcePaid = _data["forcePaid"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Invoices {
        data = typeof data === 'object' ? data : {};
        let result = new Invoices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceSeries"] = this.invoiceSeries;
        data["activityTypeId"] = this.activityTypeId;
        data["activityType"] = this.activityType ? this.activityType.toJSON() : <any>undefined;
        data["value"] = this.value;
        data["valueLocalCurr"] = this.valueLocalCurr;
        data["vat"] = this.vat;
        data["vatLocalCurr"] = this.vatLocalCurr;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["regNumber"] = this.regNumber;
        data["regDate"] = this.regDate ? this.regDate.toISOString() : <any>undefined;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdParty"] = this.thirdParty ? this.thirdParty.toJSON() : <any>undefined;
        data["startDatePeriod"] = this.startDatePeriod ? this.startDatePeriod.toISOString() : <any>undefined;
        data["endDatePeriod"] = this.endDatePeriod ? this.endDatePeriod.toISOString() : <any>undefined;
        if (Array.isArray(this.invoiceDetails)) {
            data["invoiceDetails"] = [];
            for (let item of this.invoiceDetails)
                data["invoiceDetails"].push(item.toJSON());
        }
        data["state"] = this.state;
        data["thirdPartyQuality"] = this.thirdPartyQuality;
        data["contaOperationId"] = this.contaOperationId;
        data["contaOperation"] = this.contaOperation ? this.contaOperation.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["contractsId"] = this.contractsId;
        data["contracts"] = this.contracts ? this.contracts.toJSON() : <any>undefined;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["decontId"] = this.decontId;
        data["decont"] = this.decont ? this.decont.toJSON() : <any>undefined;
        data["hasDecont"] = this.hasDecont;
        data["fileDocValue"] = this.fileDocValue;
        data["fileDocId"] = this.fileDocId;
        if (Array.isArray(this.dispositionInvoices)) {
            data["dispositionInvoices"] = [];
            for (let item of this.dispositionInvoices)
                data["dispositionInvoices"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentOrderInvoices)) {
            data["paymentOrderInvoices"] = [];
            for (let item of this.paymentOrderInvoices)
                data["paymentOrderInvoices"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["totalPlatit"] = this.totalPlatit;
        data["restPlata"] = this.restPlata;
        data["decontareInLei"] = this.decontareInLei;
        data["cursValutar"] = this.cursValutar;
        data["monedaFacturaId"] = this.monedaFacturaId;
        data["monedaFactura"] = this.monedaFactura ? this.monedaFactura.toJSON() : <any>undefined;
        data["valoareTotalaFactura"] = this.valoareTotalaFactura;
        data["forcePaid"] = this.forcePaid;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): Invoices {
        const json = this.toJSON();
        let result = new Invoices();
        result.init(json);
        return result;
    }
}

export interface IInvoices {
    operationDate: moment.Moment;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    activityTypeId: number | undefined;
    activityType: ActivityType;
    value: number;
    valueLocalCurr: number;
    vat: number;
    vatLocalCurr: number;
    dueDate: moment.Moment | undefined;
    description: string | undefined;
    regNumber: string | undefined;
    regDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
    thirdParty: Person;
    startDatePeriod: moment.Moment | undefined;
    endDatePeriod: moment.Moment | undefined;
    invoiceDetails: InvoiceDetails[] | undefined;
    state: State;
    thirdPartyQuality: ThirdPartyQuality;
    contaOperationId: number | undefined;
    contaOperation: Operation;
    currencyId: number;
    currency: Currency;
    contractsId: number | undefined;
    contracts: Contracts;
    documentTypeId: number;
    documentType: DocumentType;
    decontId: number | undefined;
    decont: Decont;
    hasDecont: boolean;
    fileDocValue: number;
    fileDocId: number;
    dispositionInvoices: DispositionInvoice[] | undefined;
    paymentOrderInvoices: PaymentOrderInvoice[] | undefined;
    tenantId: number;
    totalPlatit: number;
    restPlata: number;
    decontareInLei: boolean;
    cursValutar: number | undefined;
    monedaFacturaId: number | undefined;
    monedaFactura: Currency;
    valoareTotalaFactura: number | undefined;
    forcePaid: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Currency implements ICurrency {
    currencyCode: string | undefined;
    currencyName: string | undefined;
    status: State;
    bankAccounts: BankAccount[] | undefined;
    invoice: Invoices[] | undefined;
    id: number;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyCode = _data["currencyCode"];
            this.currencyName = _data["currencyName"];
            this.status = _data["status"];
            if (Array.isArray(_data["bankAccounts"])) {
                this.bankAccounts = [] as any;
                for (let item of _data["bankAccounts"])
                    this.bankAccounts.push(BankAccount.fromJS(item));
            }
            if (Array.isArray(_data["invoice"])) {
                this.invoice = [] as any;
                for (let item of _data["invoice"])
                    this.invoice.push(Invoices.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyCode"] = this.currencyCode;
        data["currencyName"] = this.currencyName;
        data["status"] = this.status;
        if (Array.isArray(this.bankAccounts)) {
            data["bankAccounts"] = [];
            for (let item of this.bankAccounts)
                data["bankAccounts"].push(item.toJSON());
        }
        if (Array.isArray(this.invoice)) {
            data["invoice"] = [];
            for (let item of this.invoice)
                data["invoice"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): Currency {
        const json = this.toJSON();
        let result = new Currency();
        result.init(json);
        return result;
    }
}

export interface ICurrency {
    currencyCode: string | undefined;
    currencyName: string | undefined;
    status: State;
    bankAccounts: BankAccount[] | undefined;
    invoice: Invoices[] | undefined;
    id: number;
}

export enum ImprumuturiTipDurata {
    _0 = 0,
    _1 = 1,
}

export enum TipCreditare {
    _0 = 0,
    _1 = 1,
}

export class ImprumutTermen implements IImprumutTermen {
    description: string | undefined;
    minValue: number;
    maxValue: number;
    state: State;
    tenantId: number;
    id: number;

    constructor(data?: IImprumutTermen) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImprumutTermen {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumutTermen();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): ImprumutTermen {
        const json = this.toJSON();
        let result = new ImprumutTermen();
        result.init(json);
        return result;
    }
}

export interface IImprumutTermen {
    description: string | undefined;
    minValue: number;
    maxValue: number;
    state: State;
    tenantId: number;
    id: number;
}

export class DateDobanziReferinta implements IDateDobanziReferinta {
    data: moment.Moment;
    dobanda: string | undefined;
    valoare: number;
    state: State;
    tenantId: number;
    dobanziReferintaId: number | undefined;
    dobanziReferinta: DobanziReferinta;
    id: number;

    constructor(data?: IDateDobanziReferinta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? moment(_data["data"].toString()) : <any>undefined;
            this.dobanda = _data["dobanda"];
            this.valoare = _data["valoare"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.dobanziReferintaId = _data["dobanziReferintaId"];
            this.dobanziReferinta = _data["dobanziReferinta"] ? DobanziReferinta.fromJS(_data["dobanziReferinta"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DateDobanziReferinta {
        data = typeof data === 'object' ? data : {};
        let result = new DateDobanziReferinta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toISOString() : <any>undefined;
        data["dobanda"] = this.dobanda;
        data["valoare"] = this.valoare;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["dobanziReferintaId"] = this.dobanziReferintaId;
        data["dobanziReferinta"] = this.dobanziReferinta ? this.dobanziReferinta.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): DateDobanziReferinta {
        const json = this.toJSON();
        let result = new DateDobanziReferinta();
        result.init(json);
        return result;
    }
}

export interface IDateDobanziReferinta {
    data: moment.Moment;
    dobanda: string | undefined;
    valoare: number;
    state: State;
    tenantId: number;
    dobanziReferintaId: number | undefined;
    dobanziReferinta: DobanziReferinta;
    id: number;
}

export class DobanziReferinta implements IDobanziReferinta {
    dobanda: string | undefined;
    descriere: string | undefined;
    perioadaCalcul: number;
    state: State;
    tenantId: number;
    dateDobanziReferinta: DateDobanziReferinta[] | undefined;
    id: number;

    constructor(data?: IDobanziReferinta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dobanda = _data["dobanda"];
            this.descriere = _data["descriere"];
            this.perioadaCalcul = _data["perioadaCalcul"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["dateDobanziReferinta"])) {
                this.dateDobanziReferinta = [] as any;
                for (let item of _data["dateDobanziReferinta"])
                    this.dateDobanziReferinta.push(DateDobanziReferinta.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DobanziReferinta {
        data = typeof data === 'object' ? data : {};
        let result = new DobanziReferinta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dobanda"] = this.dobanda;
        data["descriere"] = this.descriere;
        data["perioadaCalcul"] = this.perioadaCalcul;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.dateDobanziReferinta)) {
            data["dateDobanziReferinta"] = [];
            for (let item of this.dateDobanziReferinta)
                data["dateDobanziReferinta"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): DobanziReferinta {
        const json = this.toJSON();
        let result = new DobanziReferinta();
        result.init(json);
        return result;
    }
}

export interface IDobanziReferinta {
    dobanda: string | undefined;
    descriere: string | undefined;
    perioadaCalcul: number;
    state: State;
    tenantId: number;
    dateDobanziReferinta: DateDobanziReferinta[] | undefined;
    id: number;
}

export enum PerioadaTipDurata {
    _0 = 0,
    _1 = 1,
}

export enum TipRata {
    _0 = 0,
    _1 = 1,
}

export enum TipDobanda {
    _0 = 0,
    _1 = 1,
}

export enum ImprumuturiStare {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ImprumutState implements IImprumutState {
    contaOperationDetailId: number | undefined;
    contaOperationDetail: OperationDetails;
    imprumuturiStare: ImprumuturiStare;
    comentariu: string | undefined;
    operationDate: moment.Moment;
    imprumutId: number | undefined;
    imprumut: Imprumut;
    tenantId: number;
    id: number;

    constructor(data?: IImprumutState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contaOperationDetailId = _data["contaOperationDetailId"];
            this.contaOperationDetail = _data["contaOperationDetail"] ? OperationDetails.fromJS(_data["contaOperationDetail"]) : <any>undefined;
            this.imprumuturiStare = _data["imprumuturiStare"];
            this.comentariu = _data["comentariu"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.imprumutId = _data["imprumutId"];
            this.imprumut = _data["imprumut"] ? Imprumut.fromJS(_data["imprumut"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImprumutState {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumutState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contaOperationDetailId"] = this.contaOperationDetailId;
        data["contaOperationDetail"] = this.contaOperationDetail ? this.contaOperationDetail.toJSON() : <any>undefined;
        data["imprumuturiStare"] = this.imprumuturiStare;
        data["comentariu"] = this.comentariu;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["imprumutId"] = this.imprumutId;
        data["imprumut"] = this.imprumut ? this.imprumut.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): ImprumutState {
        const json = this.toJSON();
        let result = new ImprumutState();
        result.init(json);
        return result;
    }
}

export interface IImprumutState {
    contaOperationDetailId: number | undefined;
    contaOperationDetail: OperationDetails;
    imprumuturiStare: ImprumuturiStare;
    comentariu: string | undefined;
    operationDate: moment.Moment;
    imprumutId: number | undefined;
    imprumut: Imprumut;
    tenantId: number;
    id: number;
}

export class GarantieCeGaranteaza implements IGarantieCeGaranteaza {
    description: string | undefined;
    state: State;
    tenantId: number;
    id: number;

    constructor(data?: IGarantieCeGaranteaza) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GarantieCeGaranteaza {
        data = typeof data === 'object' ? data : {};
        let result = new GarantieCeGaranteaza();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): GarantieCeGaranteaza {
        const json = this.toJSON();
        let result = new GarantieCeGaranteaza();
        result.init(json);
        return result;
    }
}

export interface IGarantieCeGaranteaza {
    description: string | undefined;
    state: State;
    tenantId: number;
    id: number;
}

export class GarantieTip implements IGarantieTip {
    description: string | undefined;
    state: State;
    tenantId: number;
    id: number;

    constructor(data?: IGarantieTip) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GarantieTip {
        data = typeof data === 'object' ? data : {};
        let result = new GarantieTip();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): GarantieTip {
        const json = this.toJSON();
        let result = new GarantieTip();
        result.init(json);
        return result;
    }
}

export interface IGarantieTip {
    description: string | undefined;
    state: State;
    tenantId: number;
    id: number;
}

export enum TipGarantiePrimitaDataEnum {
    _0 = 0,
    _1 = 1,
}

export enum TipOperatieGarantieEnum {
    _0 = 0,
    _1 = 1,
}

export class OperatieGarantie implements IOperatieGarantie {
    garantieId: number;
    garantie: Garantie;
    contaOperationId: number | undefined;
    contaOperation: Operation;
    contaOperationDetailId: number | undefined;
    contaOperationDetail: OperationDetails;
    suma: number;
    sold: number;
    tipOperatieGarantieEnum: TipOperatieGarantieEnum;
    dataOperatiei: moment.Moment;
    state: State;
    tenantId: number;
    id: number;

    constructor(data?: IOperatieGarantie) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.garantieId = _data["garantieId"];
            this.garantie = _data["garantie"] ? Garantie.fromJS(_data["garantie"]) : <any>undefined;
            this.contaOperationId = _data["contaOperationId"];
            this.contaOperation = _data["contaOperation"] ? Operation.fromJS(_data["contaOperation"]) : <any>undefined;
            this.contaOperationDetailId = _data["contaOperationDetailId"];
            this.contaOperationDetail = _data["contaOperationDetail"] ? OperationDetails.fromJS(_data["contaOperationDetail"]) : <any>undefined;
            this.suma = _data["suma"];
            this.sold = _data["sold"];
            this.tipOperatieGarantieEnum = _data["tipOperatieGarantieEnum"];
            this.dataOperatiei = _data["dataOperatiei"] ? moment(_data["dataOperatiei"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OperatieGarantie {
        data = typeof data === 'object' ? data : {};
        let result = new OperatieGarantie();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["garantieId"] = this.garantieId;
        data["garantie"] = this.garantie ? this.garantie.toJSON() : <any>undefined;
        data["contaOperationId"] = this.contaOperationId;
        data["contaOperation"] = this.contaOperation ? this.contaOperation.toJSON() : <any>undefined;
        data["contaOperationDetailId"] = this.contaOperationDetailId;
        data["contaOperationDetail"] = this.contaOperationDetail ? this.contaOperationDetail.toJSON() : <any>undefined;
        data["suma"] = this.suma;
        data["sold"] = this.sold;
        data["tipOperatieGarantieEnum"] = this.tipOperatieGarantieEnum;
        data["dataOperatiei"] = this.dataOperatiei ? this.dataOperatiei.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): OperatieGarantie {
        const json = this.toJSON();
        let result = new OperatieGarantie();
        result.init(json);
        return result;
    }
}

export interface IOperatieGarantie {
    garantieId: number;
    garantie: Garantie;
    contaOperationId: number | undefined;
    contaOperation: Operation;
    contaOperationDetailId: number | undefined;
    contaOperationDetail: OperationDetails;
    suma: number;
    sold: number;
    tipOperatieGarantieEnum: TipOperatieGarantieEnum;
    dataOperatiei: moment.Moment;
    state: State;
    tenantId: number;
    id: number;
}

export class Garantie implements IGarantie {
    documentNr: number;
    documentDate: moment.Moment;
    garantieAccountId: number | undefined;
    garantieAccount: BankAccount;
    sumaGarantiei: number;
    currencyId: number;
    currency: Currency;
    legalPersonId: number;
    legalPerson: LegalPerson;
    mentiuni: string | undefined;
    garantieCeGaranteazaId: number;
    garantieCeGaranteaza: GarantieCeGaranteaza;
    garantieTipId: number;
    garantieTip: GarantieTip;
    startDateGarantie: moment.Moment;
    tipGarantiePrimitaDataEnum: TipGarantiePrimitaDataEnum;
    endDateGarantie: moment.Moment;
    state: State;
    imprumutId: number | undefined;
    imprumut: Imprumut;
    tenantId: number;
    operatiiGarantie: OperatieGarantie[] | undefined;
    id: number;

    constructor(data?: IGarantie) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.garantieAccountId = _data["garantieAccountId"];
            this.garantieAccount = _data["garantieAccount"] ? BankAccount.fromJS(_data["garantieAccount"]) : <any>undefined;
            this.sumaGarantiei = _data["sumaGarantiei"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.legalPersonId = _data["legalPersonId"];
            this.legalPerson = _data["legalPerson"] ? LegalPerson.fromJS(_data["legalPerson"]) : <any>undefined;
            this.mentiuni = _data["mentiuni"];
            this.garantieCeGaranteazaId = _data["garantieCeGaranteazaId"];
            this.garantieCeGaranteaza = _data["garantieCeGaranteaza"] ? GarantieCeGaranteaza.fromJS(_data["garantieCeGaranteaza"]) : <any>undefined;
            this.garantieTipId = _data["garantieTipId"];
            this.garantieTip = _data["garantieTip"] ? GarantieTip.fromJS(_data["garantieTip"]) : <any>undefined;
            this.startDateGarantie = _data["startDateGarantie"] ? moment(_data["startDateGarantie"].toString()) : <any>undefined;
            this.tipGarantiePrimitaDataEnum = _data["tipGarantiePrimitaDataEnum"];
            this.endDateGarantie = _data["endDateGarantie"] ? moment(_data["endDateGarantie"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.imprumutId = _data["imprumutId"];
            this.imprumut = _data["imprumut"] ? Imprumut.fromJS(_data["imprumut"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["operatiiGarantie"])) {
                this.operatiiGarantie = [] as any;
                for (let item of _data["operatiiGarantie"])
                    this.operatiiGarantie.push(OperatieGarantie.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Garantie {
        data = typeof data === 'object' ? data : {};
        let result = new Garantie();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["garantieAccountId"] = this.garantieAccountId;
        data["garantieAccount"] = this.garantieAccount ? this.garantieAccount.toJSON() : <any>undefined;
        data["sumaGarantiei"] = this.sumaGarantiei;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["legalPersonId"] = this.legalPersonId;
        data["legalPerson"] = this.legalPerson ? this.legalPerson.toJSON() : <any>undefined;
        data["mentiuni"] = this.mentiuni;
        data["garantieCeGaranteazaId"] = this.garantieCeGaranteazaId;
        data["garantieCeGaranteaza"] = this.garantieCeGaranteaza ? this.garantieCeGaranteaza.toJSON() : <any>undefined;
        data["garantieTipId"] = this.garantieTipId;
        data["garantieTip"] = this.garantieTip ? this.garantieTip.toJSON() : <any>undefined;
        data["startDateGarantie"] = this.startDateGarantie ? this.startDateGarantie.toISOString() : <any>undefined;
        data["tipGarantiePrimitaDataEnum"] = this.tipGarantiePrimitaDataEnum;
        data["endDateGarantie"] = this.endDateGarantie ? this.endDateGarantie.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["imprumutId"] = this.imprumutId;
        data["imprumut"] = this.imprumut ? this.imprumut.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.operatiiGarantie)) {
            data["operatiiGarantie"] = [];
            for (let item of this.operatiiGarantie)
                data["operatiiGarantie"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): Garantie {
        const json = this.toJSON();
        let result = new Garantie();
        result.init(json);
        return result;
    }
}

export interface IGarantie {
    documentNr: number;
    documentDate: moment.Moment;
    garantieAccountId: number | undefined;
    garantieAccount: BankAccount;
    sumaGarantiei: number;
    currencyId: number;
    currency: Currency;
    legalPersonId: number;
    legalPerson: LegalPerson;
    mentiuni: string | undefined;
    garantieCeGaranteazaId: number;
    garantieCeGaranteaza: GarantieCeGaranteaza;
    garantieTipId: number;
    garantieTip: GarantieTip;
    startDateGarantie: moment.Moment;
    tipGarantiePrimitaDataEnum: TipGarantiePrimitaDataEnum;
    endDateGarantie: moment.Moment;
    state: State;
    imprumutId: number | undefined;
    imprumut: Imprumut;
    tenantId: number;
    operatiiGarantie: OperatieGarantie[] | undefined;
    id: number;
}

export class Rata implements IRata {
    index: number;
    tipRata: TipRata;
    tipDobanda: TipDobanda;
    numarOrdinDePlata: number;
    dataPlataRata: moment.Moment;
    sumaPrincipal: number;
    sumaDobanda: number;
    sumaPlatita: number;
    sold: number;
    procentDobanda: number;
    currencyId: number;
    currency: Currency;
    state: State;
    imprumutId: number | undefined;
    imprumut: Imprumut;
    contaOperationDetailId: number | undefined;
    contaOperationDetail: OperationDetails;
    tenantId: number;
    isValid: boolean;
    id: number;

    constructor(data?: IRata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.tipRata = _data["tipRata"];
            this.tipDobanda = _data["tipDobanda"];
            this.numarOrdinDePlata = _data["numarOrdinDePlata"];
            this.dataPlataRata = _data["dataPlataRata"] ? moment(_data["dataPlataRata"].toString()) : <any>undefined;
            this.sumaPrincipal = _data["sumaPrincipal"];
            this.sumaDobanda = _data["sumaDobanda"];
            this.sumaPlatita = _data["sumaPlatita"];
            this.sold = _data["sold"];
            this.procentDobanda = _data["procentDobanda"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.state = _data["state"];
            this.imprumutId = _data["imprumutId"];
            this.imprumut = _data["imprumut"] ? Imprumut.fromJS(_data["imprumut"]) : <any>undefined;
            this.contaOperationDetailId = _data["contaOperationDetailId"];
            this.contaOperationDetail = _data["contaOperationDetail"] ? OperationDetails.fromJS(_data["contaOperationDetail"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.isValid = _data["isValid"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Rata {
        data = typeof data === 'object' ? data : {};
        let result = new Rata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["tipRata"] = this.tipRata;
        data["tipDobanda"] = this.tipDobanda;
        data["numarOrdinDePlata"] = this.numarOrdinDePlata;
        data["dataPlataRata"] = this.dataPlataRata ? this.dataPlataRata.toISOString() : <any>undefined;
        data["sumaPrincipal"] = this.sumaPrincipal;
        data["sumaDobanda"] = this.sumaDobanda;
        data["sumaPlatita"] = this.sumaPlatita;
        data["sold"] = this.sold;
        data["procentDobanda"] = this.procentDobanda;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["state"] = this.state;
        data["imprumutId"] = this.imprumutId;
        data["imprumut"] = this.imprumut ? this.imprumut.toJSON() : <any>undefined;
        data["contaOperationDetailId"] = this.contaOperationDetailId;
        data["contaOperationDetail"] = this.contaOperationDetail ? this.contaOperationDetail.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["isValid"] = this.isValid;
        data["id"] = this.id;
        return data;
    }

    clone(): Rata {
        const json = this.toJSON();
        let result = new Rata();
        result.init(json);
        return result;
    }
}

export interface IRata {
    index: number;
    tipRata: TipRata;
    tipDobanda: TipDobanda;
    numarOrdinDePlata: number;
    dataPlataRata: moment.Moment;
    sumaPrincipal: number;
    sumaDobanda: number;
    sumaPlatita: number;
    sold: number;
    procentDobanda: number;
    currencyId: number;
    currency: Currency;
    state: State;
    imprumutId: number | undefined;
    imprumut: Imprumut;
    contaOperationDetailId: number | undefined;
    contaOperationDetail: OperationDetails;
    tenantId: number;
    isValid: boolean;
    id: number;
}

export enum TipTragere {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class DataComision implements IDataComision {
    comisionId: number | undefined;
    comision: Comision;
    imprumutId: number | undefined;
    imprumut: Imprumut;
    tragereId: number | undefined;
    tragere: Tragere;
    contaOperationId: number | undefined;
    contaOperation: Operation;
    contaOperationDetailId: number | undefined;
    contaOperationDetail: OperationDetails;
    index: number;
    dataPlataComision: moment.Moment;
    sumaComision: number;
    tipValoareComision: TipValoareComision;
    tipSumaComision: TipSumaComision;
    valoareComision: number;
    state: State;
    tenantId: number;
    isValid: boolean;
    id: number;

    constructor(data?: IDataComision) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comisionId = _data["comisionId"];
            this.comision = _data["comision"] ? Comision.fromJS(_data["comision"]) : <any>undefined;
            this.imprumutId = _data["imprumutId"];
            this.imprumut = _data["imprumut"] ? Imprumut.fromJS(_data["imprumut"]) : <any>undefined;
            this.tragereId = _data["tragereId"];
            this.tragere = _data["tragere"] ? Tragere.fromJS(_data["tragere"]) : <any>undefined;
            this.contaOperationId = _data["contaOperationId"];
            this.contaOperation = _data["contaOperation"] ? Operation.fromJS(_data["contaOperation"]) : <any>undefined;
            this.contaOperationDetailId = _data["contaOperationDetailId"];
            this.contaOperationDetail = _data["contaOperationDetail"] ? OperationDetails.fromJS(_data["contaOperationDetail"]) : <any>undefined;
            this.index = _data["index"];
            this.dataPlataComision = _data["dataPlataComision"] ? moment(_data["dataPlataComision"].toString()) : <any>undefined;
            this.sumaComision = _data["sumaComision"];
            this.tipValoareComision = _data["tipValoareComision"];
            this.tipSumaComision = _data["tipSumaComision"];
            this.valoareComision = _data["valoareComision"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.isValid = _data["isValid"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DataComision {
        data = typeof data === 'object' ? data : {};
        let result = new DataComision();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comisionId"] = this.comisionId;
        data["comision"] = this.comision ? this.comision.toJSON() : <any>undefined;
        data["imprumutId"] = this.imprumutId;
        data["imprumut"] = this.imprumut ? this.imprumut.toJSON() : <any>undefined;
        data["tragereId"] = this.tragereId;
        data["tragere"] = this.tragere ? this.tragere.toJSON() : <any>undefined;
        data["contaOperationId"] = this.contaOperationId;
        data["contaOperation"] = this.contaOperation ? this.contaOperation.toJSON() : <any>undefined;
        data["contaOperationDetailId"] = this.contaOperationDetailId;
        data["contaOperationDetail"] = this.contaOperationDetail ? this.contaOperationDetail.toJSON() : <any>undefined;
        data["index"] = this.index;
        data["dataPlataComision"] = this.dataPlataComision ? this.dataPlataComision.toISOString() : <any>undefined;
        data["sumaComision"] = this.sumaComision;
        data["tipValoareComision"] = this.tipValoareComision;
        data["tipSumaComision"] = this.tipSumaComision;
        data["valoareComision"] = this.valoareComision;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["isValid"] = this.isValid;
        data["id"] = this.id;
        return data;
    }

    clone(): DataComision {
        const json = this.toJSON();
        let result = new DataComision();
        result.init(json);
        return result;
    }
}

export interface IDataComision {
    comisionId: number | undefined;
    comision: Comision;
    imprumutId: number | undefined;
    imprumut: Imprumut;
    tragereId: number | undefined;
    tragere: Tragere;
    contaOperationId: number | undefined;
    contaOperation: Operation;
    contaOperationDetailId: number | undefined;
    contaOperationDetail: OperationDetails;
    index: number;
    dataPlataComision: moment.Moment;
    sumaComision: number;
    tipValoareComision: TipValoareComision;
    tipSumaComision: TipSumaComision;
    valoareComision: number;
    state: State;
    tenantId: number;
    isValid: boolean;
    id: number;
}

export class Tragere implements ITragere {
    tipTragere: TipTragere;
    dataTragere: moment.Moment;
    sumaDisponibila: number;
    sumaTrasa: number;
    sumaImprumutata: number;
    dobanda: number;
    comision: number;
    currencyId: number;
    currency: Currency;
    state: State;
    imprumutId: number | undefined;
    imprumut: Imprumut;
    tenantId: number;
    comisions: DataComision[] | undefined;
    id: number;

    constructor(data?: ITragere) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tipTragere = _data["tipTragere"];
            this.dataTragere = _data["dataTragere"] ? moment(_data["dataTragere"].toString()) : <any>undefined;
            this.sumaDisponibila = _data["sumaDisponibila"];
            this.sumaTrasa = _data["sumaTrasa"];
            this.sumaImprumutata = _data["sumaImprumutata"];
            this.dobanda = _data["dobanda"];
            this.comision = _data["comision"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.state = _data["state"];
            this.imprumutId = _data["imprumutId"];
            this.imprumut = _data["imprumut"] ? Imprumut.fromJS(_data["imprumut"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["comisions"])) {
                this.comisions = [] as any;
                for (let item of _data["comisions"])
                    this.comisions.push(DataComision.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Tragere {
        data = typeof data === 'object' ? data : {};
        let result = new Tragere();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tipTragere"] = this.tipTragere;
        data["dataTragere"] = this.dataTragere ? this.dataTragere.toISOString() : <any>undefined;
        data["sumaDisponibila"] = this.sumaDisponibila;
        data["sumaTrasa"] = this.sumaTrasa;
        data["sumaImprumutata"] = this.sumaImprumutata;
        data["dobanda"] = this.dobanda;
        data["comision"] = this.comision;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["state"] = this.state;
        data["imprumutId"] = this.imprumutId;
        data["imprumut"] = this.imprumut ? this.imprumut.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.comisions)) {
            data["comisions"] = [];
            for (let item of this.comisions)
                data["comisions"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): Tragere {
        const json = this.toJSON();
        let result = new Tragere();
        result.init(json);
        return result;
    }
}

export interface ITragere {
    tipTragere: TipTragere;
    dataTragere: moment.Moment;
    sumaDisponibila: number;
    sumaTrasa: number;
    sumaImprumutata: number;
    dobanda: number;
    comision: number;
    currencyId: number;
    currency: Currency;
    state: State;
    imprumutId: number | undefined;
    imprumut: Imprumut;
    tenantId: number;
    comisions: DataComision[] | undefined;
    id: number;
}

export class Imprumut implements IImprumut {
    documentTypeId: number | undefined;
    documentType: DocumentType;
    documentNr: number;
    documentDate: moment.Moment;
    imprumuturiTipuriId: number | undefined;
    imprumuturiTipuri: ImprumutTip;
    currencyId: number;
    currency: Currency;
    bankId: number | undefined;
    bank: Issuer;
    loanAccountId: number | undefined;
    loanAccount: BankAccount;
    paymentAccountId: number | undefined;
    paymentAccount: BankAccount;
    loanDate: moment.Moment;
    startDate: moment.Moment;
    isFinalDeLuna: boolean;
    durata: number;
    imprumuturiTipDurata: ImprumuturiTipDurata;
    tipCreditare: TipCreditare;
    endDate: moment.Moment;
    imprumuturiTermenId: number | undefined;
    imprumuturiTermen: ImprumutTermen;
    dobanziReferintaId: number | undefined;
    dobanziReferinta: DobanziReferinta;
    activityTypeId: number | undefined;
    activityType: ActivityType;
    suma: number;
    marjaFixa: number;
    procentDobanda: number;
    perioadaTipDurata: PerioadaTipDurata;
    tipRata: TipRata;
    tipDobanda: TipDobanda;
    periodicitate: number;
    state: State;
    tenantId: number;
    contContabilId: number | undefined;
    account: Account;
    thirdPartyId: number | undefined;
    thirdParty: Person;
    imprumutStateList: ImprumutState[] | undefined;
    getImprumuturiState: ImprumuturiStare;
    garantii: Garantie[] | undefined;
    rate: Rata[] | undefined;
    tragere: Tragere[] | undefined;
    comisioane: Comision[] | undefined;
    id: number;

    constructor(data?: IImprumut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"] ? DocumentType.fromJS(_data["documentType"]) : <any>undefined;
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.imprumuturiTipuriId = _data["imprumuturiTipuriId"];
            this.imprumuturiTipuri = _data["imprumuturiTipuri"] ? ImprumutTip.fromJS(_data["imprumuturiTipuri"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.bankId = _data["bankId"];
            this.bank = _data["bank"] ? Issuer.fromJS(_data["bank"]) : <any>undefined;
            this.loanAccountId = _data["loanAccountId"];
            this.loanAccount = _data["loanAccount"] ? BankAccount.fromJS(_data["loanAccount"]) : <any>undefined;
            this.paymentAccountId = _data["paymentAccountId"];
            this.paymentAccount = _data["paymentAccount"] ? BankAccount.fromJS(_data["paymentAccount"]) : <any>undefined;
            this.loanDate = _data["loanDate"] ? moment(_data["loanDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.isFinalDeLuna = _data["isFinalDeLuna"];
            this.durata = _data["durata"];
            this.imprumuturiTipDurata = _data["imprumuturiTipDurata"];
            this.tipCreditare = _data["tipCreditare"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.imprumuturiTermenId = _data["imprumuturiTermenId"];
            this.imprumuturiTermen = _data["imprumuturiTermen"] ? ImprumutTermen.fromJS(_data["imprumuturiTermen"]) : <any>undefined;
            this.dobanziReferintaId = _data["dobanziReferintaId"];
            this.dobanziReferinta = _data["dobanziReferinta"] ? DobanziReferinta.fromJS(_data["dobanziReferinta"]) : <any>undefined;
            this.activityTypeId = _data["activityTypeId"];
            this.activityType = _data["activityType"] ? ActivityType.fromJS(_data["activityType"]) : <any>undefined;
            this.suma = _data["suma"];
            this.marjaFixa = _data["marjaFixa"];
            this.procentDobanda = _data["procentDobanda"];
            this.perioadaTipDurata = _data["perioadaTipDurata"];
            this.tipRata = _data["tipRata"];
            this.tipDobanda = _data["tipDobanda"];
            this.periodicitate = _data["periodicitate"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.contContabilId = _data["contContabilId"];
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdParty = _data["thirdParty"] ? Person.fromJS(_data["thirdParty"]) : <any>undefined;
            if (Array.isArray(_data["imprumutStateList"])) {
                this.imprumutStateList = [] as any;
                for (let item of _data["imprumutStateList"])
                    this.imprumutStateList.push(ImprumutState.fromJS(item));
            }
            this.getImprumuturiState = _data["getImprumuturiState"];
            if (Array.isArray(_data["garantii"])) {
                this.garantii = [] as any;
                for (let item of _data["garantii"])
                    this.garantii.push(Garantie.fromJS(item));
            }
            if (Array.isArray(_data["rate"])) {
                this.rate = [] as any;
                for (let item of _data["rate"])
                    this.rate.push(Rata.fromJS(item));
            }
            if (Array.isArray(_data["tragere"])) {
                this.tragere = [] as any;
                for (let item of _data["tragere"])
                    this.tragere.push(Tragere.fromJS(item));
            }
            if (Array.isArray(_data["comisioane"])) {
                this.comisioane = [] as any;
                for (let item of _data["comisioane"])
                    this.comisioane.push(Comision.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Imprumut {
        data = typeof data === 'object' ? data : {};
        let result = new Imprumut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["imprumuturiTipuriId"] = this.imprumuturiTipuriId;
        data["imprumuturiTipuri"] = this.imprumuturiTipuri ? this.imprumuturiTipuri.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["bankId"] = this.bankId;
        data["bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["loanAccountId"] = this.loanAccountId;
        data["loanAccount"] = this.loanAccount ? this.loanAccount.toJSON() : <any>undefined;
        data["paymentAccountId"] = this.paymentAccountId;
        data["paymentAccount"] = this.paymentAccount ? this.paymentAccount.toJSON() : <any>undefined;
        data["loanDate"] = this.loanDate ? this.loanDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["isFinalDeLuna"] = this.isFinalDeLuna;
        data["durata"] = this.durata;
        data["imprumuturiTipDurata"] = this.imprumuturiTipDurata;
        data["tipCreditare"] = this.tipCreditare;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["imprumuturiTermenId"] = this.imprumuturiTermenId;
        data["imprumuturiTermen"] = this.imprumuturiTermen ? this.imprumuturiTermen.toJSON() : <any>undefined;
        data["dobanziReferintaId"] = this.dobanziReferintaId;
        data["dobanziReferinta"] = this.dobanziReferinta ? this.dobanziReferinta.toJSON() : <any>undefined;
        data["activityTypeId"] = this.activityTypeId;
        data["activityType"] = this.activityType ? this.activityType.toJSON() : <any>undefined;
        data["suma"] = this.suma;
        data["marjaFixa"] = this.marjaFixa;
        data["procentDobanda"] = this.procentDobanda;
        data["perioadaTipDurata"] = this.perioadaTipDurata;
        data["tipRata"] = this.tipRata;
        data["tipDobanda"] = this.tipDobanda;
        data["periodicitate"] = this.periodicitate;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["contContabilId"] = this.contContabilId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdParty"] = this.thirdParty ? this.thirdParty.toJSON() : <any>undefined;
        if (Array.isArray(this.imprumutStateList)) {
            data["imprumutStateList"] = [];
            for (let item of this.imprumutStateList)
                data["imprumutStateList"].push(item.toJSON());
        }
        data["getImprumuturiState"] = this.getImprumuturiState;
        if (Array.isArray(this.garantii)) {
            data["garantii"] = [];
            for (let item of this.garantii)
                data["garantii"].push(item.toJSON());
        }
        if (Array.isArray(this.rate)) {
            data["rate"] = [];
            for (let item of this.rate)
                data["rate"].push(item.toJSON());
        }
        if (Array.isArray(this.tragere)) {
            data["tragere"] = [];
            for (let item of this.tragere)
                data["tragere"].push(item.toJSON());
        }
        if (Array.isArray(this.comisioane)) {
            data["comisioane"] = [];
            for (let item of this.comisioane)
                data["comisioane"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): Imprumut {
        const json = this.toJSON();
        let result = new Imprumut();
        result.init(json);
        return result;
    }
}

export interface IImprumut {
    documentTypeId: number | undefined;
    documentType: DocumentType;
    documentNr: number;
    documentDate: moment.Moment;
    imprumuturiTipuriId: number | undefined;
    imprumuturiTipuri: ImprumutTip;
    currencyId: number;
    currency: Currency;
    bankId: number | undefined;
    bank: Issuer;
    loanAccountId: number | undefined;
    loanAccount: BankAccount;
    paymentAccountId: number | undefined;
    paymentAccount: BankAccount;
    loanDate: moment.Moment;
    startDate: moment.Moment;
    isFinalDeLuna: boolean;
    durata: number;
    imprumuturiTipDurata: ImprumuturiTipDurata;
    tipCreditare: TipCreditare;
    endDate: moment.Moment;
    imprumuturiTermenId: number | undefined;
    imprumuturiTermen: ImprumutTermen;
    dobanziReferintaId: number | undefined;
    dobanziReferinta: DobanziReferinta;
    activityTypeId: number | undefined;
    activityType: ActivityType;
    suma: number;
    marjaFixa: number;
    procentDobanda: number;
    perioadaTipDurata: PerioadaTipDurata;
    tipRata: TipRata;
    tipDobanda: TipDobanda;
    periodicitate: number;
    state: State;
    tenantId: number;
    contContabilId: number | undefined;
    account: Account;
    thirdPartyId: number | undefined;
    thirdParty: Person;
    imprumutStateList: ImprumutState[] | undefined;
    getImprumuturiState: ImprumuturiStare;
    garantii: Garantie[] | undefined;
    rate: Rata[] | undefined;
    tragere: Tragere[] | undefined;
    comisioane: Comision[] | undefined;
    id: number;
}

export class Comision implements IComision {
    imprumutId: number | undefined;
    imprumut: Imprumut;
    tipComision: TipComision;
    description: string | undefined;
    tipValoareComision: TipValoareComision;
    valoareComision: number;
    modCalculComision: ModCalculComision;
    tipSumaComision: TipSumaComision;
    bazaDeCalcul: number;
    state: State;
    tenantId: number;
    dateComision: DataComision[] | undefined;
    id: number;

    constructor(data?: IComision) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imprumutId = _data["imprumutId"];
            this.imprumut = _data["imprumut"] ? Imprumut.fromJS(_data["imprumut"]) : <any>undefined;
            this.tipComision = _data["tipComision"];
            this.description = _data["description"];
            this.tipValoareComision = _data["tipValoareComision"];
            this.valoareComision = _data["valoareComision"];
            this.modCalculComision = _data["modCalculComision"];
            this.tipSumaComision = _data["tipSumaComision"];
            this.bazaDeCalcul = _data["bazaDeCalcul"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["dateComision"])) {
                this.dateComision = [] as any;
                for (let item of _data["dateComision"])
                    this.dateComision.push(DataComision.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Comision {
        data = typeof data === 'object' ? data : {};
        let result = new Comision();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imprumutId"] = this.imprumutId;
        data["imprumut"] = this.imprumut ? this.imprumut.toJSON() : <any>undefined;
        data["tipComision"] = this.tipComision;
        data["description"] = this.description;
        data["tipValoareComision"] = this.tipValoareComision;
        data["valoareComision"] = this.valoareComision;
        data["modCalculComision"] = this.modCalculComision;
        data["tipSumaComision"] = this.tipSumaComision;
        data["bazaDeCalcul"] = this.bazaDeCalcul;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.dateComision)) {
            data["dateComision"] = [];
            for (let item of this.dateComision)
                data["dateComision"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): Comision {
        const json = this.toJSON();
        let result = new Comision();
        result.init(json);
        return result;
    }
}

export interface IComision {
    imprumutId: number | undefined;
    imprumut: Imprumut;
    tipComision: TipComision;
    description: string | undefined;
    tipValoareComision: TipValoareComision;
    valoareComision: number;
    modCalculComision: ModCalculComision;
    tipSumaComision: TipSumaComision;
    bazaDeCalcul: number;
    state: State;
    tenantId: number;
    dateComision: DataComision[] | undefined;
    id: number;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ContractDto implements IContractDto {
    id: number;
    contractObject: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    value: number | undefined;
    firstInstalmentDate: moment.Moment;
    thirdPartyContractNr: string | undefined;
    thirdPartyContractDate: moment.Moment;
    contractNr: string | undefined;
    contractDate: moment.Moment;
    cotaTVA_Id: number | undefined;
    monthlyValue: number | undefined;
    isMonthlyValue: boolean;
    contractsType: ContractsType;
    contractsTypeStr: string | undefined;
    contractsStatusStr: string | undefined;
    currencyId: number | undefined;
    currencyName: string | undefined;
    contractsPaymentInstalmentFreq: ContractsPaymentInstalmentFreq;
    thirdPartyName: string | undefined;
    thirdPartyId: number;
    thirdPartyQuality: ThirdPartyQuality;
    thirdPartyQualityStr: string | undefined;
    contract_State: string | undefined;
    aditionalContracts: ContractDto[] | undefined;
    state: State;
    contractsCategoryName: string | undefined;
    contractsCategoryId: number | undefined;
    masterContractId: number | undefined;
    prelungireAutomata: boolean;
    nrLuniPrelungire: number | undefined;
    comentarii: string | undefined;
    departamentId: number | undefined;
    fileDocId: number | undefined;

    constructor(data?: IContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractObject = _data["contractObject"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.firstInstalmentDate = _data["firstInstalmentDate"] ? moment(_data["firstInstalmentDate"].toString()) : <any>undefined;
            this.thirdPartyContractNr = _data["thirdPartyContractNr"];
            this.thirdPartyContractDate = _data["thirdPartyContractDate"] ? moment(_data["thirdPartyContractDate"].toString()) : <any>undefined;
            this.contractNr = _data["contractNr"];
            this.contractDate = _data["contractDate"] ? moment(_data["contractDate"].toString()) : <any>undefined;
            this.cotaTVA_Id = _data["cotaTVA_Id"];
            this.monthlyValue = _data["monthlyValue"];
            this.isMonthlyValue = _data["isMonthlyValue"];
            this.contractsType = _data["contractsType"];
            this.contractsTypeStr = _data["contractsTypeStr"];
            this.contractsStatusStr = _data["contractsStatusStr"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.contractsPaymentInstalmentFreq = _data["contractsPaymentInstalmentFreq"];
            this.thirdPartyName = _data["thirdPartyName"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdPartyQuality = _data["thirdPartyQuality"];
            this.thirdPartyQualityStr = _data["thirdPartyQualityStr"];
            this.contract_State = _data["contract_State"];
            if (Array.isArray(_data["aditionalContracts"])) {
                this.aditionalContracts = [] as any;
                for (let item of _data["aditionalContracts"])
                    this.aditionalContracts.push(ContractDto.fromJS(item));
            }
            this.state = _data["state"];
            this.contractsCategoryName = _data["contractsCategoryName"];
            this.contractsCategoryId = _data["contractsCategoryId"];
            this.masterContractId = _data["masterContractId"];
            this.prelungireAutomata = _data["prelungireAutomata"];
            this.nrLuniPrelungire = _data["nrLuniPrelungire"];
            this.comentarii = _data["comentarii"];
            this.departamentId = _data["departamentId"];
            this.fileDocId = _data["fileDocId"];
        }
    }

    static fromJS(data: any): ContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractObject"] = this.contractObject;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["firstInstalmentDate"] = this.firstInstalmentDate ? this.firstInstalmentDate.toISOString() : <any>undefined;
        data["thirdPartyContractNr"] = this.thirdPartyContractNr;
        data["thirdPartyContractDate"] = this.thirdPartyContractDate ? this.thirdPartyContractDate.toISOString() : <any>undefined;
        data["contractNr"] = this.contractNr;
        data["contractDate"] = this.contractDate ? this.contractDate.toISOString() : <any>undefined;
        data["cotaTVA_Id"] = this.cotaTVA_Id;
        data["monthlyValue"] = this.monthlyValue;
        data["isMonthlyValue"] = this.isMonthlyValue;
        data["contractsType"] = this.contractsType;
        data["contractsTypeStr"] = this.contractsTypeStr;
        data["contractsStatusStr"] = this.contractsStatusStr;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["contractsPaymentInstalmentFreq"] = this.contractsPaymentInstalmentFreq;
        data["thirdPartyName"] = this.thirdPartyName;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdPartyQuality"] = this.thirdPartyQuality;
        data["thirdPartyQualityStr"] = this.thirdPartyQualityStr;
        data["contract_State"] = this.contract_State;
        if (Array.isArray(this.aditionalContracts)) {
            data["aditionalContracts"] = [];
            for (let item of this.aditionalContracts)
                data["aditionalContracts"].push(item.toJSON());
        }
        data["state"] = this.state;
        data["contractsCategoryName"] = this.contractsCategoryName;
        data["contractsCategoryId"] = this.contractsCategoryId;
        data["masterContractId"] = this.masterContractId;
        data["prelungireAutomata"] = this.prelungireAutomata;
        data["nrLuniPrelungire"] = this.nrLuniPrelungire;
        data["comentarii"] = this.comentarii;
        data["departamentId"] = this.departamentId;
        data["fileDocId"] = this.fileDocId;
        return data;
    }

    clone(): ContractDto {
        const json = this.toJSON();
        let result = new ContractDto();
        result.init(json);
        return result;
    }
}

export interface IContractDto {
    id: number;
    contractObject: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    value: number | undefined;
    firstInstalmentDate: moment.Moment;
    thirdPartyContractNr: string | undefined;
    thirdPartyContractDate: moment.Moment;
    contractNr: string | undefined;
    contractDate: moment.Moment;
    cotaTVA_Id: number | undefined;
    monthlyValue: number | undefined;
    isMonthlyValue: boolean;
    contractsType: ContractsType;
    contractsTypeStr: string | undefined;
    contractsStatusStr: string | undefined;
    currencyId: number | undefined;
    currencyName: string | undefined;
    contractsPaymentInstalmentFreq: ContractsPaymentInstalmentFreq;
    thirdPartyName: string | undefined;
    thirdPartyId: number;
    thirdPartyQuality: ThirdPartyQuality;
    thirdPartyQualityStr: string | undefined;
    contract_State: string | undefined;
    aditionalContracts: ContractDto[] | undefined;
    state: State;
    contractsCategoryName: string | undefined;
    contractsCategoryId: number | undefined;
    masterContractId: number | undefined;
    prelungireAutomata: boolean;
    nrLuniPrelungire: number | undefined;
    comentarii: string | undefined;
    departamentId: number | undefined;
    fileDocId: number | undefined;
}

export class ContractStateListDto implements IContractStateListDto {
    operationDate: moment.Moment;
    comentarii: string | undefined;
    contract_State: string | undefined;

    constructor(data?: IContractStateListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.comentarii = _data["comentarii"];
            this.contract_State = _data["contract_State"];
        }
    }

    static fromJS(data: any): ContractStateListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractStateListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["comentarii"] = this.comentarii;
        data["contract_State"] = this.contract_State;
        return data;
    }

    clone(): ContractStateListDto {
        const json = this.toJSON();
        let result = new ContractStateListDto();
        result.init(json);
        return result;
    }
}

export interface IContractStateListDto {
    operationDate: moment.Moment;
    comentarii: string | undefined;
    contract_State: string | undefined;
}

export class ChangeContractStateDto implements IChangeContractStateDto {
    contractId: number;
    dataEnd: moment.Moment;
    contract_State: Contract_State;
    comentarii: string | undefined;

    constructor(data?: IChangeContractStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.contract_State = _data["contract_State"];
            this.comentarii = _data["comentarii"];
        }
    }

    static fromJS(data: any): ChangeContractStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeContractStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["contract_State"] = this.contract_State;
        data["comentarii"] = this.comentarii;
        return data;
    }

    clone(): ChangeContractStateDto {
        const json = this.toJSON();
        let result = new ChangeContractStateDto();
        result.init(json);
        return result;
    }
}

export interface IChangeContractStateDto {
    contractId: number;
    dataEnd: moment.Moment;
    contract_State: Contract_State;
    comentarii: string | undefined;
}

export class ContractSearchParametersDTO implements IContractSearchParametersDTO {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    thirdParty: string | undefined;
    thirdPartyQuality: ThirdPartyQuality;
    state: Contract_State;

    constructor(data?: IContractSearchParametersDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.thirdParty = _data["thirdParty"];
            this.thirdPartyQuality = _data["thirdPartyQuality"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): ContractSearchParametersDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSearchParametersDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["thirdParty"] = this.thirdParty;
        data["thirdPartyQuality"] = this.thirdPartyQuality;
        data["state"] = this.state;
        return data;
    }

    clone(): ContractSearchParametersDTO {
        const json = this.toJSON();
        let result = new ContractSearchParametersDTO();
        result.init(json);
        return result;
    }
}

export interface IContractSearchParametersDTO {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    thirdParty: string | undefined;
    thirdPartyQuality: ThirdPartyQuality;
    state: Contract_State;
}

export class ContractCategoryListDto implements IContractCategoryListDto {
    id: number;
    name: string | undefined;

    constructor(data?: IContractCategoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ContractCategoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractCategoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ContractCategoryListDto {
        const json = this.toJSON();
        let result = new ContractCategoryListDto();
        result.init(json);
        return result;
    }
}

export interface IContractCategoryListDto {
    id: number;
    name: string | undefined;
}

export class ContractCategoryEditDto implements IContractCategoryEditDto {
    id: number;
    name: string | undefined;
    okDelete: boolean;

    constructor(data?: IContractCategoryEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): ContractCategoryEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractCategoryEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): ContractCategoryEditDto {
        const json = this.toJSON();
        let result = new ContractCategoryEditDto();
        result.init(json);
        return result;
    }
}

export interface IContractCategoryEditDto {
    id: number;
    name: string | undefined;
    okDelete: boolean;
}

export class CotaTVAEditDto implements ICotaTVAEditDto {
    id: number;
    vat: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    state: State;
    tenantId: number;

    constructor(data?: ICotaTVAEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vat = _data["vat"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CotaTVAEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CotaTVAEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vat"] = this.vat;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CotaTVAEditDto {
        const json = this.toJSON();
        let result = new CotaTVAEditDto();
        result.init(json);
        return result;
    }
}

export interface ICotaTVAEditDto {
    id: number;
    vat: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    state: State;
    tenantId: number;
}

export class CotaTVAListDto implements ICotaTVAListDto {
    id: number;
    vat: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    state: State;
    tenantId: number;

    constructor(data?: ICotaTVAListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vat = _data["vat"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CotaTVAListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CotaTVAListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vat"] = this.vat;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CotaTVAListDto {
        const json = this.toJSON();
        let result = new CotaTVAListDto();
        result.init(json);
        return result;
    }
}

export interface ICotaTVAListDto {
    id: number;
    vat: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    state: State;
    tenantId: number;
}

export class BVC_PAAPTranseDto implements IBVC_PAAPTranseDto {
    id: number;
    bvC_PAAPId: number;
    dataTransa: moment.Moment;
    valoareLei: number;
    valoareLeiFaraTVA: number;

    constructor(data?: IBVC_PAAPTranseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bvC_PAAPId = _data["bvC_PAAPId"];
            this.dataTransa = _data["dataTransa"] ? moment(_data["dataTransa"].toString()) : <any>undefined;
            this.valoareLei = _data["valoareLei"];
            this.valoareLeiFaraTVA = _data["valoareLeiFaraTVA"];
        }
    }

    static fromJS(data: any): BVC_PAAPTranseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BVC_PAAPTranseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bvC_PAAPId"] = this.bvC_PAAPId;
        data["dataTransa"] = this.dataTransa ? this.dataTransa.toISOString() : <any>undefined;
        data["valoareLei"] = this.valoareLei;
        data["valoareLeiFaraTVA"] = this.valoareLeiFaraTVA;
        return data;
    }

    clone(): BVC_PAAPTranseDto {
        const json = this.toJSON();
        let result = new BVC_PAAPTranseDto();
        result.init(json);
        return result;
    }
}

export interface IBVC_PAAPTranseDto {
    id: number;
    bvC_PAAPId: number;
    dataTransa: moment.Moment;
    valoareLei: number;
    valoareLeiFaraTVA: number;
}

export class PaapDto implements IPaapDto {
    id: number;
    obiectTranzactie: string | undefined;
    descriere: string | undefined;
    codCPV: string | undefined;
    value: number;
    sursaFinantare: string | undefined;
    invoiceElementsDetailsName: string | undefined;
    invoiceElementsDetailsId: number | undefined;
    currencyName: string | undefined;
    cotaTVA_Id: number | undefined;
    localCurrencyId: number | undefined;
    invoiceElementsDetailsCategoryName: string | undefined;
    invoiceElementsDetailsCategoryId: number | undefined;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    firstInstalmentDate: moment.Moment;
    modDerulare: string | undefined;
    contractsPaymentInstalmentFreq: string | undefined;
    persoanaResponsabila: string | undefined;
    statePAAP: string | undefined;
    statePAAPId: number;
    departamentName: string | undefined;
    departamentId: number | undefined;
    showCategory: boolean;
    valoareTotalaLei: number;
    valoareTotalaValuta: number;
    valoareRealizata: number;
    nrTranse: number;
    isValueEqualToSumTranse: boolean;
    hasTranse: boolean;
    state: State;
    tenantId: number;
    transe: BVC_PAAPTranseDto[] | undefined;

    constructor(data?: IPaapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.obiectTranzactie = _data["obiectTranzactie"];
            this.descriere = _data["descriere"];
            this.codCPV = _data["codCPV"];
            this.value = _data["value"];
            this.sursaFinantare = _data["sursaFinantare"];
            this.invoiceElementsDetailsName = _data["invoiceElementsDetailsName"];
            this.invoiceElementsDetailsId = _data["invoiceElementsDetailsId"];
            this.currencyName = _data["currencyName"];
            this.cotaTVA_Id = _data["cotaTVA_Id"];
            this.localCurrencyId = _data["localCurrencyId"];
            this.invoiceElementsDetailsCategoryName = _data["invoiceElementsDetailsCategoryName"];
            this.invoiceElementsDetailsCategoryId = _data["invoiceElementsDetailsCategoryId"];
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.firstInstalmentDate = _data["firstInstalmentDate"] ? moment(_data["firstInstalmentDate"].toString()) : <any>undefined;
            this.modDerulare = _data["modDerulare"];
            this.contractsPaymentInstalmentFreq = _data["contractsPaymentInstalmentFreq"];
            this.persoanaResponsabila = _data["persoanaResponsabila"];
            this.statePAAP = _data["statePAAP"];
            this.statePAAPId = _data["statePAAPId"];
            this.departamentName = _data["departamentName"];
            this.departamentId = _data["departamentId"];
            this.showCategory = _data["showCategory"];
            this.valoareTotalaLei = _data["valoareTotalaLei"];
            this.valoareTotalaValuta = _data["valoareTotalaValuta"];
            this.valoareRealizata = _data["valoareRealizata"];
            this.nrTranse = _data["nrTranse"];
            this.isValueEqualToSumTranse = _data["isValueEqualToSumTranse"];
            this.hasTranse = _data["hasTranse"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["transe"])) {
                this.transe = [] as any;
                for (let item of _data["transe"])
                    this.transe.push(BVC_PAAPTranseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaapDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["obiectTranzactie"] = this.obiectTranzactie;
        data["descriere"] = this.descriere;
        data["codCPV"] = this.codCPV;
        data["value"] = this.value;
        data["sursaFinantare"] = this.sursaFinantare;
        data["invoiceElementsDetailsName"] = this.invoiceElementsDetailsName;
        data["invoiceElementsDetailsId"] = this.invoiceElementsDetailsId;
        data["currencyName"] = this.currencyName;
        data["cotaTVA_Id"] = this.cotaTVA_Id;
        data["localCurrencyId"] = this.localCurrencyId;
        data["invoiceElementsDetailsCategoryName"] = this.invoiceElementsDetailsCategoryName;
        data["invoiceElementsDetailsCategoryId"] = this.invoiceElementsDetailsCategoryId;
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["firstInstalmentDate"] = this.firstInstalmentDate ? this.firstInstalmentDate.toISOString() : <any>undefined;
        data["modDerulare"] = this.modDerulare;
        data["contractsPaymentInstalmentFreq"] = this.contractsPaymentInstalmentFreq;
        data["persoanaResponsabila"] = this.persoanaResponsabila;
        data["statePAAP"] = this.statePAAP;
        data["statePAAPId"] = this.statePAAPId;
        data["departamentName"] = this.departamentName;
        data["departamentId"] = this.departamentId;
        data["showCategory"] = this.showCategory;
        data["valoareTotalaLei"] = this.valoareTotalaLei;
        data["valoareTotalaValuta"] = this.valoareTotalaValuta;
        data["valoareRealizata"] = this.valoareRealizata;
        data["nrTranse"] = this.nrTranse;
        data["isValueEqualToSumTranse"] = this.isValueEqualToSumTranse;
        data["hasTranse"] = this.hasTranse;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.transe)) {
            data["transe"] = [];
            for (let item of this.transe)
                data["transe"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaapDto {
        const json = this.toJSON();
        let result = new PaapDto();
        result.init(json);
        return result;
    }
}

export interface IPaapDto {
    id: number;
    obiectTranzactie: string | undefined;
    descriere: string | undefined;
    codCPV: string | undefined;
    value: number;
    sursaFinantare: string | undefined;
    invoiceElementsDetailsName: string | undefined;
    invoiceElementsDetailsId: number | undefined;
    currencyName: string | undefined;
    cotaTVA_Id: number | undefined;
    localCurrencyId: number | undefined;
    invoiceElementsDetailsCategoryName: string | undefined;
    invoiceElementsDetailsCategoryId: number | undefined;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    firstInstalmentDate: moment.Moment;
    modDerulare: string | undefined;
    contractsPaymentInstalmentFreq: string | undefined;
    persoanaResponsabila: string | undefined;
    statePAAP: string | undefined;
    statePAAPId: number;
    departamentName: string | undefined;
    departamentId: number | undefined;
    showCategory: boolean;
    valoareTotalaLei: number;
    valoareTotalaValuta: number;
    valoareRealizata: number;
    nrTranse: number;
    isValueEqualToSumTranse: boolean;
    hasTranse: boolean;
    state: State;
    tenantId: number;
    transe: BVC_PAAPTranseDto[] | undefined;
}

export class CupiuriDetailsDto implements ICupiuriDetailsDto {
    quantity: number | undefined;
    value: number;
    state: State;
    tenantId: number;

    constructor(data?: ICupiuriDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.value = _data["value"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CupiuriDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CupiuriDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["value"] = this.value;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CupiuriDetailsDto {
        const json = this.toJSON();
        let result = new CupiuriDetailsDto();
        result.init(json);
        return result;
    }
}

export interface ICupiuriDetailsDto {
    quantity: number | undefined;
    value: number;
    state: State;
    tenantId: number;
}

export class CupiuriItemDto implements ICupiuriItemDto {
    currencyId: number | undefined;
    tenantId: number;
    state: State;
    cupiuriDetails: CupiuriDetailsDto[] | undefined;
    total: number;
    sold: number;

    constructor(data?: ICupiuriItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"];
            this.tenantId = _data["tenantId"];
            this.state = _data["state"];
            if (Array.isArray(_data["cupiuriDetails"])) {
                this.cupiuriDetails = [] as any;
                for (let item of _data["cupiuriDetails"])
                    this.cupiuriDetails.push(CupiuriDetailsDto.fromJS(item));
            }
            this.total = _data["total"];
            this.sold = _data["sold"];
        }
    }

    static fromJS(data: any): CupiuriItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CupiuriItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId;
        data["tenantId"] = this.tenantId;
        data["state"] = this.state;
        if (Array.isArray(this.cupiuriDetails)) {
            data["cupiuriDetails"] = [];
            for (let item of this.cupiuriDetails)
                data["cupiuriDetails"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["sold"] = this.sold;
        return data;
    }

    clone(): CupiuriItemDto {
        const json = this.toJSON();
        let result = new CupiuriItemDto();
        result.init(json);
        return result;
    }
}

export interface ICupiuriItemDto {
    currencyId: number | undefined;
    tenantId: number;
    state: State;
    cupiuriDetails: CupiuriDetailsDto[] | undefined;
    total: number;
    sold: number;
}

export class CupiuriForm implements ICupiuriForm {
    id: number;
    cupiuriInitId: number;
    operationDate: moment.Moment;
    cupiuri: CupiuriItemDto[] | undefined;

    constructor(data?: ICupiuriForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cupiuriInitId = _data["cupiuriInitId"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["cupiuri"])) {
                this.cupiuri = [] as any;
                for (let item of _data["cupiuri"])
                    this.cupiuri.push(CupiuriItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CupiuriForm {
        data = typeof data === 'object' ? data : {};
        let result = new CupiuriForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cupiuriInitId"] = this.cupiuriInitId;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.cupiuri)) {
            data["cupiuri"] = [];
            for (let item of this.cupiuri)
                data["cupiuri"].push(item.toJSON());
        }
        return data;
    }

    clone(): CupiuriForm {
        const json = this.toJSON();
        let result = new CupiuriForm();
        result.init(json);
        return result;
    }
}

export interface ICupiuriForm {
    id: number;
    cupiuriInitId: number;
    operationDate: moment.Moment;
    cupiuri: CupiuriItemDto[] | undefined;
}

export class CupiuriListDto implements ICupiuriListDto {
    id: number;
    operationDate: moment.Moment;

    constructor(data?: ICupiuriListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CupiuriListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CupiuriListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): CupiuriListDto {
        const json = this.toJSON();
        let result = new CupiuriListDto();
        result.init(json);
        return result;
    }
}

export interface ICupiuriListDto {
    id: number;
    operationDate: moment.Moment;
}

export class CurrencyDto implements ICurrencyDto {
    id: number;
    name: string | undefined;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): CurrencyDto {
        const json = this.toJSON();
        let result = new CurrencyDto();
        result.init(json);
        return result;
    }
}

export interface ICurrencyDto {
    id: number;
    name: string | undefined;
}

export class DataComisionDto implements IDataComisionDto {
    id: number;
    index: number;
    dataPlataComision: moment.Moment;
    sumaComision: number;
    tipValoareComision: TipValoareComision;
    tipSumaComision: TipSumaComision;
    tragereId: number | undefined;
    imprumutId: number | undefined;
    comisionId: number | undefined;
    valoareComision: number;
    state: State;
    isValid: boolean;

    constructor(data?: IDataComisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.index = _data["index"];
            this.dataPlataComision = _data["dataPlataComision"] ? moment(_data["dataPlataComision"].toString()) : <any>undefined;
            this.sumaComision = _data["sumaComision"];
            this.tipValoareComision = _data["tipValoareComision"];
            this.tipSumaComision = _data["tipSumaComision"];
            this.tragereId = _data["tragereId"];
            this.imprumutId = _data["imprumutId"];
            this.comisionId = _data["comisionId"];
            this.valoareComision = _data["valoareComision"];
            this.state = _data["state"];
            this.isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): DataComisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataComisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["index"] = this.index;
        data["dataPlataComision"] = this.dataPlataComision ? this.dataPlataComision.toISOString() : <any>undefined;
        data["sumaComision"] = this.sumaComision;
        data["tipValoareComision"] = this.tipValoareComision;
        data["tipSumaComision"] = this.tipSumaComision;
        data["tragereId"] = this.tragereId;
        data["imprumutId"] = this.imprumutId;
        data["comisionId"] = this.comisionId;
        data["valoareComision"] = this.valoareComision;
        data["state"] = this.state;
        data["isValid"] = this.isValid;
        return data;
    }

    clone(): DataComisionDto {
        const json = this.toJSON();
        let result = new DataComisionDto();
        result.init(json);
        return result;
    }
}

export interface IDataComisionDto {
    id: number;
    index: number;
    dataPlataComision: moment.Moment;
    sumaComision: number;
    tipValoareComision: TipValoareComision;
    tipSumaComision: TipSumaComision;
    tragereId: number | undefined;
    imprumutId: number | undefined;
    comisionId: number | undefined;
    valoareComision: number;
    state: State;
    isValid: boolean;
}

export class DateDobanziReferintaDto implements IDateDobanziReferintaDto {
    id: number;
    data: moment.Moment;
    dobanziReferinta: string | undefined;
    valoare: number;

    constructor(data?: IDateDobanziReferintaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? moment(_data["data"].toString()) : <any>undefined;
            this.dobanziReferinta = _data["dobanziReferinta"];
            this.valoare = _data["valoare"];
        }
    }

    static fromJS(data: any): DateDobanziReferintaDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateDobanziReferintaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toISOString() : <any>undefined;
        data["dobanziReferinta"] = this.dobanziReferinta;
        data["valoare"] = this.valoare;
        return data;
    }

    clone(): DateDobanziReferintaDto {
        const json = this.toJSON();
        let result = new DateDobanziReferintaDto();
        result.init(json);
        return result;
    }
}

export interface IDateDobanziReferintaDto {
    id: number;
    data: moment.Moment;
    dobanziReferinta: string | undefined;
    valoare: number;
}

export class DateDobanziReferintaEditDto implements IDateDobanziReferintaEditDto {
    id: number;
    data: moment.Moment;
    valoare: number;
    dobanziReferintaId: number;
    okDelete: boolean;

    constructor(data?: IDateDobanziReferintaEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? moment(_data["data"].toString()) : <any>undefined;
            this.valoare = _data["valoare"];
            this.dobanziReferintaId = _data["dobanziReferintaId"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): DateDobanziReferintaEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateDobanziReferintaEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toISOString() : <any>undefined;
        data["valoare"] = this.valoare;
        data["dobanziReferintaId"] = this.dobanziReferintaId;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): DateDobanziReferintaEditDto {
        const json = this.toJSON();
        let result = new DateDobanziReferintaEditDto();
        result.init(json);
        return result;
    }
}

export interface IDateDobanziReferintaEditDto {
    id: number;
    data: moment.Moment;
    valoare: number;
    dobanziReferintaId: number;
    okDelete: boolean;
}

export class DecontListDto implements IDecontListDto {
    id: number;
    decontNumber: number;
    decontDate: moment.Moment;
    thirdParty: string | undefined;
    diurna: number | undefined;
    dateStart: moment.Moment | undefined;
    dateEnd: moment.Moment | undefined;
    decontType: string | undefined;
    scopDeplasareTypeName: string | undefined;
    documentName: string | undefined;
    totalDiurnaAcordata: number;
    totalDiurnaImpozabila: number;

    constructor(data?: IDecontListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.decontNumber = _data["decontNumber"];
            this.decontDate = _data["decontDate"] ? moment(_data["decontDate"].toString()) : <any>undefined;
            this.thirdParty = _data["thirdParty"];
            this.diurna = _data["diurna"];
            this.dateStart = _data["dateStart"] ? moment(_data["dateStart"].toString()) : <any>undefined;
            this.dateEnd = _data["dateEnd"] ? moment(_data["dateEnd"].toString()) : <any>undefined;
            this.decontType = _data["decontType"];
            this.scopDeplasareTypeName = _data["scopDeplasareTypeName"];
            this.documentName = _data["documentName"];
            this.totalDiurnaAcordata = _data["totalDiurnaAcordata"];
            this.totalDiurnaImpozabila = _data["totalDiurnaImpozabila"];
        }
    }

    static fromJS(data: any): DecontListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DecontListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["decontNumber"] = this.decontNumber;
        data["decontDate"] = this.decontDate ? this.decontDate.toISOString() : <any>undefined;
        data["thirdParty"] = this.thirdParty;
        data["diurna"] = this.diurna;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        data["dateEnd"] = this.dateEnd ? this.dateEnd.toISOString() : <any>undefined;
        data["decontType"] = this.decontType;
        data["scopDeplasareTypeName"] = this.scopDeplasareTypeName;
        data["documentName"] = this.documentName;
        data["totalDiurnaAcordata"] = this.totalDiurnaAcordata;
        data["totalDiurnaImpozabila"] = this.totalDiurnaImpozabila;
        return data;
    }

    clone(): DecontListDto {
        const json = this.toJSON();
        let result = new DecontListDto();
        result.init(json);
        return result;
    }
}

export interface IDecontListDto {
    id: number;
    decontNumber: number;
    decontDate: moment.Moment;
    thirdParty: string | undefined;
    diurna: number | undefined;
    dateStart: moment.Moment | undefined;
    dateEnd: moment.Moment | undefined;
    decontType: string | undefined;
    scopDeplasareTypeName: string | undefined;
    documentName: string | undefined;
    totalDiurnaAcordata: number;
    totalDiurnaImpozabila: number;
}

export class DecontInitForm implements IDecontInitForm {
    thirdPartyId: number | undefined;
    thirdPartyName: string | undefined;
    decontStartDate: moment.Moment;
    decontEndDate: moment.Moment;
    delegatieStartDate: moment.Moment | undefined;
    delegatieEndDate: moment.Moment | undefined;
    diurnaLegalaId: number | undefined;
    decontTypeId: number | undefined;
    scopDeplasareTypeId: number | undefined;
    documentType: string | undefined;
    decontList: DecontListDto[] | undefined;

    constructor(data?: IDecontInitForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdPartyName = _data["thirdPartyName"];
            this.decontStartDate = _data["decontStartDate"] ? moment(_data["decontStartDate"].toString()) : <any>undefined;
            this.decontEndDate = _data["decontEndDate"] ? moment(_data["decontEndDate"].toString()) : <any>undefined;
            this.delegatieStartDate = _data["delegatieStartDate"] ? moment(_data["delegatieStartDate"].toString()) : <any>undefined;
            this.delegatieEndDate = _data["delegatieEndDate"] ? moment(_data["delegatieEndDate"].toString()) : <any>undefined;
            this.diurnaLegalaId = _data["diurnaLegalaId"];
            this.decontTypeId = _data["decontTypeId"];
            this.scopDeplasareTypeId = _data["scopDeplasareTypeId"];
            this.documentType = _data["documentType"];
            if (Array.isArray(_data["decontList"])) {
                this.decontList = [] as any;
                for (let item of _data["decontList"])
                    this.decontList.push(DecontListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DecontInitForm {
        data = typeof data === 'object' ? data : {};
        let result = new DecontInitForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdPartyName"] = this.thirdPartyName;
        data["decontStartDate"] = this.decontStartDate ? this.decontStartDate.toISOString() : <any>undefined;
        data["decontEndDate"] = this.decontEndDate ? this.decontEndDate.toISOString() : <any>undefined;
        data["delegatieStartDate"] = this.delegatieStartDate ? this.delegatieStartDate.toISOString() : <any>undefined;
        data["delegatieEndDate"] = this.delegatieEndDate ? this.delegatieEndDate.toISOString() : <any>undefined;
        data["diurnaLegalaId"] = this.diurnaLegalaId;
        data["decontTypeId"] = this.decontTypeId;
        data["scopDeplasareTypeId"] = this.scopDeplasareTypeId;
        data["documentType"] = this.documentType;
        if (Array.isArray(this.decontList)) {
            data["decontList"] = [];
            for (let item of this.decontList)
                data["decontList"].push(item.toJSON());
        }
        return data;
    }

    clone(): DecontInitForm {
        const json = this.toJSON();
        let result = new DecontInitForm();
        result.init(json);
        return result;
    }
}

export interface IDecontInitForm {
    thirdPartyId: number | undefined;
    thirdPartyName: string | undefined;
    decontStartDate: moment.Moment;
    decontEndDate: moment.Moment;
    delegatieStartDate: moment.Moment | undefined;
    delegatieEndDate: moment.Moment | undefined;
    diurnaLegalaId: number | undefined;
    decontTypeId: number | undefined;
    scopDeplasareTypeId: number | undefined;
    documentType: string | undefined;
    decontList: DecontListDto[] | undefined;
}

export class DecontEditDto implements IDecontEditDto {
    id: number;
    decontNumber: number;
    decontDate: moment.Moment;
    currencyId: number;
    thirdPartyId: number;
    thirdPartyName: string | undefined;
    diurnaZi: number | undefined;
    diurnaImpozabila: number | undefined;
    diurnaLegala: number | undefined;
    diurnaLegalaId: number | undefined;
    totalDiurnaAcordata: number;
    nrZile: number | undefined;
    totalDiurnaImpozabila: number;
    dateStart: moment.Moment | undefined;
    dateEnd: moment.Moment | undefined;
    decontTypeId: number | undefined;
    decontType: string | undefined;
    tenantId: number;
    state: State;
    scopDeplasareTypeId: number;
    documentType: string | undefined;
    totalDiurnaAcordataFileDoc: number;
    operationId: number | undefined;

    constructor(data?: IDecontEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.decontNumber = _data["decontNumber"];
            this.decontDate = _data["decontDate"] ? moment(_data["decontDate"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdPartyName = _data["thirdPartyName"];
            this.diurnaZi = _data["diurnaZi"];
            this.diurnaImpozabila = _data["diurnaImpozabila"];
            this.diurnaLegala = _data["diurnaLegala"];
            this.diurnaLegalaId = _data["diurnaLegalaId"];
            this.totalDiurnaAcordata = _data["totalDiurnaAcordata"];
            this.nrZile = _data["nrZile"];
            this.totalDiurnaImpozabila = _data["totalDiurnaImpozabila"];
            this.dateStart = _data["dateStart"] ? moment(_data["dateStart"].toString()) : <any>undefined;
            this.dateEnd = _data["dateEnd"] ? moment(_data["dateEnd"].toString()) : <any>undefined;
            this.decontTypeId = _data["decontTypeId"];
            this.decontType = _data["decontType"];
            this.tenantId = _data["tenantId"];
            this.state = _data["state"];
            this.scopDeplasareTypeId = _data["scopDeplasareTypeId"];
            this.documentType = _data["documentType"];
            this.totalDiurnaAcordataFileDoc = _data["totalDiurnaAcordataFileDoc"];
            this.operationId = _data["operationId"];
        }
    }

    static fromJS(data: any): DecontEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DecontEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["decontNumber"] = this.decontNumber;
        data["decontDate"] = this.decontDate ? this.decontDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdPartyName"] = this.thirdPartyName;
        data["diurnaZi"] = this.diurnaZi;
        data["diurnaImpozabila"] = this.diurnaImpozabila;
        data["diurnaLegala"] = this.diurnaLegala;
        data["diurnaLegalaId"] = this.diurnaLegalaId;
        data["totalDiurnaAcordata"] = this.totalDiurnaAcordata;
        data["nrZile"] = this.nrZile;
        data["totalDiurnaImpozabila"] = this.totalDiurnaImpozabila;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        data["dateEnd"] = this.dateEnd ? this.dateEnd.toISOString() : <any>undefined;
        data["decontTypeId"] = this.decontTypeId;
        data["decontType"] = this.decontType;
        data["tenantId"] = this.tenantId;
        data["state"] = this.state;
        data["scopDeplasareTypeId"] = this.scopDeplasareTypeId;
        data["documentType"] = this.documentType;
        data["totalDiurnaAcordataFileDoc"] = this.totalDiurnaAcordataFileDoc;
        data["operationId"] = this.operationId;
        return data;
    }

    clone(): DecontEditDto {
        const json = this.toJSON();
        let result = new DecontEditDto();
        result.init(json);
        return result;
    }
}

export interface IDecontEditDto {
    id: number;
    decontNumber: number;
    decontDate: moment.Moment;
    currencyId: number;
    thirdPartyId: number;
    thirdPartyName: string | undefined;
    diurnaZi: number | undefined;
    diurnaImpozabila: number | undefined;
    diurnaLegala: number | undefined;
    diurnaLegalaId: number | undefined;
    totalDiurnaAcordata: number;
    nrZile: number | undefined;
    totalDiurnaImpozabila: number;
    dateStart: moment.Moment | undefined;
    dateEnd: moment.Moment | undefined;
    decontTypeId: number | undefined;
    decontType: string | undefined;
    tenantId: number;
    state: State;
    scopDeplasareTypeId: number;
    documentType: string | undefined;
    totalDiurnaAcordataFileDoc: number;
    operationId: number | undefined;
}

export class DepartamentListDto implements IDepartamentListDto {
    id: number;
    name: string | undefined;

    constructor(data?: IDepartamentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DepartamentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartamentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): DepartamentListDto {
        const json = this.toJSON();
        let result = new DepartamentListDto();
        result.init(json);
        return result;
    }
}

export interface IDepartamentListDto {
    id: number;
    name: string | undefined;
}

export class DepositEditDto implements IDepositEditDto {
    id: number;
    operationType: OperationType;
    operationDate: moment.Moment;
    dispositionNumber: number;
    dispositionDate: moment.Moment;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    description: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    sumOper: number;
    state: State;
    bankAccountId: number;
    bankId: number;
    tenantId: number;

    constructor(data?: IDepositEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationType = _data["operationType"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.dispositionNumber = _data["dispositionNumber"];
            this.dispositionDate = _data["dispositionDate"] ? moment(_data["dispositionDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.description = _data["description"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.sumOper = _data["sumOper"];
            this.state = _data["state"];
            this.bankAccountId = _data["bankAccountId"];
            this.bankId = _data["bankId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): DepositEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepositEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationType"] = this.operationType;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["dispositionNumber"] = this.dispositionNumber;
        data["dispositionDate"] = this.dispositionDate ? this.dispositionDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["description"] = this.description;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["sumOper"] = this.sumOper;
        data["state"] = this.state;
        data["bankAccountId"] = this.bankAccountId;
        data["bankId"] = this.bankId;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): DepositEditDto {
        const json = this.toJSON();
        let result = new DepositEditDto();
        result.init(json);
        return result;
    }
}

export interface IDepositEditDto {
    id: number;
    operationType: OperationType;
    operationDate: moment.Moment;
    dispositionNumber: number;
    dispositionDate: moment.Moment;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    description: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    sumOper: number;
    state: State;
    bankAccountId: number;
    bankId: number;
    tenantId: number;
}

export class DepositListDto implements IDepositListDto {
    id: number;
    operationType: string | undefined;
    dispositionNumber: number;
    dispositionDate: moment.Moment;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    description: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    sumOper: number;
    state: State;
    bankAccountId: number | undefined;
    bankName: string | undefined;
    bankAcount: string | undefined;

    constructor(data?: IDepositListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationType = _data["operationType"];
            this.dispositionNumber = _data["dispositionNumber"];
            this.dispositionDate = _data["dispositionDate"] ? moment(_data["dispositionDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.description = _data["description"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.sumOper = _data["sumOper"];
            this.state = _data["state"];
            this.bankAccountId = _data["bankAccountId"];
            this.bankName = _data["bankName"];
            this.bankAcount = _data["bankAcount"];
        }
    }

    static fromJS(data: any): DepositListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepositListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationType"] = this.operationType;
        data["dispositionNumber"] = this.dispositionNumber;
        data["dispositionDate"] = this.dispositionDate ? this.dispositionDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["description"] = this.description;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["sumOper"] = this.sumOper;
        data["state"] = this.state;
        data["bankAccountId"] = this.bankAccountId;
        data["bankName"] = this.bankName;
        data["bankAcount"] = this.bankAcount;
        return data;
    }

    clone(): DepositListDto {
        const json = this.toJSON();
        let result = new DepositListDto();
        result.init(json);
        return result;
    }
}

export interface IDepositListDto {
    id: number;
    operationType: string | undefined;
    dispositionNumber: number;
    dispositionDate: moment.Moment;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    description: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    sumOper: number;
    state: State;
    bankAccountId: number | undefined;
    bankName: string | undefined;
    bankAcount: string | undefined;
}

export class ThirdPartyAccListDto implements IThirdPartyAccListDto {
    id: number;
    bankName: string | undefined;
    iban: string | undefined;
    currency: string | undefined;
    thirdPartyId: number;

    constructor(data?: IThirdPartyAccListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankName = _data["bankName"];
            this.iban = _data["iban"];
            this.currency = _data["currency"];
            this.thirdPartyId = _data["thirdPartyId"];
        }
    }

    static fromJS(data: any): ThirdPartyAccListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThirdPartyAccListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankName"] = this.bankName;
        data["iban"] = this.iban;
        data["currency"] = this.currency;
        data["thirdPartyId"] = this.thirdPartyId;
        return data;
    }

    clone(): ThirdPartyAccListDto {
        const json = this.toJSON();
        let result = new ThirdPartyAccListDto();
        result.init(json);
        return result;
    }
}

export interface IThirdPartyAccListDto {
    id: number;
    bankName: string | undefined;
    iban: string | undefined;
    currency: string | undefined;
    thirdPartyId: number;
}

export class DispositionListDto implements IDispositionListDto {
    id: number;
    thirdPartyId: number;
    thirdPartyName: string | undefined;
    operationTypeId: number;
    operationType: string | undefined;
    operationDate: moment.Moment;
    dispositionNumber: number;
    dispositionDate: moment.Moment;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    description: string | undefined;
    documentTypeId: number | undefined;
    documentTypeName: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment | undefined;
    invoiceId: number | undefined;
    dispositionOperStatus: number | undefined;
    sumOper: number;
    state: State;

    constructor(data?: IDispositionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdPartyName = _data["thirdPartyName"];
            this.operationTypeId = _data["operationTypeId"];
            this.operationType = _data["operationType"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.dispositionNumber = _data["dispositionNumber"];
            this.dispositionDate = _data["dispositionDate"] ? moment(_data["dispositionDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.description = _data["description"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentTypeName = _data["documentTypeName"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.invoiceId = _data["invoiceId"];
            this.dispositionOperStatus = _data["dispositionOperStatus"];
            this.sumOper = _data["sumOper"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): DispositionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispositionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdPartyName"] = this.thirdPartyName;
        data["operationTypeId"] = this.operationTypeId;
        data["operationType"] = this.operationType;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["dispositionNumber"] = this.dispositionNumber;
        data["dispositionDate"] = this.dispositionDate ? this.dispositionDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["description"] = this.description;
        data["documentTypeId"] = this.documentTypeId;
        data["documentTypeName"] = this.documentTypeName;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["dispositionOperStatus"] = this.dispositionOperStatus;
        data["sumOper"] = this.sumOper;
        data["state"] = this.state;
        return data;
    }

    clone(): DispositionListDto {
        const json = this.toJSON();
        let result = new DispositionListDto();
        result.init(json);
        return result;
    }
}

export interface IDispositionListDto {
    id: number;
    thirdPartyId: number;
    thirdPartyName: string | undefined;
    operationTypeId: number;
    operationType: string | undefined;
    operationDate: moment.Moment;
    dispositionNumber: number;
    dispositionDate: moment.Moment;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    description: string | undefined;
    documentTypeId: number | undefined;
    documentTypeName: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment | undefined;
    invoiceId: number | undefined;
    dispositionOperStatus: number | undefined;
    sumOper: number;
    state: State;
}

export class InvoiceListSelectableDto implements IInvoiceListSelectableDto {
    id: number;
    details: string | undefined;
    totalValue: number;
    remainingValue: number;
    rest: number;
    payedValue: number;
    currencyId: number | undefined;
    thirdPartyId: number | undefined;
    selected: boolean;

    constructor(data?: IInvoiceListSelectableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
            this.totalValue = _data["totalValue"];
            this.remainingValue = _data["remainingValue"];
            this.rest = _data["rest"];
            this.payedValue = _data["payedValue"];
            this.currencyId = _data["currencyId"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.selected = _data["selected"];
        }
    }

    static fromJS(data: any): InvoiceListSelectableDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceListSelectableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        data["totalValue"] = this.totalValue;
        data["remainingValue"] = this.remainingValue;
        data["rest"] = this.rest;
        data["payedValue"] = this.payedValue;
        data["currencyId"] = this.currencyId;
        data["thirdPartyId"] = this.thirdPartyId;
        data["selected"] = this.selected;
        return data;
    }

    clone(): InvoiceListSelectableDto {
        const json = this.toJSON();
        let result = new InvoiceListSelectableDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceListSelectableDto {
    id: number;
    details: string | undefined;
    totalValue: number;
    remainingValue: number;
    rest: number;
    payedValue: number;
    currencyId: number | undefined;
    thirdPartyId: number | undefined;
    selected: boolean;
}

export class DispositionEditDto implements IDispositionEditDto {
    id: number;
    thirdPartyId: number;
    thirdPartyName: string | undefined;
    operationType: OperationType;
    operationTypeId: number | undefined;
    dispositionNumber: number;
    dispositionDate: moment.Moment;
    value: number;
    documentTypeId: number | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment | undefined;
    categoryElementId: number | undefined;
    elementId: number | undefined;
    currencyId: number | undefined;
    currencyName: string | undefined;
    description: string | undefined;
    sumOper: number;
    operationId: number | undefined;
    state: State;
    tenantId: number;
    nrChitanta: number | undefined;
    numePrenume: string | undefined;
    tipDoc: string | undefined;
    actIdentitate: string | undefined;
    invoiceList: InvoiceListSelectableDto[] | undefined;

    constructor(data?: IDispositionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdPartyName = _data["thirdPartyName"];
            this.operationType = _data["operationType"];
            this.operationTypeId = _data["operationTypeId"];
            this.dispositionNumber = _data["dispositionNumber"];
            this.dispositionDate = _data["dispositionDate"] ? moment(_data["dispositionDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.categoryElementId = _data["categoryElementId"];
            this.elementId = _data["elementId"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.description = _data["description"];
            this.sumOper = _data["sumOper"];
            this.operationId = _data["operationId"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.nrChitanta = _data["nrChitanta"];
            this.numePrenume = _data["numePrenume"];
            this.tipDoc = _data["tipDoc"];
            this.actIdentitate = _data["actIdentitate"];
            if (Array.isArray(_data["invoiceList"])) {
                this.invoiceList = [] as any;
                for (let item of _data["invoiceList"])
                    this.invoiceList.push(InvoiceListSelectableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DispositionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispositionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdPartyName"] = this.thirdPartyName;
        data["operationType"] = this.operationType;
        data["operationTypeId"] = this.operationTypeId;
        data["dispositionNumber"] = this.dispositionNumber;
        data["dispositionDate"] = this.dispositionDate ? this.dispositionDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["documentTypeId"] = this.documentTypeId;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["categoryElementId"] = this.categoryElementId;
        data["elementId"] = this.elementId;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["description"] = this.description;
        data["sumOper"] = this.sumOper;
        data["operationId"] = this.operationId;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["nrChitanta"] = this.nrChitanta;
        data["numePrenume"] = this.numePrenume;
        data["tipDoc"] = this.tipDoc;
        data["actIdentitate"] = this.actIdentitate;
        if (Array.isArray(this.invoiceList)) {
            data["invoiceList"] = [];
            for (let item of this.invoiceList)
                data["invoiceList"].push(item.toJSON());
        }
        return data;
    }

    clone(): DispositionEditDto {
        const json = this.toJSON();
        let result = new DispositionEditDto();
        result.init(json);
        return result;
    }
}

export interface IDispositionEditDto {
    id: number;
    thirdPartyId: number;
    thirdPartyName: string | undefined;
    operationType: OperationType;
    operationTypeId: number | undefined;
    dispositionNumber: number;
    dispositionDate: moment.Moment;
    value: number;
    documentTypeId: number | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment | undefined;
    categoryElementId: number | undefined;
    elementId: number | undefined;
    currencyId: number | undefined;
    currencyName: string | undefined;
    description: string | undefined;
    sumOper: number;
    operationId: number | undefined;
    state: State;
    tenantId: number;
    nrChitanta: number | undefined;
    numePrenume: string | undefined;
    tipDoc: string | undefined;
    actIdentitate: string | undefined;
    invoiceList: InvoiceListSelectableDto[] | undefined;
}

export class DiurnaListDto implements IDiurnaListDto {
    id: number;
    countryName: string | undefined;
    currencyName: string | undefined;
    dataValabilitate: moment.Moment;
    value: number;
    diurnaTypeName: string | undefined;
    tenantId: number;

    constructor(data?: IDiurnaListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryName = _data["countryName"];
            this.currencyName = _data["currencyName"];
            this.dataValabilitate = _data["dataValabilitate"] ? moment(_data["dataValabilitate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.diurnaTypeName = _data["diurnaTypeName"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): DiurnaListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiurnaListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryName"] = this.countryName;
        data["currencyName"] = this.currencyName;
        data["dataValabilitate"] = this.dataValabilitate ? this.dataValabilitate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["diurnaTypeName"] = this.diurnaTypeName;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): DiurnaListDto {
        const json = this.toJSON();
        let result = new DiurnaListDto();
        result.init(json);
        return result;
    }
}

export interface IDiurnaListDto {
    id: number;
    countryName: string | undefined;
    currencyName: string | undefined;
    dataValabilitate: moment.Moment;
    value: number;
    diurnaTypeName: string | undefined;
    tenantId: number;
}

export class DiurnaEditDto implements IDiurnaEditDto {
    id: number;
    countryId: number;
    currencyId: number;
    value: number;
    dataValabilitate: moment.Moment;
    diurnaTypeId: number | undefined;
    tenantId: number;

    constructor(data?: IDiurnaEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryId = _data["countryId"];
            this.currencyId = _data["currencyId"];
            this.value = _data["value"];
            this.dataValabilitate = _data["dataValabilitate"] ? moment(_data["dataValabilitate"].toString()) : <any>undefined;
            this.diurnaTypeId = _data["diurnaTypeId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): DiurnaEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiurnaEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        data["currencyId"] = this.currencyId;
        data["value"] = this.value;
        data["dataValabilitate"] = this.dataValabilitate ? this.dataValabilitate.toISOString() : <any>undefined;
        data["diurnaTypeId"] = this.diurnaTypeId;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): DiurnaEditDto {
        const json = this.toJSON();
        let result = new DiurnaEditDto();
        result.init(json);
        return result;
    }
}

export interface IDiurnaEditDto {
    id: number;
    countryId: number;
    currencyId: number;
    value: number;
    dataValabilitate: moment.Moment;
    diurnaTypeId: number | undefined;
    tenantId: number;
}

export class DobanziReferintaDto implements IDobanziReferintaDto {
    id: number;
    dobanda: string | undefined;
    descriere: string | undefined;
    perioadaCalcul: number;

    constructor(data?: IDobanziReferintaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dobanda = _data["dobanda"];
            this.descriere = _data["descriere"];
            this.perioadaCalcul = _data["perioadaCalcul"];
        }
    }

    static fromJS(data: any): DobanziReferintaDto {
        data = typeof data === 'object' ? data : {};
        let result = new DobanziReferintaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dobanda"] = this.dobanda;
        data["descriere"] = this.descriere;
        data["perioadaCalcul"] = this.perioadaCalcul;
        return data;
    }

    clone(): DobanziReferintaDto {
        const json = this.toJSON();
        let result = new DobanziReferintaDto();
        result.init(json);
        return result;
    }
}

export interface IDobanziReferintaDto {
    id: number;
    dobanda: string | undefined;
    descriere: string | undefined;
    perioadaCalcul: number;
}

export class DobanziReferintaEditDto implements IDobanziReferintaEditDto {
    id: number;
    dobanda: string | undefined;
    descriere: string | undefined;
    perioadaCalcul: number;
    okDelete: boolean;

    constructor(data?: IDobanziReferintaEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dobanda = _data["dobanda"];
            this.descriere = _data["descriere"];
            this.perioadaCalcul = _data["perioadaCalcul"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): DobanziReferintaEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DobanziReferintaEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dobanda"] = this.dobanda;
        data["descriere"] = this.descriere;
        data["perioadaCalcul"] = this.perioadaCalcul;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): DobanziReferintaEditDto {
        const json = this.toJSON();
        let result = new DobanziReferintaEditDto();
        result.init(json);
        return result;
    }
}

export interface IDobanziReferintaEditDto {
    id: number;
    dobanda: string | undefined;
    descriere: string | undefined;
    perioadaCalcul: number;
    okDelete: boolean;
}

export class DocumentTypeListDDDto implements IDocumentTypeListDDDto {
    id: number;
    typeName: string | undefined;
    typeNameShort: string | undefined;
    name: string | undefined;

    constructor(data?: IDocumentTypeListDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.typeNameShort = _data["typeNameShort"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DocumentTypeListDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeListDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["typeNameShort"] = this.typeNameShort;
        data["name"] = this.name;
        return data;
    }

    clone(): DocumentTypeListDDDto {
        const json = this.toJSON();
        let result = new DocumentTypeListDDDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentTypeListDDDto {
    id: number;
    typeName: string | undefined;
    typeNameShort: string | undefined;
    name: string | undefined;
}

export class GetDocumentTypeOutput implements IGetDocumentTypeOutput {
    getDocumentType: DocumentTypeListDDDto[] | undefined;

    constructor(data?: IGetDocumentTypeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getDocumentType"])) {
                this.getDocumentType = [] as any;
                for (let item of _data["getDocumentType"])
                    this.getDocumentType.push(DocumentTypeListDDDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDocumentTypeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentTypeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getDocumentType)) {
            data["getDocumentType"] = [];
            for (let item of this.getDocumentType)
                data["getDocumentType"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetDocumentTypeOutput {
        const json = this.toJSON();
        let result = new GetDocumentTypeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentTypeOutput {
    getDocumentType: DocumentTypeListDDDto[] | undefined;
}

export class DocumentTypeEditDto implements IDocumentTypeEditDto {
    id: number;
    typeName: string | undefined;
    typeNameShort: string | undefined;
    editable: boolean;
    autoNumber: boolean;
    closingMonth: boolean;
    appClientId: number;

    constructor(data?: IDocumentTypeEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeName = _data["typeName"];
            this.typeNameShort = _data["typeNameShort"];
            this.editable = _data["editable"];
            this.autoNumber = _data["autoNumber"];
            this.closingMonth = _data["closingMonth"];
            this.appClientId = _data["appClientId"];
        }
    }

    static fromJS(data: any): DocumentTypeEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        data["typeNameShort"] = this.typeNameShort;
        data["editable"] = this.editable;
        data["autoNumber"] = this.autoNumber;
        data["closingMonth"] = this.closingMonth;
        data["appClientId"] = this.appClientId;
        return data;
    }

    clone(): DocumentTypeEditDto {
        const json = this.toJSON();
        let result = new DocumentTypeEditDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentTypeEditDto {
    id: number;
    typeName: string | undefined;
    typeNameShort: string | undefined;
    editable: boolean;
    autoNumber: boolean;
    closingMonth: boolean;
    appClientId: number;
}

export class ImoAssetOperTypeDto implements IImoAssetOperTypeDto {
    id: number;
    name: string | undefined;

    constructor(data?: IImoAssetOperTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ImoAssetOperTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetOperTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ImoAssetOperTypeDto {
        const json = this.toJSON();
        let result = new ImoAssetOperTypeDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetOperTypeDto {
    id: number;
    name: string | undefined;
}

export class GetImoAssetOperTypeOutput implements IGetImoAssetOperTypeOutput {
    getImoAssetOperType: ImoAssetOperTypeDto[] | undefined;

    constructor(data?: IGetImoAssetOperTypeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getImoAssetOperType"])) {
                this.getImoAssetOperType = [] as any;
                for (let item of _data["getImoAssetOperType"])
                    this.getImoAssetOperType.push(ImoAssetOperTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetImoAssetOperTypeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetImoAssetOperTypeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getImoAssetOperType)) {
            data["getImoAssetOperType"] = [];
            for (let item of this.getImoAssetOperType)
                data["getImoAssetOperType"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetImoAssetOperTypeOutput {
        const json = this.toJSON();
        let result = new GetImoAssetOperTypeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetImoAssetOperTypeOutput {
    getImoAssetOperType: ImoAssetOperTypeDto[] | undefined;
}

export class InvOperationTypeDto implements IInvOperationTypeDto {
    id: number;
    name: string | undefined;

    constructor(data?: IInvOperationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): InvOperationTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvOperationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): InvOperationTypeDto {
        const json = this.toJSON();
        let result = new InvOperationTypeDto();
        result.init(json);
        return result;
    }
}

export interface IInvOperationTypeDto {
    id: number;
    name: string | undefined;
}

export class GetInvOperationTypeOutput implements IGetInvOperationTypeOutput {
    getInvOperationType: InvOperationTypeDto[] | undefined;

    constructor(data?: IGetInvOperationTypeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getInvOperationType"])) {
                this.getInvOperationType = [] as any;
                for (let item of _data["getInvOperationType"])
                    this.getInvOperationType.push(InvOperationTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInvOperationTypeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvOperationTypeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getInvOperationType)) {
            data["getInvOperationType"] = [];
            for (let item of this.getInvOperationType)
                data["getInvOperationType"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetInvOperationTypeOutput {
        const json = this.toJSON();
        let result = new GetInvOperationTypeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInvOperationTypeOutput {
    getInvOperationType: InvOperationTypeDto[] | undefined;
}

export class PrepaymentOperationTypeDto implements IPrepaymentOperationTypeDto {
    id: number;
    name: string | undefined;

    constructor(data?: IPrepaymentOperationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PrepaymentOperationTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentOperationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): PrepaymentOperationTypeDto {
        const json = this.toJSON();
        let result = new PrepaymentOperationTypeDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentOperationTypeDto {
    id: number;
    name: string | undefined;
}

export class EnumTypeDto implements IEnumTypeDto {
    id: number;
    name: string | undefined;

    constructor(data?: IEnumTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EnumTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnumTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): EnumTypeDto {
        const json = this.toJSON();
        let result = new EnumTypeDto();
        result.init(json);
        return result;
    }
}

export interface IEnumTypeDto {
    id: number;
    name: string | undefined;
}

export class EnumImprumutTipDetaliuDescriereDto implements IEnumImprumutTipDetaliuDescriereDto {
    id: string | undefined;
    name: string | undefined;

    constructor(data?: IEnumImprumutTipDetaliuDescriereDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EnumImprumutTipDetaliuDescriereDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnumImprumutTipDetaliuDescriereDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): EnumImprumutTipDetaliuDescriereDto {
        const json = this.toJSON();
        let result = new EnumImprumutTipDetaliuDescriereDto();
        result.init(json);
        return result;
    }
}

export interface IEnumImprumutTipDetaliuDescriereDto {
    id: string | undefined;
    name: string | undefined;
}

export class ExchangeListDto implements IExchangeListDto {
    id: number;
    exchangeOperType: string | undefined;
    operationType: string | undefined;
    bankAccountLei: string | undefined;
    bankAccountValuta: string | undefined;
    operationDate: moment.Moment;
    value: number;
    exchangeRate: number;
    currencyName: string | undefined;
    state: State;

    constructor(data?: IExchangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exchangeOperType = _data["exchangeOperType"];
            this.operationType = _data["operationType"];
            this.bankAccountLei = _data["bankAccountLei"];
            this.bankAccountValuta = _data["bankAccountValuta"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.exchangeRate = _data["exchangeRate"];
            this.currencyName = _data["currencyName"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): ExchangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exchangeOperType"] = this.exchangeOperType;
        data["operationType"] = this.operationType;
        data["bankAccountLei"] = this.bankAccountLei;
        data["bankAccountValuta"] = this.bankAccountValuta;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["exchangeRate"] = this.exchangeRate;
        data["currencyName"] = this.currencyName;
        data["state"] = this.state;
        return data;
    }

    clone(): ExchangeListDto {
        const json = this.toJSON();
        let result = new ExchangeListDto();
        result.init(json);
        return result;
    }
}

export interface IExchangeListDto {
    id: number;
    exchangeOperType: string | undefined;
    operationType: string | undefined;
    bankAccountLei: string | undefined;
    bankAccountValuta: string | undefined;
    operationDate: moment.Moment;
    value: number;
    exchangeRate: number;
    currencyName: string | undefined;
    state: State;
}

export class ExchangeInitDto implements IExchangeInitDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    operationTypeId: number | undefined;
    currencyId: number | undefined;
    exchangeList: ExchangeListDto[] | undefined;

    constructor(data?: IExchangeInitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.operationTypeId = _data["operationTypeId"];
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["exchangeList"])) {
                this.exchangeList = [] as any;
                for (let item of _data["exchangeList"])
                    this.exchangeList.push(ExchangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExchangeInitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeInitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["operationTypeId"] = this.operationTypeId;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.exchangeList)) {
            data["exchangeList"] = [];
            for (let item of this.exchangeList)
                data["exchangeList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExchangeInitDto {
        const json = this.toJSON();
        let result = new ExchangeInitDto();
        result.init(json);
        return result;
    }
}

export interface IExchangeInitDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    operationTypeId: number | undefined;
    currencyId: number | undefined;
    exchangeList: ExchangeListDto[] | undefined;
}

export class ExchangeEditDto implements IExchangeEditDto {
    id: number;
    operationDate: moment.Moment;
    exchangeDate: moment.Moment;
    value: number;
    exchangedValue: number;
    exchangeOperType: number | undefined;
    operationType: number | undefined;
    currencyId: number | undefined;
    localCurrencyCode: string | undefined;
    currencyCode: string | undefined;
    bankAccountLeiId: number | undefined;
    bankAccountValutaId: number | undefined;
    bankLeiId: number | undefined;
    bankValutaId: number | undefined;
    activityTypeId: number | undefined;
    exchangeRate: number;
    contaOperationId: number | undefined;
    tenantId: number;

    constructor(data?: IExchangeEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.exchangeDate = _data["exchangeDate"] ? moment(_data["exchangeDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.exchangedValue = _data["exchangedValue"];
            this.exchangeOperType = _data["exchangeOperType"];
            this.operationType = _data["operationType"];
            this.currencyId = _data["currencyId"];
            this.localCurrencyCode = _data["localCurrencyCode"];
            this.currencyCode = _data["currencyCode"];
            this.bankAccountLeiId = _data["bankAccountLeiId"];
            this.bankAccountValutaId = _data["bankAccountValutaId"];
            this.bankLeiId = _data["bankLeiId"];
            this.bankValutaId = _data["bankValutaId"];
            this.activityTypeId = _data["activityTypeId"];
            this.exchangeRate = _data["exchangeRate"];
            this.contaOperationId = _data["contaOperationId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): ExchangeEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["exchangeDate"] = this.exchangeDate ? this.exchangeDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["exchangedValue"] = this.exchangedValue;
        data["exchangeOperType"] = this.exchangeOperType;
        data["operationType"] = this.operationType;
        data["currencyId"] = this.currencyId;
        data["localCurrencyCode"] = this.localCurrencyCode;
        data["currencyCode"] = this.currencyCode;
        data["bankAccountLeiId"] = this.bankAccountLeiId;
        data["bankAccountValutaId"] = this.bankAccountValutaId;
        data["bankLeiId"] = this.bankLeiId;
        data["bankValutaId"] = this.bankValutaId;
        data["activityTypeId"] = this.activityTypeId;
        data["exchangeRate"] = this.exchangeRate;
        data["contaOperationId"] = this.contaOperationId;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): ExchangeEditDto {
        const json = this.toJSON();
        let result = new ExchangeEditDto();
        result.init(json);
        return result;
    }
}

export interface IExchangeEditDto {
    id: number;
    operationDate: moment.Moment;
    exchangeDate: moment.Moment;
    value: number;
    exchangedValue: number;
    exchangeOperType: number | undefined;
    operationType: number | undefined;
    currencyId: number | undefined;
    localCurrencyCode: string | undefined;
    currencyCode: string | undefined;
    bankAccountLeiId: number | undefined;
    bankAccountValutaId: number | undefined;
    bankLeiId: number | undefined;
    bankValutaId: number | undefined;
    activityTypeId: number | undefined;
    exchangeRate: number;
    contaOperationId: number | undefined;
    tenantId: number;
}

export class ExchangeRateForecastDto implements IExchangeRateForecastDto {
    id: number;
    currency: string | undefined;
    valoareEstimata: number;

    constructor(data?: IExchangeRateForecastDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currency = _data["currency"];
            this.valoareEstimata = _data["valoareEstimata"];
        }
    }

    static fromJS(data: any): ExchangeRateForecastDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeRateForecastDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currency"] = this.currency;
        data["valoareEstimata"] = this.valoareEstimata;
        return data;
    }

    clone(): ExchangeRateForecastDto {
        const json = this.toJSON();
        let result = new ExchangeRateForecastDto();
        result.init(json);
        return result;
    }
}

export interface IExchangeRateForecastDto {
    id: number;
    currency: string | undefined;
    valoareEstimata: number;
}

export class ExchangeRateForecastEditDto implements IExchangeRateForecastEditDto {
    id: number;
    currencyId: number | undefined;
    valoareEstimata: number;
    tenantId: number;
    year: number;
    state: State;

    constructor(data?: IExchangeRateForecastEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyId = _data["currencyId"];
            this.valoareEstimata = _data["valoareEstimata"];
            this.tenantId = _data["tenantId"];
            this.year = _data["year"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): ExchangeRateForecastEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeRateForecastEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyId"] = this.currencyId;
        data["valoareEstimata"] = this.valoareEstimata;
        data["tenantId"] = this.tenantId;
        data["year"] = this.year;
        data["state"] = this.state;
        return data;
    }

    clone(): ExchangeRateForecastEditDto {
        const json = this.toJSON();
        let result = new ExchangeRateForecastEditDto();
        result.init(json);
        return result;
    }
}

export interface IExchangeRateForecastEditDto {
    id: number;
    currencyId: number | undefined;
    valoareEstimata: number;
    tenantId: number;
    year: number;
    state: State;
}

export class AtasamentDTO implements IAtasamentDTO {
    denumire: string | undefined;
    id: number;

    constructor(data?: IAtasamentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.denumire = _data["denumire"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AtasamentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AtasamentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["denumire"] = this.denumire;
        data["id"] = this.id;
        return data;
    }

    clone(): AtasamentDTO {
        const json = this.toJSON();
        let result = new AtasamentDTO();
        result.init(json);
        return result;
    }
}

export interface IAtasamentDTO {
    denumire: string | undefined;
    id: number;
}

export class AtasamentFileDTO implements IAtasamentFileDTO {
    content: string | undefined;
    fileName: string | undefined;

    constructor(data?: IAtasamentFileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): AtasamentFileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AtasamentFileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["fileName"] = this.fileName;
        return data;
    }

    clone(): AtasamentFileDTO {
        const json = this.toJSON();
        let result = new AtasamentFileDTO();
        result.init(json);
        return result;
    }
}

export interface IAtasamentFileDTO {
    content: string | undefined;
    fileName: string | undefined;
}

export class FileDocErrorDto implements IFileDocErrorDto {
    documentId: number;
    documentNr: string | undefined;
    mesajEroare: string | undefined;
    rezolvat: boolean;
    lastErrorDate: moment.Moment;
    rezolvatDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IFileDocErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentId = _data["documentId"];
            this.documentNr = _data["documentNr"];
            this.mesajEroare = _data["mesajEroare"];
            this.rezolvat = _data["rezolvat"];
            this.lastErrorDate = _data["lastErrorDate"] ? moment(_data["lastErrorDate"].toString()) : <any>undefined;
            this.rezolvatDate = _data["rezolvatDate"] ? moment(_data["rezolvatDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FileDocErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDocErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentNr"] = this.documentNr;
        data["mesajEroare"] = this.mesajEroare;
        data["rezolvat"] = this.rezolvat;
        data["lastErrorDate"] = this.lastErrorDate ? this.lastErrorDate.toISOString() : <any>undefined;
        data["rezolvatDate"] = this.rezolvatDate ? this.rezolvatDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): FileDocErrorDto {
        const json = this.toJSON();
        let result = new FileDocErrorDto();
        result.init(json);
        return result;
    }
}

export interface IFileDocErrorDto {
    documentId: number;
    documentNr: string | undefined;
    mesajEroare: string | undefined;
    rezolvat: boolean;
    lastErrorDate: moment.Moment;
    rezolvatDate: moment.Moment | undefined;
    id: number;
}

export class ForeignOperationAccountingList implements IForeignOperationAccountingList {
    id: number;
    detailOperId: number;
    value: number;
    valueCurr: number;
    details: string | undefined;
    debitAccountId: number | undefined;
    debitAccount: string | undefined;
    creditAccountId: number | undefined;
    creditAccount: string | undefined;
    operationsDetailId: number | undefined;
    readonly ncGenerated: boolean;

    constructor(data?: IForeignOperationAccountingList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.detailOperId = _data["detailOperId"];
            this.value = _data["value"];
            this.valueCurr = _data["valueCurr"];
            this.details = _data["details"];
            this.debitAccountId = _data["debitAccountId"];
            this.debitAccount = _data["debitAccount"];
            this.creditAccountId = _data["creditAccountId"];
            this.creditAccount = _data["creditAccount"];
            this.operationsDetailId = _data["operationsDetailId"];
            (<any>this).ncGenerated = _data["ncGenerated"];
        }
    }

    static fromJS(data: any): ForeignOperationAccountingList {
        data = typeof data === 'object' ? data : {};
        let result = new ForeignOperationAccountingList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detailOperId"] = this.detailOperId;
        data["value"] = this.value;
        data["valueCurr"] = this.valueCurr;
        data["details"] = this.details;
        data["debitAccountId"] = this.debitAccountId;
        data["debitAccount"] = this.debitAccount;
        data["creditAccountId"] = this.creditAccountId;
        data["creditAccount"] = this.creditAccount;
        data["operationsDetailId"] = this.operationsDetailId;
        data["ncGenerated"] = this.ncGenerated;
        return data;
    }

    clone(): ForeignOperationAccountingList {
        const json = this.toJSON();
        let result = new ForeignOperationAccountingList();
        result.init(json);
        return result;
    }
}

export interface IForeignOperationAccountingList {
    id: number;
    detailOperId: number;
    value: number;
    valueCurr: number;
    details: string | undefined;
    debitAccountId: number | undefined;
    debitAccount: string | undefined;
    creditAccountId: number | undefined;
    creditAccount: string | undefined;
    operationsDetailId: number | undefined;
    ncGenerated: boolean;
}

export class PaymentOrderForForeignOperationDto implements IPaymentOrderForForeignOperationDto {
    id: number;
    payerBank: string | undefined;
    paymentDetails: string | undefined;

    constructor(data?: IPaymentOrderForForeignOperationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.payerBank = _data["payerBank"];
            this.paymentDetails = _data["paymentDetails"];
        }
    }

    static fromJS(data: any): PaymentOrderForForeignOperationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentOrderForForeignOperationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["payerBank"] = this.payerBank;
        data["paymentDetails"] = this.paymentDetails;
        return data;
    }

    clone(): PaymentOrderForForeignOperationDto {
        const json = this.toJSON();
        let result = new PaymentOrderForForeignOperationDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentOrderForForeignOperationDto {
    id: number;
    payerBank: string | undefined;
    paymentDetails: string | undefined;
}

export class ForeignOperationList implements IForeignOperationList {
    id: number;
    foreignOperId: number;
    currencyId: number;
    bankAccountId: number;
    bankAccount: string | undefined;
    documentTypeId: number;
    documentTypeStr: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    operationDate: moment.Moment;
    value: number;
    valueCurr: number;
    originalDetails: string | undefined;
    selectedPaymentOrderId: number | undefined;
    selectedPaymentOrderDetails: string | undefined;
    selectedOP: boolean;
    paymentOrderId: number | undefined;
    paymentOrder: string | undefined;
    accountingList: ForeignOperationAccountingList[] | undefined;
    paymentOrdersList: PaymentOrderForForeignOperationDto[] | undefined;
    readonly ncChildGenerated: boolean;

    constructor(data?: IForeignOperationList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.foreignOperId = _data["foreignOperId"];
            this.currencyId = _data["currencyId"];
            this.bankAccountId = _data["bankAccountId"];
            this.bankAccount = _data["bankAccount"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentTypeStr = _data["documentTypeStr"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.valueCurr = _data["valueCurr"];
            this.originalDetails = _data["originalDetails"];
            this.selectedPaymentOrderId = _data["selectedPaymentOrderId"];
            this.selectedPaymentOrderDetails = _data["selectedPaymentOrderDetails"];
            this.selectedOP = _data["selectedOP"];
            this.paymentOrderId = _data["paymentOrderId"];
            this.paymentOrder = _data["paymentOrder"];
            if (Array.isArray(_data["accountingList"])) {
                this.accountingList = [] as any;
                for (let item of _data["accountingList"])
                    this.accountingList.push(ForeignOperationAccountingList.fromJS(item));
            }
            if (Array.isArray(_data["paymentOrdersList"])) {
                this.paymentOrdersList = [] as any;
                for (let item of _data["paymentOrdersList"])
                    this.paymentOrdersList.push(PaymentOrderForForeignOperationDto.fromJS(item));
            }
            (<any>this).ncChildGenerated = _data["ncChildGenerated"];
        }
    }

    static fromJS(data: any): ForeignOperationList {
        data = typeof data === 'object' ? data : {};
        let result = new ForeignOperationList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["foreignOperId"] = this.foreignOperId;
        data["currencyId"] = this.currencyId;
        data["bankAccountId"] = this.bankAccountId;
        data["bankAccount"] = this.bankAccount;
        data["documentTypeId"] = this.documentTypeId;
        data["documentTypeStr"] = this.documentTypeStr;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["valueCurr"] = this.valueCurr;
        data["originalDetails"] = this.originalDetails;
        data["selectedPaymentOrderId"] = this.selectedPaymentOrderId;
        data["selectedPaymentOrderDetails"] = this.selectedPaymentOrderDetails;
        data["selectedOP"] = this.selectedOP;
        data["paymentOrderId"] = this.paymentOrderId;
        data["paymentOrder"] = this.paymentOrder;
        if (Array.isArray(this.accountingList)) {
            data["accountingList"] = [];
            for (let item of this.accountingList)
                data["accountingList"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentOrdersList)) {
            data["paymentOrdersList"] = [];
            for (let item of this.paymentOrdersList)
                data["paymentOrdersList"].push(item.toJSON());
        }
        data["ncChildGenerated"] = this.ncChildGenerated;
        return data;
    }

    clone(): ForeignOperationList {
        const json = this.toJSON();
        let result = new ForeignOperationList();
        result.init(json);
        return result;
    }
}

export interface IForeignOperationList {
    id: number;
    foreignOperId: number;
    currencyId: number;
    bankAccountId: number;
    bankAccount: string | undefined;
    documentTypeId: number;
    documentTypeStr: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    operationDate: moment.Moment;
    value: number;
    valueCurr: number;
    originalDetails: string | undefined;
    selectedPaymentOrderId: number | undefined;
    selectedPaymentOrderDetails: string | undefined;
    selectedOP: boolean;
    paymentOrderId: number | undefined;
    paymentOrder: string | undefined;
    accountingList: ForeignOperationAccountingList[] | undefined;
    paymentOrdersList: PaymentOrderForForeignOperationDto[] | undefined;
    ncChildGenerated: boolean;
}

export class FileUploadDto implements IFileUploadDto {
    fileName: string | undefined;
    content: string | undefined;

    constructor(data?: IFileUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): FileUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["content"] = this.content;
        return data;
    }

    clone(): FileUploadDto {
        const json = this.toJSON();
        let result = new FileUploadDto();
        result.init(json);
        return result;
    }
}

export interface IFileUploadDto {
    fileName: string | undefined;
    content: string | undefined;
}

export class ForeignOperationUpload implements IForeignOperationUpload {
    bankAccountId: number | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    operationDate: moment.Moment;
    documentTypeId: number | undefined;
    fileUpld: FileUploadDto;

    constructor(data?: IForeignOperationUpload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankAccountId = _data["bankAccountId"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentTypeId = _data["documentTypeId"];
            this.fileUpld = _data["fileUpld"] ? FileUploadDto.fromJS(_data["fileUpld"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ForeignOperationUpload {
        data = typeof data === 'object' ? data : {};
        let result = new ForeignOperationUpload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentTypeId"] = this.documentTypeId;
        data["fileUpld"] = this.fileUpld ? this.fileUpld.toJSON() : <any>undefined;
        return data;
    }

    clone(): ForeignOperationUpload {
        const json = this.toJSON();
        let result = new ForeignOperationUpload();
        result.init(json);
        return result;
    }
}

export interface IForeignOperationUpload {
    bankAccountId: number | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    operationDate: moment.Moment;
    documentTypeId: number | undefined;
    fileUpld: FileUploadDto;
}

export class FODeleteList implements IFODeleteList {
    foreignOperId: number;
    bankAccountId: number;
    bankAccount: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    operationDate: moment.Moment;
    ncGenerated: boolean;

    constructor(data?: IFODeleteList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foreignOperId = _data["foreignOperId"];
            this.bankAccountId = _data["bankAccountId"];
            this.bankAccount = _data["bankAccount"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.ncGenerated = _data["ncGenerated"];
        }
    }

    static fromJS(data: any): FODeleteList {
        data = typeof data === 'object' ? data : {};
        let result = new FODeleteList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foreignOperId"] = this.foreignOperId;
        data["bankAccountId"] = this.bankAccountId;
        data["bankAccount"] = this.bankAccount;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["ncGenerated"] = this.ncGenerated;
        return data;
    }

    clone(): FODeleteList {
        const json = this.toJSON();
        let result = new FODeleteList();
        result.init(json);
        return result;
    }
}

export interface IFODeleteList {
    foreignOperId: number;
    bankAccountId: number;
    bankAccount: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    operationDate: moment.Moment;
    ncGenerated: boolean;
}

export class FOInitDeleteDto implements IFOInitDeleteDto {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    bankAccountId: number | undefined;
    list: FODeleteList[] | undefined;

    constructor(data?: IFOInitDeleteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.bankAccountId = _data["bankAccountId"];
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list.push(FODeleteList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FOInitDeleteDto {
        data = typeof data === 'object' ? data : {};
        let result = new FOInitDeleteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["bankAccountId"] = this.bankAccountId;
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        return data;
    }

    clone(): FOInitDeleteDto {
        const json = this.toJSON();
        let result = new FOInitDeleteDto();
        result.init(json);
        return result;
    }
}

export interface IFOInitDeleteDto {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    bankAccountId: number | undefined;
    list: FODeleteList[] | undefined;
}

export class ForeignOperationDto implements IForeignOperationDto {
    quickSearch: string | undefined;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    bankAccountId: number | undefined;
    contaOperation: boolean;
    tenantId: number;
    thirdPartyId: number;
    showList: boolean;
    showUploadForm: boolean;
    showDeleteForm: boolean;
    okGenerate: boolean;
    includeGenerate: boolean;
    operList: ForeignOperationList[] | undefined;
    uploadFile: ForeignOperationUpload;
    deleteForm: FOInitDeleteDto;
    readonly hideModifBtn: boolean;

    constructor(data?: IForeignOperationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quickSearch = _data["quickSearch"];
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.bankAccountId = _data["bankAccountId"];
            this.contaOperation = _data["contaOperation"];
            this.tenantId = _data["tenantId"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.showList = _data["showList"];
            this.showUploadForm = _data["showUploadForm"];
            this.showDeleteForm = _data["showDeleteForm"];
            this.okGenerate = _data["okGenerate"];
            this.includeGenerate = _data["includeGenerate"];
            if (Array.isArray(_data["operList"])) {
                this.operList = [] as any;
                for (let item of _data["operList"])
                    this.operList.push(ForeignOperationList.fromJS(item));
            }
            this.uploadFile = _data["uploadFile"] ? ForeignOperationUpload.fromJS(_data["uploadFile"]) : <any>undefined;
            this.deleteForm = _data["deleteForm"] ? FOInitDeleteDto.fromJS(_data["deleteForm"]) : <any>undefined;
            (<any>this).hideModifBtn = _data["hideModifBtn"];
        }
    }

    static fromJS(data: any): ForeignOperationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForeignOperationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quickSearch"] = this.quickSearch;
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["bankAccountId"] = this.bankAccountId;
        data["contaOperation"] = this.contaOperation;
        data["tenantId"] = this.tenantId;
        data["thirdPartyId"] = this.thirdPartyId;
        data["showList"] = this.showList;
        data["showUploadForm"] = this.showUploadForm;
        data["showDeleteForm"] = this.showDeleteForm;
        data["okGenerate"] = this.okGenerate;
        data["includeGenerate"] = this.includeGenerate;
        if (Array.isArray(this.operList)) {
            data["operList"] = [];
            for (let item of this.operList)
                data["operList"].push(item.toJSON());
        }
        data["uploadFile"] = this.uploadFile ? this.uploadFile.toJSON() : <any>undefined;
        data["deleteForm"] = this.deleteForm ? this.deleteForm.toJSON() : <any>undefined;
        data["hideModifBtn"] = this.hideModifBtn;
        return data;
    }

    clone(): ForeignOperationDto {
        const json = this.toJSON();
        let result = new ForeignOperationDto();
        result.init(json);
        return result;
    }
}

export interface IForeignOperationDto {
    quickSearch: string | undefined;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    bankAccountId: number | undefined;
    contaOperation: boolean;
    tenantId: number;
    thirdPartyId: number;
    showList: boolean;
    showUploadForm: boolean;
    showDeleteForm: boolean;
    okGenerate: boolean;
    includeGenerate: boolean;
    operList: ForeignOperationList[] | undefined;
    uploadFile: ForeignOperationUpload;
    deleteForm: FOInitDeleteDto;
    hideModifBtn: boolean;
}

export enum FODictionaryType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class FODictionaryEditDto implements IFODictionaryEditDto {
    id: number;
    tenantId: number;
    operationDate: moment.Moment;
    expression: string | undefined;
    symbol: string | undefined;
    accountId: number;
    foDictionaryType: FODictionaryType;
    accountName: string | undefined;

    constructor(data?: IFODictionaryEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.expression = _data["expression"];
            this.symbol = _data["symbol"];
            this.accountId = _data["accountId"];
            this.foDictionaryType = _data["foDictionaryType"];
            this.accountName = _data["accountName"];
        }
    }

    static fromJS(data: any): FODictionaryEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new FODictionaryEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["expression"] = this.expression;
        data["symbol"] = this.symbol;
        data["accountId"] = this.accountId;
        data["foDictionaryType"] = this.foDictionaryType;
        data["accountName"] = this.accountName;
        return data;
    }

    clone(): FODictionaryEditDto {
        const json = this.toJSON();
        let result = new FODictionaryEditDto();
        result.init(json);
        return result;
    }
}

export interface IFODictionaryEditDto {
    id: number;
    tenantId: number;
    operationDate: moment.Moment;
    expression: string | undefined;
    symbol: string | undefined;
    accountId: number;
    foDictionaryType: FODictionaryType;
    accountName: string | undefined;
}

export class FODictionaryListDto implements IFODictionaryListDto {
    id: number;
    accountId: number;
    accountName: string | undefined;
    expression: string | undefined;
    operationDate: moment.Moment;
    dictionaryType: string | undefined;

    constructor(data?: IFODictionaryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountId = _data["accountId"];
            this.accountName = _data["accountName"];
            this.expression = _data["expression"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.dictionaryType = _data["dictionaryType"];
        }
    }

    static fromJS(data: any): FODictionaryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FODictionaryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["expression"] = this.expression;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["dictionaryType"] = this.dictionaryType;
        return data;
    }

    clone(): FODictionaryListDto {
        const json = this.toJSON();
        let result = new FODictionaryListDto();
        result.init(json);
        return result;
    }
}

export interface IFODictionaryListDto {
    id: number;
    accountId: number;
    accountName: string | undefined;
    expression: string | undefined;
    operationDate: moment.Moment;
    dictionaryType: string | undefined;
}

export class FODictionaryFormDto implements IFODictionaryFormDto {
    searchAccount: string | undefined;
    fOdictionaryList: FODictionaryListDto[] | undefined;

    constructor(data?: IFODictionaryFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchAccount = _data["searchAccount"];
            if (Array.isArray(_data["fOdictionaryList"])) {
                this.fOdictionaryList = [] as any;
                for (let item of _data["fOdictionaryList"])
                    this.fOdictionaryList.push(FODictionaryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FODictionaryFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new FODictionaryFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchAccount"] = this.searchAccount;
        if (Array.isArray(this.fOdictionaryList)) {
            data["fOdictionaryList"] = [];
            for (let item of this.fOdictionaryList)
                data["fOdictionaryList"].push(item.toJSON());
        }
        return data;
    }

    clone(): FODictionaryFormDto {
        const json = this.toJSON();
        let result = new FODictionaryFormDto();
        result.init(json);
        return result;
    }
}

export interface IFODictionaryFormDto {
    searchAccount: string | undefined;
    fOdictionaryList: FODictionaryListDto[] | undefined;
}

export class GarantieDto implements IGarantieDto {
    id: number;
    tipGarantie: string | undefined;
    documentNr: number;
    legalPerson: string | undefined;
    garantieAccount: string | undefined;
    currency: string | undefined;
    garantieTip: string | undefined;
    garantieCeGaranteaza: string | undefined;
    sumaGarantiei: number;
    sold: number;
    mentiuni: string | undefined;
    ceGaranteaza: string | undefined;
    garantiePrimitaDataEnum: string | undefined;
    startDateGarantie: moment.Moment;
    endDateGarantie: moment.Moment;
    documentDate: moment.Moment;

    constructor(data?: IGarantieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tipGarantie = _data["tipGarantie"];
            this.documentNr = _data["documentNr"];
            this.legalPerson = _data["legalPerson"];
            this.garantieAccount = _data["garantieAccount"];
            this.currency = _data["currency"];
            this.garantieTip = _data["garantieTip"];
            this.garantieCeGaranteaza = _data["garantieCeGaranteaza"];
            this.sumaGarantiei = _data["sumaGarantiei"];
            this.sold = _data["sold"];
            this.mentiuni = _data["mentiuni"];
            this.ceGaranteaza = _data["ceGaranteaza"];
            this.garantiePrimitaDataEnum = _data["garantiePrimitaDataEnum"];
            this.startDateGarantie = _data["startDateGarantie"] ? moment(_data["startDateGarantie"].toString()) : <any>undefined;
            this.endDateGarantie = _data["endDateGarantie"] ? moment(_data["endDateGarantie"].toString()) : <any>undefined;
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GarantieDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarantieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tipGarantie"] = this.tipGarantie;
        data["documentNr"] = this.documentNr;
        data["legalPerson"] = this.legalPerson;
        data["garantieAccount"] = this.garantieAccount;
        data["currency"] = this.currency;
        data["garantieTip"] = this.garantieTip;
        data["garantieCeGaranteaza"] = this.garantieCeGaranteaza;
        data["sumaGarantiei"] = this.sumaGarantiei;
        data["sold"] = this.sold;
        data["mentiuni"] = this.mentiuni;
        data["ceGaranteaza"] = this.ceGaranteaza;
        data["garantiePrimitaDataEnum"] = this.garantiePrimitaDataEnum;
        data["startDateGarantie"] = this.startDateGarantie ? this.startDateGarantie.toISOString() : <any>undefined;
        data["endDateGarantie"] = this.endDateGarantie ? this.endDateGarantie.toISOString() : <any>undefined;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): GarantieDto {
        const json = this.toJSON();
        let result = new GarantieDto();
        result.init(json);
        return result;
    }
}

export interface IGarantieDto {
    id: number;
    tipGarantie: string | undefined;
    documentNr: number;
    legalPerson: string | undefined;
    garantieAccount: string | undefined;
    currency: string | undefined;
    garantieTip: string | undefined;
    garantieCeGaranteaza: string | undefined;
    sumaGarantiei: number;
    sold: number;
    mentiuni: string | undefined;
    ceGaranteaza: string | undefined;
    garantiePrimitaDataEnum: string | undefined;
    startDateGarantie: moment.Moment;
    endDateGarantie: moment.Moment;
    documentDate: moment.Moment;
}

export class GarantieEditDto implements IGarantieEditDto {
    id: number;
    tipGarantie: string | undefined;
    documentNr: number;
    garantieAccountId: number | undefined;
    sumaGarantiei: number;
    mentiuni: string | undefined;
    startDateGarantie: moment.Moment;
    endDateGarantie: moment.Moment;
    documentDate: moment.Moment;
    imprumutId: number;
    currencyId: number;
    legalPersonId: number;
    garantieTipId: number;
    garantieCeGaranteazaId: number;
    garantiePrimitaDataEnum: TipGarantiePrimitaDataEnum;
    okDelete: boolean;

    constructor(data?: IGarantieEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tipGarantie = _data["tipGarantie"];
            this.documentNr = _data["documentNr"];
            this.garantieAccountId = _data["garantieAccountId"];
            this.sumaGarantiei = _data["sumaGarantiei"];
            this.mentiuni = _data["mentiuni"];
            this.startDateGarantie = _data["startDateGarantie"] ? moment(_data["startDateGarantie"].toString()) : <any>undefined;
            this.endDateGarantie = _data["endDateGarantie"] ? moment(_data["endDateGarantie"].toString()) : <any>undefined;
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.imprumutId = _data["imprumutId"];
            this.currencyId = _data["currencyId"];
            this.legalPersonId = _data["legalPersonId"];
            this.garantieTipId = _data["garantieTipId"];
            this.garantieCeGaranteazaId = _data["garantieCeGaranteazaId"];
            this.garantiePrimitaDataEnum = _data["garantiePrimitaDataEnum"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): GarantieEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarantieEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tipGarantie"] = this.tipGarantie;
        data["documentNr"] = this.documentNr;
        data["garantieAccountId"] = this.garantieAccountId;
        data["sumaGarantiei"] = this.sumaGarantiei;
        data["mentiuni"] = this.mentiuni;
        data["startDateGarantie"] = this.startDateGarantie ? this.startDateGarantie.toISOString() : <any>undefined;
        data["endDateGarantie"] = this.endDateGarantie ? this.endDateGarantie.toISOString() : <any>undefined;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["imprumutId"] = this.imprumutId;
        data["currencyId"] = this.currencyId;
        data["legalPersonId"] = this.legalPersonId;
        data["garantieTipId"] = this.garantieTipId;
        data["garantieCeGaranteazaId"] = this.garantieCeGaranteazaId;
        data["garantiePrimitaDataEnum"] = this.garantiePrimitaDataEnum;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): GarantieEditDto {
        const json = this.toJSON();
        let result = new GarantieEditDto();
        result.init(json);
        return result;
    }
}

export interface IGarantieEditDto {
    id: number;
    tipGarantie: string | undefined;
    documentNr: number;
    garantieAccountId: number | undefined;
    sumaGarantiei: number;
    mentiuni: string | undefined;
    startDateGarantie: moment.Moment;
    endDateGarantie: moment.Moment;
    documentDate: moment.Moment;
    imprumutId: number;
    currencyId: number;
    legalPersonId: number;
    garantieTipId: number;
    garantieCeGaranteazaId: number;
    garantiePrimitaDataEnum: TipGarantiePrimitaDataEnum;
    okDelete: boolean;
}

export class OperatieGarantieDto implements IOperatieGarantieDto {
    id: number;
    garantieId: number;
    suma: number;
    sold: number;
    tipOperatieGarantieEnum: TipOperatieGarantieEnum;
    dataOperatiei: moment.Moment;
    tenantId: number;

    constructor(data?: IOperatieGarantieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.garantieId = _data["garantieId"];
            this.suma = _data["suma"];
            this.sold = _data["sold"];
            this.tipOperatieGarantieEnum = _data["tipOperatieGarantieEnum"];
            this.dataOperatiei = _data["dataOperatiei"] ? moment(_data["dataOperatiei"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): OperatieGarantieDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperatieGarantieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["garantieId"] = this.garantieId;
        data["suma"] = this.suma;
        data["sold"] = this.sold;
        data["tipOperatieGarantieEnum"] = this.tipOperatieGarantieEnum;
        data["dataOperatiei"] = this.dataOperatiei ? this.dataOperatiei.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): OperatieGarantieDto {
        const json = this.toJSON();
        let result = new OperatieGarantieDto();
        result.init(json);
        return result;
    }
}

export interface IOperatieGarantieDto {
    id: number;
    garantieId: number;
    suma: number;
    sold: number;
    tipOperatieGarantieEnum: TipOperatieGarantieEnum;
    dataOperatiei: moment.Moment;
    tenantId: number;
}

export class GarantieCeGaranteazaDto implements IGarantieCeGaranteazaDto {
    id: number;
    description: string | undefined;

    constructor(data?: IGarantieCeGaranteazaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GarantieCeGaranteazaDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarantieCeGaranteazaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        return data;
    }

    clone(): GarantieCeGaranteazaDto {
        const json = this.toJSON();
        let result = new GarantieCeGaranteazaDto();
        result.init(json);
        return result;
    }
}

export interface IGarantieCeGaranteazaDto {
    id: number;
    description: string | undefined;
}

export class GarantieCeGaranteazaEditDto implements IGarantieCeGaranteazaEditDto {
    id: number;
    description: string | undefined;
    okDelete: boolean;

    constructor(data?: IGarantieCeGaranteazaEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): GarantieCeGaranteazaEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarantieCeGaranteazaEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): GarantieCeGaranteazaEditDto {
        const json = this.toJSON();
        let result = new GarantieCeGaranteazaEditDto();
        result.init(json);
        return result;
    }
}

export interface IGarantieCeGaranteazaEditDto {
    id: number;
    description: string | undefined;
    okDelete: boolean;
}

export class GarantieTipDto implements IGarantieTipDto {
    id: number;
    description: string | undefined;

    constructor(data?: IGarantieTipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GarantieTipDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarantieTipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        return data;
    }

    clone(): GarantieTipDto {
        const json = this.toJSON();
        let result = new GarantieTipDto();
        result.init(json);
        return result;
    }
}

export interface IGarantieTipDto {
    id: number;
    description: string | undefined;
}

export class GarantieTipEditDto implements IGarantieTipEditDto {
    id: number;
    description: string | undefined;
    okDelete: boolean;

    constructor(data?: IGarantieTipEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): GarantieTipEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GarantieTipEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): GarantieTipEditDto {
        const json = this.toJSON();
        let result = new GarantieTipEditDto();
        result.init(json);
        return result;
    }
}

export interface IGarantieTipEditDto {
    id: number;
    description: string | undefined;
    okDelete: boolean;
}

export class ImoAssetListDto implements IImoAssetListDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;
    priceUnit: number;
    inventoryValue: number;
    fiscalInventoryValue: number;
    operationDate: moment.Moment;
    useStartDate: string | undefined;
    depreciationStartDate: string | undefined;
    durationInMonths: number;
    inConservare: boolean;
    inStock: boolean;
    documentNr: number;
    documentDate: moment.Moment;
    documentType: string | undefined;
    classCode: string | undefined;
    thirdParty: string | undefined;
    invoice: string | undefined;
    processed: boolean;
    processedIn: boolean;
    processedInUse: boolean;

    constructor(data?: IImoAssetListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.inventoryNr = _data["inventoryNr"];
            this.priceUnit = _data["priceUnit"];
            this.inventoryValue = _data["inventoryValue"];
            this.fiscalInventoryValue = _data["fiscalInventoryValue"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.useStartDate = _data["useStartDate"];
            this.depreciationStartDate = _data["depreciationStartDate"];
            this.durationInMonths = _data["durationInMonths"];
            this.inConservare = _data["inConservare"];
            this.inStock = _data["inStock"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.documentType = _data["documentType"];
            this.classCode = _data["classCode"];
            this.thirdParty = _data["thirdParty"];
            this.invoice = _data["invoice"];
            this.processed = _data["processed"];
            this.processedIn = _data["processedIn"];
            this.processedInUse = _data["processedInUse"];
        }
    }

    static fromJS(data: any): ImoAssetListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["inventoryNr"] = this.inventoryNr;
        data["priceUnit"] = this.priceUnit;
        data["inventoryValue"] = this.inventoryValue;
        data["fiscalInventoryValue"] = this.fiscalInventoryValue;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["useStartDate"] = this.useStartDate;
        data["depreciationStartDate"] = this.depreciationStartDate;
        data["durationInMonths"] = this.durationInMonths;
        data["inConservare"] = this.inConservare;
        data["inStock"] = this.inStock;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["documentType"] = this.documentType;
        data["classCode"] = this.classCode;
        data["thirdParty"] = this.thirdParty;
        data["invoice"] = this.invoice;
        data["processed"] = this.processed;
        data["processedIn"] = this.processedIn;
        data["processedInUse"] = this.processedInUse;
        return data;
    }

    clone(): ImoAssetListDto {
        const json = this.toJSON();
        let result = new ImoAssetListDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetListDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;
    priceUnit: number;
    inventoryValue: number;
    fiscalInventoryValue: number;
    operationDate: moment.Moment;
    useStartDate: string | undefined;
    depreciationStartDate: string | undefined;
    durationInMonths: number;
    inConservare: boolean;
    inStock: boolean;
    documentNr: number;
    documentDate: moment.Moment;
    documentType: string | undefined;
    classCode: string | undefined;
    thirdParty: string | undefined;
    invoice: string | undefined;
    processed: boolean;
    processedIn: boolean;
    processedInUse: boolean;
}

export class GetImoAssetOutput implements IGetImoAssetOutput {
    getImoAssets: ImoAssetListDto[] | undefined;

    constructor(data?: IGetImoAssetOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getImoAssets"])) {
                this.getImoAssets = [] as any;
                for (let item of _data["getImoAssets"])
                    this.getImoAssets.push(ImoAssetListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetImoAssetOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetImoAssetOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getImoAssets)) {
            data["getImoAssets"] = [];
            for (let item of this.getImoAssets)
                data["getImoAssets"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetImoAssetOutput {
        const json = this.toJSON();
        let result = new GetImoAssetOutput();
        result.init(json);
        return result;
    }
}

export interface IGetImoAssetOutput {
    getImoAssets: ImoAssetListDto[] | undefined;
}

export enum ImoAssetOperType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
}

export class ImoAssetAddInvoiceDetailDto implements IImoAssetAddInvoiceDetailDto {
    invoiceId: number;
    invoiceDetailsId: number | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    assetName: string | undefined;
    quantity: number;
    invValue: number;
    storageInId: number | undefined;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;

    constructor(data?: IImoAssetAddInvoiceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.invoiceDetailsId = _data["invoiceDetailsId"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.assetName = _data["assetName"];
            this.quantity = _data["quantity"];
            this.invValue = _data["invValue"];
            this.storageInId = _data["storageInId"];
            this.primDocumentTypeId = _data["primDocumentTypeId"];
            this.primDocumentNr = _data["primDocumentNr"];
            this.primDocumentDate = _data["primDocumentDate"] ? moment(_data["primDocumentDate"].toString()) : <any>undefined;
            this.thirdPartyId = _data["thirdPartyId"];
        }
    }

    static fromJS(data: any): ImoAssetAddInvoiceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetAddInvoiceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["invoiceDetailsId"] = this.invoiceDetailsId;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["assetName"] = this.assetName;
        data["quantity"] = this.quantity;
        data["invValue"] = this.invValue;
        data["storageInId"] = this.storageInId;
        data["primDocumentTypeId"] = this.primDocumentTypeId;
        data["primDocumentNr"] = this.primDocumentNr;
        data["primDocumentDate"] = this.primDocumentDate ? this.primDocumentDate.toISOString() : <any>undefined;
        data["thirdPartyId"] = this.thirdPartyId;
        return data;
    }

    clone(): ImoAssetAddInvoiceDetailDto {
        const json = this.toJSON();
        let result = new ImoAssetAddInvoiceDetailDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetAddInvoiceDetailDto {
    invoiceId: number;
    invoiceDetailsId: number | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    assetName: string | undefined;
    quantity: number;
    invValue: number;
    storageInId: number | undefined;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
}

export class ImoAssetAddDetailDto implements IImoAssetAddDetailDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;
    quantity: number;
    inventoryValue: number;
    fiscalInventoryValue: number;
    useStartDate: moment.Moment | undefined;
    depreciationStartDate: moment.Moment | undefined;
    durationInMonths: number;
    depreciation: number;
    fiscalDepreciation: number;
    invoiceDetailsId: number | undefined;
    assetClassCodesId: number | undefined;
    assetAccountId: number | undefined;
    assetAccountInUseId: number | undefined;
    depreciationAccountId: number | undefined;
    expenseAccountId: number | undefined;
    storageInId: number | undefined;
    storageIn: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;

    constructor(data?: IImoAssetAddDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.inventoryNr = _data["inventoryNr"];
            this.quantity = _data["quantity"];
            this.inventoryValue = _data["inventoryValue"];
            this.fiscalInventoryValue = _data["fiscalInventoryValue"];
            this.useStartDate = _data["useStartDate"] ? moment(_data["useStartDate"].toString()) : <any>undefined;
            this.depreciationStartDate = _data["depreciationStartDate"] ? moment(_data["depreciationStartDate"].toString()) : <any>undefined;
            this.durationInMonths = _data["durationInMonths"];
            this.depreciation = _data["depreciation"];
            this.fiscalDepreciation = _data["fiscalDepreciation"];
            this.invoiceDetailsId = _data["invoiceDetailsId"];
            this.assetClassCodesId = _data["assetClassCodesId"];
            this.assetAccountId = _data["assetAccountId"];
            this.assetAccountInUseId = _data["assetAccountInUseId"];
            this.depreciationAccountId = _data["depreciationAccountId"];
            this.expenseAccountId = _data["expenseAccountId"];
            this.storageInId = _data["storageInId"];
            this.storageIn = _data["storageIn"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.primDocumentTypeId = _data["primDocumentTypeId"];
            this.primDocumentNr = _data["primDocumentNr"];
            this.primDocumentDate = _data["primDocumentDate"] ? moment(_data["primDocumentDate"].toString()) : <any>undefined;
            this.thirdPartyId = _data["thirdPartyId"];
        }
    }

    static fromJS(data: any): ImoAssetAddDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetAddDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["inventoryNr"] = this.inventoryNr;
        data["quantity"] = this.quantity;
        data["inventoryValue"] = this.inventoryValue;
        data["fiscalInventoryValue"] = this.fiscalInventoryValue;
        data["useStartDate"] = this.useStartDate ? this.useStartDate.toISOString() : <any>undefined;
        data["depreciationStartDate"] = this.depreciationStartDate ? this.depreciationStartDate.toISOString() : <any>undefined;
        data["durationInMonths"] = this.durationInMonths;
        data["depreciation"] = this.depreciation;
        data["fiscalDepreciation"] = this.fiscalDepreciation;
        data["invoiceDetailsId"] = this.invoiceDetailsId;
        data["assetClassCodesId"] = this.assetClassCodesId;
        data["assetAccountId"] = this.assetAccountId;
        data["assetAccountInUseId"] = this.assetAccountInUseId;
        data["depreciationAccountId"] = this.depreciationAccountId;
        data["expenseAccountId"] = this.expenseAccountId;
        data["storageInId"] = this.storageInId;
        data["storageIn"] = this.storageIn;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["primDocumentTypeId"] = this.primDocumentTypeId;
        data["primDocumentNr"] = this.primDocumentNr;
        data["primDocumentDate"] = this.primDocumentDate ? this.primDocumentDate.toISOString() : <any>undefined;
        data["thirdPartyId"] = this.thirdPartyId;
        return data;
    }

    clone(): ImoAssetAddDetailDto {
        const json = this.toJSON();
        let result = new ImoAssetAddDetailDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetAddDetailDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;
    quantity: number;
    inventoryValue: number;
    fiscalInventoryValue: number;
    useStartDate: moment.Moment | undefined;
    depreciationStartDate: moment.Moment | undefined;
    durationInMonths: number;
    depreciation: number;
    fiscalDepreciation: number;
    invoiceDetailsId: number | undefined;
    assetClassCodesId: number | undefined;
    assetAccountId: number | undefined;
    assetAccountInUseId: number | undefined;
    depreciationAccountId: number | undefined;
    expenseAccountId: number | undefined;
    storageInId: number | undefined;
    storageIn: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
}

export class ImoAssetAddDto implements IImoAssetAddDto {
    operationDate: moment.Moment;
    documentTypeId: number;
    documentType: string | undefined;
    operationType: ImoAssetOperType;
    invoiceId: number | undefined;
    invoiceDetail: ImoAssetAddInvoiceDetailDto[] | undefined;
    assets: ImoAssetAddDetailDto[] | undefined;
    showForm1: boolean;
    showForm2: boolean;
    showForm3: boolean;
    finishAdd: boolean;

    constructor(data?: IImoAssetAddDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.operationType = _data["operationType"];
            this.invoiceId = _data["invoiceId"];
            if (Array.isArray(_data["invoiceDetail"])) {
                this.invoiceDetail = [] as any;
                for (let item of _data["invoiceDetail"])
                    this.invoiceDetail.push(ImoAssetAddInvoiceDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets.push(ImoAssetAddDetailDto.fromJS(item));
            }
            this.showForm1 = _data["showForm1"];
            this.showForm2 = _data["showForm2"];
            this.showForm3 = _data["showForm3"];
            this.finishAdd = _data["finishAdd"];
        }
    }

    static fromJS(data: any): ImoAssetAddDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetAddDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["operationType"] = this.operationType;
        data["invoiceId"] = this.invoiceId;
        if (Array.isArray(this.invoiceDetail)) {
            data["invoiceDetail"] = [];
            for (let item of this.invoiceDetail)
                data["invoiceDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        data["showForm1"] = this.showForm1;
        data["showForm2"] = this.showForm2;
        data["showForm3"] = this.showForm3;
        data["finishAdd"] = this.finishAdd;
        return data;
    }

    clone(): ImoAssetAddDto {
        const json = this.toJSON();
        let result = new ImoAssetAddDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetAddDto {
    operationDate: moment.Moment;
    documentTypeId: number;
    documentType: string | undefined;
    operationType: ImoAssetOperType;
    invoiceId: number | undefined;
    invoiceDetail: ImoAssetAddInvoiceDetailDto[] | undefined;
    assets: ImoAssetAddDetailDto[] | undefined;
    showForm1: boolean;
    showForm2: boolean;
    showForm3: boolean;
    finishAdd: boolean;
}

export class ImoAssetAddDirectDto implements IImoAssetAddDirectDto {
    id: number;
    assetType: number;
    operationDate: moment.Moment;
    documentTypeId: number;
    documentType: string | undefined;
    operationType: ImoAssetOperType;
    invoiceId: number | undefined;
    finishAdd: boolean;
    name: string | undefined;
    inventoryNr: number;
    quantity: number;
    inventoryValue: number;
    fiscalInventoryValue: number;
    useStartDate: moment.Moment | undefined;
    depreciationStartDate: moment.Moment | undefined;
    durationInMonths: number;
    remainingDuration: number | undefined;
    depreciation: number | undefined;
    fiscalDepreciation: number | undefined;
    monthlyDepreciation: number | undefined;
    monthlyFiscalDepreciation: number | undefined;
    invoiceDetailsId: number | undefined;
    assetClassCodesId: number | undefined;
    assetAccountId: number | undefined;
    depreciationAccountId: number | undefined;
    expenseAccountId: number | undefined;
    assetAccountInUseId: number | undefined;
    storageInId: number | undefined;
    storageIn: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    processed: boolean;
    processedIn: boolean;
    processedInUse: boolean;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
    thirdPartyName: string | undefined;

    constructor(data?: IImoAssetAddDirectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetType = _data["assetType"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.operationType = _data["operationType"];
            this.invoiceId = _data["invoiceId"];
            this.finishAdd = _data["finishAdd"];
            this.name = _data["name"];
            this.inventoryNr = _data["inventoryNr"];
            this.quantity = _data["quantity"];
            this.inventoryValue = _data["inventoryValue"];
            this.fiscalInventoryValue = _data["fiscalInventoryValue"];
            this.useStartDate = _data["useStartDate"] ? moment(_data["useStartDate"].toString()) : <any>undefined;
            this.depreciationStartDate = _data["depreciationStartDate"] ? moment(_data["depreciationStartDate"].toString()) : <any>undefined;
            this.durationInMonths = _data["durationInMonths"];
            this.remainingDuration = _data["remainingDuration"];
            this.depreciation = _data["depreciation"];
            this.fiscalDepreciation = _data["fiscalDepreciation"];
            this.monthlyDepreciation = _data["monthlyDepreciation"];
            this.monthlyFiscalDepreciation = _data["monthlyFiscalDepreciation"];
            this.invoiceDetailsId = _data["invoiceDetailsId"];
            this.assetClassCodesId = _data["assetClassCodesId"];
            this.assetAccountId = _data["assetAccountId"];
            this.depreciationAccountId = _data["depreciationAccountId"];
            this.expenseAccountId = _data["expenseAccountId"];
            this.assetAccountInUseId = _data["assetAccountInUseId"];
            this.storageInId = _data["storageInId"];
            this.storageIn = _data["storageIn"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.processed = _data["processed"];
            this.processedIn = _data["processedIn"];
            this.processedInUse = _data["processedInUse"];
            this.primDocumentTypeId = _data["primDocumentTypeId"];
            this.primDocumentNr = _data["primDocumentNr"];
            this.primDocumentDate = _data["primDocumentDate"] ? moment(_data["primDocumentDate"].toString()) : <any>undefined;
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdPartyName = _data["thirdPartyName"];
        }
    }

    static fromJS(data: any): ImoAssetAddDirectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetAddDirectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetType"] = this.assetType;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["operationType"] = this.operationType;
        data["invoiceId"] = this.invoiceId;
        data["finishAdd"] = this.finishAdd;
        data["name"] = this.name;
        data["inventoryNr"] = this.inventoryNr;
        data["quantity"] = this.quantity;
        data["inventoryValue"] = this.inventoryValue;
        data["fiscalInventoryValue"] = this.fiscalInventoryValue;
        data["useStartDate"] = this.useStartDate ? this.useStartDate.toISOString() : <any>undefined;
        data["depreciationStartDate"] = this.depreciationStartDate ? this.depreciationStartDate.toISOString() : <any>undefined;
        data["durationInMonths"] = this.durationInMonths;
        data["remainingDuration"] = this.remainingDuration;
        data["depreciation"] = this.depreciation;
        data["fiscalDepreciation"] = this.fiscalDepreciation;
        data["monthlyDepreciation"] = this.monthlyDepreciation;
        data["monthlyFiscalDepreciation"] = this.monthlyFiscalDepreciation;
        data["invoiceDetailsId"] = this.invoiceDetailsId;
        data["assetClassCodesId"] = this.assetClassCodesId;
        data["assetAccountId"] = this.assetAccountId;
        data["depreciationAccountId"] = this.depreciationAccountId;
        data["expenseAccountId"] = this.expenseAccountId;
        data["assetAccountInUseId"] = this.assetAccountInUseId;
        data["storageInId"] = this.storageInId;
        data["storageIn"] = this.storageIn;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["processed"] = this.processed;
        data["processedIn"] = this.processedIn;
        data["processedInUse"] = this.processedInUse;
        data["primDocumentTypeId"] = this.primDocumentTypeId;
        data["primDocumentNr"] = this.primDocumentNr;
        data["primDocumentDate"] = this.primDocumentDate ? this.primDocumentDate.toISOString() : <any>undefined;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdPartyName"] = this.thirdPartyName;
        return data;
    }

    clone(): ImoAssetAddDirectDto {
        const json = this.toJSON();
        let result = new ImoAssetAddDirectDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetAddDirectDto {
    id: number;
    assetType: number;
    operationDate: moment.Moment;
    documentTypeId: number;
    documentType: string | undefined;
    operationType: ImoAssetOperType;
    invoiceId: number | undefined;
    finishAdd: boolean;
    name: string | undefined;
    inventoryNr: number;
    quantity: number;
    inventoryValue: number;
    fiscalInventoryValue: number;
    useStartDate: moment.Moment | undefined;
    depreciationStartDate: moment.Moment | undefined;
    durationInMonths: number;
    remainingDuration: number | undefined;
    depreciation: number | undefined;
    fiscalDepreciation: number | undefined;
    monthlyDepreciation: number | undefined;
    monthlyFiscalDepreciation: number | undefined;
    invoiceDetailsId: number | undefined;
    assetClassCodesId: number | undefined;
    assetAccountId: number | undefined;
    depreciationAccountId: number | undefined;
    expenseAccountId: number | undefined;
    assetAccountInUseId: number | undefined;
    storageInId: number | undefined;
    storageIn: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    processed: boolean;
    processedIn: boolean;
    processedInUse: boolean;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
    thirdPartyName: string | undefined;
}

export class ImoAssetClassCodeListDto implements IImoAssetClassCodeListDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    assetAccount: string | undefined;
    depreciationAccount: string | undefined;
    expenseAccount: string | undefined;
    classCodeParrent: string | undefined;
    durationMin: number;
    durationMax: number;

    constructor(data?: IImoAssetClassCodeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.assetAccount = _data["assetAccount"];
            this.depreciationAccount = _data["depreciationAccount"];
            this.expenseAccount = _data["expenseAccount"];
            this.classCodeParrent = _data["classCodeParrent"];
            this.durationMin = _data["durationMin"];
            this.durationMax = _data["durationMax"];
        }
    }

    static fromJS(data: any): ImoAssetClassCodeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetClassCodeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["assetAccount"] = this.assetAccount;
        data["depreciationAccount"] = this.depreciationAccount;
        data["expenseAccount"] = this.expenseAccount;
        data["classCodeParrent"] = this.classCodeParrent;
        data["durationMin"] = this.durationMin;
        data["durationMax"] = this.durationMax;
        return data;
    }

    clone(): ImoAssetClassCodeListDto {
        const json = this.toJSON();
        let result = new ImoAssetClassCodeListDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetClassCodeListDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    assetAccount: string | undefined;
    depreciationAccount: string | undefined;
    expenseAccount: string | undefined;
    classCodeParrent: string | undefined;
    durationMin: number;
    durationMax: number;
}

export class GetImoAssetClassCodeOutput implements IGetImoAssetClassCodeOutput {
    getImoAssetClassCode: ImoAssetClassCodeListDto[] | undefined;

    constructor(data?: IGetImoAssetClassCodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getImoAssetClassCode"])) {
                this.getImoAssetClassCode = [] as any;
                for (let item of _data["getImoAssetClassCode"])
                    this.getImoAssetClassCode.push(ImoAssetClassCodeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetImoAssetClassCodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetImoAssetClassCodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getImoAssetClassCode)) {
            data["getImoAssetClassCode"] = [];
            for (let item of this.getImoAssetClassCode)
                data["getImoAssetClassCode"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetImoAssetClassCodeOutput {
        const json = this.toJSON();
        let result = new GetImoAssetClassCodeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetImoAssetClassCodeOutput {
    getImoAssetClassCode: ImoAssetClassCodeListDto[] | undefined;
}

export class ImoAssetClassCodeListDDDto implements IImoAssetClassCodeListDDDto {
    id: number;
    name: string | undefined;

    constructor(data?: IImoAssetClassCodeListDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ImoAssetClassCodeListDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetClassCodeListDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ImoAssetClassCodeListDDDto {
        const json = this.toJSON();
        let result = new ImoAssetClassCodeListDDDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetClassCodeListDDDto {
    id: number;
    name: string | undefined;
}

export class ImoAssetClassCodeEditDto implements IImoAssetClassCodeEditDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    assetAccountId: number | undefined;
    depreciationAccountId: number | undefined;
    expenseAccountId: number | undefined;
    classCodeParrentId: number | undefined;
    durationMin: number;
    durationMax: number;

    constructor(data?: IImoAssetClassCodeEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.assetAccountId = _data["assetAccountId"];
            this.depreciationAccountId = _data["depreciationAccountId"];
            this.expenseAccountId = _data["expenseAccountId"];
            this.classCodeParrentId = _data["classCodeParrentId"];
            this.durationMin = _data["durationMin"];
            this.durationMax = _data["durationMax"];
        }
    }

    static fromJS(data: any): ImoAssetClassCodeEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetClassCodeEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["assetAccountId"] = this.assetAccountId;
        data["depreciationAccountId"] = this.depreciationAccountId;
        data["expenseAccountId"] = this.expenseAccountId;
        data["classCodeParrentId"] = this.classCodeParrentId;
        data["durationMin"] = this.durationMin;
        data["durationMax"] = this.durationMax;
        return data;
    }

    clone(): ImoAssetClassCodeEditDto {
        const json = this.toJSON();
        let result = new ImoAssetClassCodeEditDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetClassCodeEditDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    assetAccountId: number | undefined;
    depreciationAccountId: number | undefined;
    expenseAccountId: number | undefined;
    classCodeParrentId: number | undefined;
    durationMin: number;
    durationMax: number;
}

export class ImoAssetOperListDetailDto implements IImoAssetOperListDetailDto {
    id: number;
    operationType: string | undefined;
    operationTypeId: number;
    operationDate: moment.Moment;
    documentType: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    processed: boolean;
    readonly showReportBtn: boolean;

    constructor(data?: IImoAssetOperListDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationType = _data["operationType"];
            this.operationTypeId = _data["operationTypeId"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentType = _data["documentType"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.processed = _data["processed"];
            (<any>this).showReportBtn = _data["showReportBtn"];
        }
    }

    static fromJS(data: any): ImoAssetOperListDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetOperListDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationType"] = this.operationType;
        data["operationTypeId"] = this.operationTypeId;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentType"] = this.documentType;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["processed"] = this.processed;
        data["showReportBtn"] = this.showReportBtn;
        return data;
    }

    clone(): ImoAssetOperListDetailDto {
        const json = this.toJSON();
        let result = new ImoAssetOperListDetailDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetOperListDetailDto {
    id: number;
    operationType: string | undefined;
    operationTypeId: number;
    operationDate: moment.Moment;
    documentType: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    processed: boolean;
    showReportBtn: boolean;
}

export class ImoAssetOperListDto implements IImoAssetOperListDto {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    listDetail: ImoAssetOperListDetailDto[] | undefined;

    constructor(data?: IImoAssetOperListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            if (Array.isArray(_data["listDetail"])) {
                this.listDetail = [] as any;
                for (let item of _data["listDetail"])
                    this.listDetail.push(ImoAssetOperListDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImoAssetOperListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetOperListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        if (Array.isArray(this.listDetail)) {
            data["listDetail"] = [];
            for (let item of this.listDetail)
                data["listDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImoAssetOperListDto {
        const json = this.toJSON();
        let result = new ImoAssetOperListDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetOperListDto {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    listDetail: ImoAssetOperListDetailDto[] | undefined;
}

export class OperTypeListDto implements IOperTypeListDto {
    id: number;
    name: string | undefined;

    constructor(data?: IOperTypeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OperTypeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperTypeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): OperTypeListDto {
        const json = this.toJSON();
        let result = new OperTypeListDto();
        result.init(json);
        return result;
    }
}

export interface IOperTypeListDto {
    id: number;
    name: string | undefined;
}

export class DocumentTypeListDto implements IDocumentTypeListDto {
    id: number;
    name: string | undefined;

    constructor(data?: IDocumentTypeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DocumentTypeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): DocumentTypeListDto {
        const json = this.toJSON();
        let result = new DocumentTypeListDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentTypeListDto {
    id: number;
    name: string | undefined;
}

export class ImoAssetOperDetailEditDto implements IImoAssetOperDetailEditDto {
    id: number;
    imoAssetItemId: number | undefined;
    imoAssetItem: string | undefined;
    quantity: number;
    invValueOld: number;
    fiscalValueOld: number;
    invValueNew: number;
    fiscalValueNew: number;
    invValueModif: number;
    fiscalValueModif: number;
    durationModif: number;
    deprecModif: number;
    fiscalDeprecModif: number;
    idOrd: number;
    invoiceDetailId: number | undefined;

    constructor(data?: IImoAssetOperDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imoAssetItemId = _data["imoAssetItemId"];
            this.imoAssetItem = _data["imoAssetItem"];
            this.quantity = _data["quantity"];
            this.invValueOld = _data["invValueOld"];
            this.fiscalValueOld = _data["fiscalValueOld"];
            this.invValueNew = _data["invValueNew"];
            this.fiscalValueNew = _data["fiscalValueNew"];
            this.invValueModif = _data["invValueModif"];
            this.fiscalValueModif = _data["fiscalValueModif"];
            this.durationModif = _data["durationModif"];
            this.deprecModif = _data["deprecModif"];
            this.fiscalDeprecModif = _data["fiscalDeprecModif"];
            this.idOrd = _data["idOrd"];
            this.invoiceDetailId = _data["invoiceDetailId"];
        }
    }

    static fromJS(data: any): ImoAssetOperDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetOperDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imoAssetItemId"] = this.imoAssetItemId;
        data["imoAssetItem"] = this.imoAssetItem;
        data["quantity"] = this.quantity;
        data["invValueOld"] = this.invValueOld;
        data["fiscalValueOld"] = this.fiscalValueOld;
        data["invValueNew"] = this.invValueNew;
        data["fiscalValueNew"] = this.fiscalValueNew;
        data["invValueModif"] = this.invValueModif;
        data["fiscalValueModif"] = this.fiscalValueModif;
        data["durationModif"] = this.durationModif;
        data["deprecModif"] = this.deprecModif;
        data["fiscalDeprecModif"] = this.fiscalDeprecModif;
        data["idOrd"] = this.idOrd;
        data["invoiceDetailId"] = this.invoiceDetailId;
        return data;
    }

    clone(): ImoAssetOperDetailEditDto {
        const json = this.toJSON();
        let result = new ImoAssetOperDetailEditDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetOperDetailEditDto {
    id: number;
    imoAssetItemId: number | undefined;
    imoAssetItem: string | undefined;
    quantity: number;
    invValueOld: number;
    fiscalValueOld: number;
    invValueNew: number;
    fiscalValueNew: number;
    invValueModif: number;
    fiscalValueModif: number;
    durationModif: number;
    deprecModif: number;
    fiscalDeprecModif: number;
    idOrd: number;
    invoiceDetailId: number | undefined;
}

export class ImoAssetOperDetailEditModifAccountDto implements IImoAssetOperDetailEditModifAccountDto {
    id: number;
    imoAssetItemId: number | undefined;
    imoAssetItem: string | undefined;
    idOrd: number;
    oldAssetAccountId: number | undefined;
    oldAssetAccount: string | undefined;
    oldAssetAccountInUseId: number | undefined;
    oldAssetAccountInUse: string | undefined;
    oldDepreciationAccountId: number | undefined;
    oldDepreciationAccount: string | undefined;
    oldExpenseAccountId: number | undefined;
    oldExpenseAccount: string | undefined;
    newAssetAccountId: number | undefined;
    newAssetAccount: string | undefined;
    newAssetAccountInUseId: number | undefined;
    newAssetAccountInUse: string | undefined;
    newDepreciationAccountId: number | undefined;
    newDepreciationAccount: string | undefined;
    newExpenseAccountId: number | undefined;
    newExpenseAccount: string | undefined;

    constructor(data?: IImoAssetOperDetailEditModifAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imoAssetItemId = _data["imoAssetItemId"];
            this.imoAssetItem = _data["imoAssetItem"];
            this.idOrd = _data["idOrd"];
            this.oldAssetAccountId = _data["oldAssetAccountId"];
            this.oldAssetAccount = _data["oldAssetAccount"];
            this.oldAssetAccountInUseId = _data["oldAssetAccountInUseId"];
            this.oldAssetAccountInUse = _data["oldAssetAccountInUse"];
            this.oldDepreciationAccountId = _data["oldDepreciationAccountId"];
            this.oldDepreciationAccount = _data["oldDepreciationAccount"];
            this.oldExpenseAccountId = _data["oldExpenseAccountId"];
            this.oldExpenseAccount = _data["oldExpenseAccount"];
            this.newAssetAccountId = _data["newAssetAccountId"];
            this.newAssetAccount = _data["newAssetAccount"];
            this.newAssetAccountInUseId = _data["newAssetAccountInUseId"];
            this.newAssetAccountInUse = _data["newAssetAccountInUse"];
            this.newDepreciationAccountId = _data["newDepreciationAccountId"];
            this.newDepreciationAccount = _data["newDepreciationAccount"];
            this.newExpenseAccountId = _data["newExpenseAccountId"];
            this.newExpenseAccount = _data["newExpenseAccount"];
        }
    }

    static fromJS(data: any): ImoAssetOperDetailEditModifAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetOperDetailEditModifAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imoAssetItemId"] = this.imoAssetItemId;
        data["imoAssetItem"] = this.imoAssetItem;
        data["idOrd"] = this.idOrd;
        data["oldAssetAccountId"] = this.oldAssetAccountId;
        data["oldAssetAccount"] = this.oldAssetAccount;
        data["oldAssetAccountInUseId"] = this.oldAssetAccountInUseId;
        data["oldAssetAccountInUse"] = this.oldAssetAccountInUse;
        data["oldDepreciationAccountId"] = this.oldDepreciationAccountId;
        data["oldDepreciationAccount"] = this.oldDepreciationAccount;
        data["oldExpenseAccountId"] = this.oldExpenseAccountId;
        data["oldExpenseAccount"] = this.oldExpenseAccount;
        data["newAssetAccountId"] = this.newAssetAccountId;
        data["newAssetAccount"] = this.newAssetAccount;
        data["newAssetAccountInUseId"] = this.newAssetAccountInUseId;
        data["newAssetAccountInUse"] = this.newAssetAccountInUse;
        data["newDepreciationAccountId"] = this.newDepreciationAccountId;
        data["newDepreciationAccount"] = this.newDepreciationAccount;
        data["newExpenseAccountId"] = this.newExpenseAccountId;
        data["newExpenseAccount"] = this.newExpenseAccount;
        return data;
    }

    clone(): ImoAssetOperDetailEditModifAccountDto {
        const json = this.toJSON();
        let result = new ImoAssetOperDetailEditModifAccountDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetOperDetailEditModifAccountDto {
    id: number;
    imoAssetItemId: number | undefined;
    imoAssetItem: string | undefined;
    idOrd: number;
    oldAssetAccountId: number | undefined;
    oldAssetAccount: string | undefined;
    oldAssetAccountInUseId: number | undefined;
    oldAssetAccountInUse: string | undefined;
    oldDepreciationAccountId: number | undefined;
    oldDepreciationAccount: string | undefined;
    oldExpenseAccountId: number | undefined;
    oldExpenseAccount: string | undefined;
    newAssetAccountId: number | undefined;
    newAssetAccount: string | undefined;
    newAssetAccountInUseId: number | undefined;
    newAssetAccountInUse: string | undefined;
    newDepreciationAccountId: number | undefined;
    newDepreciationAccount: string | undefined;
    newExpenseAccountId: number | undefined;
    newExpenseAccount: string | undefined;
}

export class ImoAssetOperEditDto implements IImoAssetOperEditDto {
    id: number;
    operationTypeId: number | undefined;
    operationType: string | undefined;
    operationDate: moment.Moment;
    operationDateStr: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    documentDateStr: string | undefined;
    documentTypeId: number | undefined;
    documentType: string | undefined;
    assetsOperType: ImoAssetOperType;
    assetsStoreInId: number | undefined;
    assetsStoreIn: string | undefined;
    assetsStoreOutId: number | undefined;
    assetsStoreOut: string | undefined;
    personStoreInId: number | undefined;
    personStoreInName: string | undefined;
    personStoreOutId: number | undefined;
    personStoreOutName: string | undefined;
    invoiceId: number | undefined;
    showForm1: boolean;
    showForm2: boolean;
    showForm3: boolean;
    finishAdd: boolean;
    showStorage: boolean;
    showValues: boolean;
    showModifValues: boolean;
    details: ImoAssetOperDetailEditDto[] | undefined;
    assetAccountDetails: ImoAssetOperDetailEditModifAccountDto[] | undefined;

    constructor(data?: IImoAssetOperEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationTypeId = _data["operationTypeId"];
            this.operationType = _data["operationType"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.operationDateStr = _data["operationDateStr"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.documentDateStr = _data["documentDateStr"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.assetsOperType = _data["assetsOperType"];
            this.assetsStoreInId = _data["assetsStoreInId"];
            this.assetsStoreIn = _data["assetsStoreIn"];
            this.assetsStoreOutId = _data["assetsStoreOutId"];
            this.assetsStoreOut = _data["assetsStoreOut"];
            this.personStoreInId = _data["personStoreInId"];
            this.personStoreInName = _data["personStoreInName"];
            this.personStoreOutId = _data["personStoreOutId"];
            this.personStoreOutName = _data["personStoreOutName"];
            this.invoiceId = _data["invoiceId"];
            this.showForm1 = _data["showForm1"];
            this.showForm2 = _data["showForm2"];
            this.showForm3 = _data["showForm3"];
            this.finishAdd = _data["finishAdd"];
            this.showStorage = _data["showStorage"];
            this.showValues = _data["showValues"];
            this.showModifValues = _data["showModifValues"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(ImoAssetOperDetailEditDto.fromJS(item));
            }
            if (Array.isArray(_data["assetAccountDetails"])) {
                this.assetAccountDetails = [] as any;
                for (let item of _data["assetAccountDetails"])
                    this.assetAccountDetails.push(ImoAssetOperDetailEditModifAccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImoAssetOperEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetOperEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationTypeId"] = this.operationTypeId;
        data["operationType"] = this.operationType;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["operationDateStr"] = this.operationDateStr;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["documentDateStr"] = this.documentDateStr;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["assetsOperType"] = this.assetsOperType;
        data["assetsStoreInId"] = this.assetsStoreInId;
        data["assetsStoreIn"] = this.assetsStoreIn;
        data["assetsStoreOutId"] = this.assetsStoreOutId;
        data["assetsStoreOut"] = this.assetsStoreOut;
        data["personStoreInId"] = this.personStoreInId;
        data["personStoreInName"] = this.personStoreInName;
        data["personStoreOutId"] = this.personStoreOutId;
        data["personStoreOutName"] = this.personStoreOutName;
        data["invoiceId"] = this.invoiceId;
        data["showForm1"] = this.showForm1;
        data["showForm2"] = this.showForm2;
        data["showForm3"] = this.showForm3;
        data["finishAdd"] = this.finishAdd;
        data["showStorage"] = this.showStorage;
        data["showValues"] = this.showValues;
        data["showModifValues"] = this.showModifValues;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        if (Array.isArray(this.assetAccountDetails)) {
            data["assetAccountDetails"] = [];
            for (let item of this.assetAccountDetails)
                data["assetAccountDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImoAssetOperEditDto {
        const json = this.toJSON();
        let result = new ImoAssetOperEditDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetOperEditDto {
    id: number;
    operationTypeId: number | undefined;
    operationType: string | undefined;
    operationDate: moment.Moment;
    operationDateStr: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    documentDateStr: string | undefined;
    documentTypeId: number | undefined;
    documentType: string | undefined;
    assetsOperType: ImoAssetOperType;
    assetsStoreInId: number | undefined;
    assetsStoreIn: string | undefined;
    assetsStoreOutId: number | undefined;
    assetsStoreOut: string | undefined;
    personStoreInId: number | undefined;
    personStoreInName: string | undefined;
    personStoreOutId: number | undefined;
    personStoreOutName: string | undefined;
    invoiceId: number | undefined;
    showForm1: boolean;
    showForm2: boolean;
    showForm3: boolean;
    finishAdd: boolean;
    showStorage: boolean;
    showValues: boolean;
    showModifValues: boolean;
    details: ImoAssetOperDetailEditDto[] | undefined;
    assetAccountDetails: ImoAssetOperDetailEditModifAccountDto[] | undefined;
}

export class ImoAssetsDDDto implements IImoAssetsDDDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;

    constructor(data?: IImoAssetsDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.inventoryNr = _data["inventoryNr"];
        }
    }

    static fromJS(data: any): ImoAssetsDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetsDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["inventoryNr"] = this.inventoryNr;
        return data;
    }

    clone(): ImoAssetsDDDto {
        const json = this.toJSON();
        let result = new ImoAssetsDDDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetsDDDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;
}

export class ImoAssetOperDocTypeListDto implements IImoAssetOperDocTypeListDto {
    id: number;
    operType: string | undefined;
    documentType: string | undefined;
    appOperation: boolean;

    constructor(data?: IImoAssetOperDocTypeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operType = _data["operType"];
            this.documentType = _data["documentType"];
            this.appOperation = _data["appOperation"];
        }
    }

    static fromJS(data: any): ImoAssetOperDocTypeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetOperDocTypeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operType"] = this.operType;
        data["documentType"] = this.documentType;
        data["appOperation"] = this.appOperation;
        return data;
    }

    clone(): ImoAssetOperDocTypeListDto {
        const json = this.toJSON();
        let result = new ImoAssetOperDocTypeListDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetOperDocTypeListDto {
    id: number;
    operType: string | undefined;
    documentType: string | undefined;
    appOperation: boolean;
}

export class GetImoAssetOperDocTypeOutput implements IGetImoAssetOperDocTypeOutput {
    getImoAssetOperDocType: ImoAssetOperDocTypeListDto[] | undefined;

    constructor(data?: IGetImoAssetOperDocTypeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getImoAssetOperDocType"])) {
                this.getImoAssetOperDocType = [] as any;
                for (let item of _data["getImoAssetOperDocType"])
                    this.getImoAssetOperDocType.push(ImoAssetOperDocTypeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetImoAssetOperDocTypeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetImoAssetOperDocTypeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getImoAssetOperDocType)) {
            data["getImoAssetOperDocType"] = [];
            for (let item of this.getImoAssetOperDocType)
                data["getImoAssetOperDocType"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetImoAssetOperDocTypeOutput {
        const json = this.toJSON();
        let result = new GetImoAssetOperDocTypeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetImoAssetOperDocTypeOutput {
    getImoAssetOperDocType: ImoAssetOperDocTypeListDto[] | undefined;
}

export class ImoAssetOperDocTypeEditDto implements IImoAssetOperDocTypeEditDto {
    id: number;
    operTypeId: number;
    documentTypeId: number;
    appOperation: boolean;

    constructor(data?: IImoAssetOperDocTypeEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operTypeId = _data["operTypeId"];
            this.documentTypeId = _data["documentTypeId"];
            this.appOperation = _data["appOperation"];
        }
    }

    static fromJS(data: any): ImoAssetOperDocTypeEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetOperDocTypeEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operTypeId"] = this.operTypeId;
        data["documentTypeId"] = this.documentTypeId;
        data["appOperation"] = this.appOperation;
        return data;
    }

    clone(): ImoAssetOperDocTypeEditDto {
        const json = this.toJSON();
        let result = new ImoAssetOperDocTypeEditDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetOperDocTypeEditDto {
    id: number;
    operTypeId: number;
    documentTypeId: number;
    appOperation: boolean;
}

export class ImoAssetSetupDto implements IImoAssetSetupDto {
    id: number;
    reserveDepreciation: boolean;

    constructor(data?: IImoAssetSetupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reserveDepreciation = _data["reserveDepreciation"];
        }
    }

    static fromJS(data: any): ImoAssetSetupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetSetupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reserveDepreciation"] = this.reserveDepreciation;
        return data;
    }

    clone(): ImoAssetSetupDto {
        const json = this.toJSON();
        let result = new ImoAssetSetupDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetSetupDto {
    id: number;
    reserveDepreciation: boolean;
}

export class ImoAssetStorageDto implements IImoAssetStorageDto {
    id: number;
    storageName: string | undefined;
    centralStorage: boolean;
    appClientId: number;

    constructor(data?: IImoAssetStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storageName = _data["storageName"];
            this.centralStorage = _data["centralStorage"];
            this.appClientId = _data["appClientId"];
        }
    }

    static fromJS(data: any): ImoAssetStorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetStorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storageName"] = this.storageName;
        data["centralStorage"] = this.centralStorage;
        data["appClientId"] = this.appClientId;
        return data;
    }

    clone(): ImoAssetStorageDto {
        const json = this.toJSON();
        let result = new ImoAssetStorageDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetStorageDto {
    id: number;
    storageName: string | undefined;
    centralStorage: boolean;
    appClientId: number;
}

export class GetImoAssetStorageOutput implements IGetImoAssetStorageOutput {
    getImoAssetStorage: ImoAssetStorageDto[] | undefined;

    constructor(data?: IGetImoAssetStorageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getImoAssetStorage"])) {
                this.getImoAssetStorage = [] as any;
                for (let item of _data["getImoAssetStorage"])
                    this.getImoAssetStorage.push(ImoAssetStorageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetImoAssetStorageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetImoAssetStorageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getImoAssetStorage)) {
            data["getImoAssetStorage"] = [];
            for (let item of this.getImoAssetStorage)
                data["getImoAssetStorage"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetImoAssetStorageOutput {
        const json = this.toJSON();
        let result = new GetImoAssetStorageOutput();
        result.init(json);
        return result;
    }
}

export interface IGetImoAssetStorageOutput {
    getImoAssetStorage: ImoAssetStorageDto[] | undefined;
}

export class ImoGestReserveDto implements IImoGestReserveDto {
    imoAssetStockId: number;
    operationDate: string | undefined;
    tranzDeprecReserve: number;
    deprecReserve: number;
    tranzReserve: number;
    reserve: number;
    expenseReserve: number;

    constructor(data?: IImoGestReserveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imoAssetStockId = _data["imoAssetStockId"];
            this.operationDate = _data["operationDate"];
            this.tranzDeprecReserve = _data["tranzDeprecReserve"];
            this.deprecReserve = _data["deprecReserve"];
            this.tranzReserve = _data["tranzReserve"];
            this.reserve = _data["reserve"];
            this.expenseReserve = _data["expenseReserve"];
        }
    }

    static fromJS(data: any): ImoGestReserveDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoGestReserveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imoAssetStockId"] = this.imoAssetStockId;
        data["operationDate"] = this.operationDate;
        data["tranzDeprecReserve"] = this.tranzDeprecReserve;
        data["deprecReserve"] = this.deprecReserve;
        data["tranzReserve"] = this.tranzReserve;
        data["reserve"] = this.reserve;
        data["expenseReserve"] = this.expenseReserve;
        return data;
    }

    clone(): ImoGestReserveDto {
        const json = this.toJSON();
        let result = new ImoGestReserveDto();
        result.init(json);
        return result;
    }
}

export interface IImoGestReserveDto {
    imoAssetStockId: number;
    operationDate: string | undefined;
    tranzDeprecReserve: number;
    deprecReserve: number;
    tranzReserve: number;
    reserve: number;
    expenseReserve: number;
}

export class ImoGestModernizDto implements IImoGestModernizDto {
    imoAssetStockId: number;
    operationDate: string | undefined;
    tranzDeprecModerniz: number;
    deprecModerniz: number;
    tranzModerniz: number;
    moderniz: number;
    expenseModerniz: number;

    constructor(data?: IImoGestModernizDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imoAssetStockId = _data["imoAssetStockId"];
            this.operationDate = _data["operationDate"];
            this.tranzDeprecModerniz = _data["tranzDeprecModerniz"];
            this.deprecModerniz = _data["deprecModerniz"];
            this.tranzModerniz = _data["tranzModerniz"];
            this.moderniz = _data["moderniz"];
            this.expenseModerniz = _data["expenseModerniz"];
        }
    }

    static fromJS(data: any): ImoGestModernizDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoGestModernizDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imoAssetStockId"] = this.imoAssetStockId;
        data["operationDate"] = this.operationDate;
        data["tranzDeprecModerniz"] = this.tranzDeprecModerniz;
        data["deprecModerniz"] = this.deprecModerniz;
        data["tranzModerniz"] = this.tranzModerniz;
        data["moderniz"] = this.moderniz;
        data["expenseModerniz"] = this.expenseModerniz;
        return data;
    }

    clone(): ImoGestModernizDto {
        const json = this.toJSON();
        let result = new ImoGestModernizDto();
        result.init(json);
        return result;
    }
}

export interface IImoGestModernizDto {
    imoAssetStockId: number;
    operationDate: string | undefined;
    tranzDeprecModerniz: number;
    deprecModerniz: number;
    tranzModerniz: number;
    moderniz: number;
    expenseModerniz: number;
}

export class ImoGestDetailListDto implements IImoGestDetailListDto {
    id: number;
    imoAssetItem: string | undefined;
    stockDate: moment.Moment;
    stockDateStr: string | undefined;
    operType: string | undefined;
    tranzQuantity: number;
    quantity: number;
    tranzDuration: number;
    duration: number;
    storage: string | undefined;
    tranzInventoryValue: number;
    inventoryValue: number;
    tranzFiscalInventoryValue: number;
    fiscalInventoryValue: number;
    tranzDeprec: number;
    deprec: number;
    tranzFiscalDeprec: number;
    fiscalDeprec: number;
    reserveDetail: ImoGestReserveDto[] | undefined;
    modernizDetail: ImoGestModernizDto[] | undefined;
    showReserve: boolean;
    showModerniz: boolean;

    constructor(data?: IImoGestDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imoAssetItem = _data["imoAssetItem"];
            this.stockDate = _data["stockDate"] ? moment(_data["stockDate"].toString()) : <any>undefined;
            this.stockDateStr = _data["stockDateStr"];
            this.operType = _data["operType"];
            this.tranzQuantity = _data["tranzQuantity"];
            this.quantity = _data["quantity"];
            this.tranzDuration = _data["tranzDuration"];
            this.duration = _data["duration"];
            this.storage = _data["storage"];
            this.tranzInventoryValue = _data["tranzInventoryValue"];
            this.inventoryValue = _data["inventoryValue"];
            this.tranzFiscalInventoryValue = _data["tranzFiscalInventoryValue"];
            this.fiscalInventoryValue = _data["fiscalInventoryValue"];
            this.tranzDeprec = _data["tranzDeprec"];
            this.deprec = _data["deprec"];
            this.tranzFiscalDeprec = _data["tranzFiscalDeprec"];
            this.fiscalDeprec = _data["fiscalDeprec"];
            if (Array.isArray(_data["reserveDetail"])) {
                this.reserveDetail = [] as any;
                for (let item of _data["reserveDetail"])
                    this.reserveDetail.push(ImoGestReserveDto.fromJS(item));
            }
            if (Array.isArray(_data["modernizDetail"])) {
                this.modernizDetail = [] as any;
                for (let item of _data["modernizDetail"])
                    this.modernizDetail.push(ImoGestModernizDto.fromJS(item));
            }
            this.showReserve = _data["showReserve"];
            this.showModerniz = _data["showModerniz"];
        }
    }

    static fromJS(data: any): ImoGestDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoGestDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imoAssetItem"] = this.imoAssetItem;
        data["stockDate"] = this.stockDate ? this.stockDate.toISOString() : <any>undefined;
        data["stockDateStr"] = this.stockDateStr;
        data["operType"] = this.operType;
        data["tranzQuantity"] = this.tranzQuantity;
        data["quantity"] = this.quantity;
        data["tranzDuration"] = this.tranzDuration;
        data["duration"] = this.duration;
        data["storage"] = this.storage;
        data["tranzInventoryValue"] = this.tranzInventoryValue;
        data["inventoryValue"] = this.inventoryValue;
        data["tranzFiscalInventoryValue"] = this.tranzFiscalInventoryValue;
        data["fiscalInventoryValue"] = this.fiscalInventoryValue;
        data["tranzDeprec"] = this.tranzDeprec;
        data["deprec"] = this.deprec;
        data["tranzFiscalDeprec"] = this.tranzFiscalDeprec;
        data["fiscalDeprec"] = this.fiscalDeprec;
        if (Array.isArray(this.reserveDetail)) {
            data["reserveDetail"] = [];
            for (let item of this.reserveDetail)
                data["reserveDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.modernizDetail)) {
            data["modernizDetail"] = [];
            for (let item of this.modernizDetail)
                data["modernizDetail"].push(item.toJSON());
        }
        data["showReserve"] = this.showReserve;
        data["showModerniz"] = this.showModerniz;
        return data;
    }

    clone(): ImoGestDetailListDto {
        const json = this.toJSON();
        let result = new ImoGestDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IImoGestDetailListDto {
    id: number;
    imoAssetItem: string | undefined;
    stockDate: moment.Moment;
    stockDateStr: string | undefined;
    operType: string | undefined;
    tranzQuantity: number;
    quantity: number;
    tranzDuration: number;
    duration: number;
    storage: string | undefined;
    tranzInventoryValue: number;
    inventoryValue: number;
    tranzFiscalInventoryValue: number;
    fiscalInventoryValue: number;
    tranzDeprec: number;
    deprec: number;
    tranzFiscalDeprec: number;
    fiscalDeprec: number;
    reserveDetail: ImoGestReserveDto[] | undefined;
    modernizDetail: ImoGestModernizDto[] | undefined;
    showReserve: boolean;
    showModerniz: boolean;
}

export class ImoGestListDto implements IImoGestListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    assetId: number | undefined;
    storageId: number | undefined;
    gestDetail: ImoGestDetailListDto[] | undefined;

    constructor(data?: IImoGestListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.assetId = _data["assetId"];
            this.storageId = _data["storageId"];
            if (Array.isArray(_data["gestDetail"])) {
                this.gestDetail = [] as any;
                for (let item of _data["gestDetail"])
                    this.gestDetail.push(ImoGestDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImoGestListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoGestListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["assetId"] = this.assetId;
        data["storageId"] = this.storageId;
        if (Array.isArray(this.gestDetail)) {
            data["gestDetail"] = [];
            for (let item of this.gestDetail)
                data["gestDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImoGestListDto {
        const json = this.toJSON();
        let result = new ImoGestListDto();
        result.init(json);
        return result;
    }
}

export interface IImoGestListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    assetId: number | undefined;
    storageId: number | undefined;
    gestDetail: ImoGestDetailListDto[] | undefined;
}

export class ImoAssetStorageDDDto implements IImoAssetStorageDDDto {
    id: number;
    name: string | undefined;

    constructor(data?: IImoAssetStorageDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ImoAssetStorageDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetStorageDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ImoAssetStorageDDDto {
        const json = this.toJSON();
        let result = new ImoAssetStorageDDDto();
        result.init(json);
        return result;
    }
}

export interface IImoAssetStorageDDDto {
    id: number;
    name: string | undefined;
}

export class ImoOperationListDto implements IImoOperationListDto {
    id: number;
    operationDate: moment.Moment;
    operationDateStr: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    documentDateStr: string | undefined;
    documentType: string | undefined;
    operationType: string | undefined;
    storageOut: string | undefined;
    storageIn: string | undefined;
    ordProcess: number;
    operationDateSort: moment.Moment;

    constructor(data?: IImoOperationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.operationDateStr = _data["operationDateStr"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.documentDateStr = _data["documentDateStr"];
            this.documentType = _data["documentType"];
            this.operationType = _data["operationType"];
            this.storageOut = _data["storageOut"];
            this.storageIn = _data["storageIn"];
            this.ordProcess = _data["ordProcess"];
            this.operationDateSort = _data["operationDateSort"] ? moment(_data["operationDateSort"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ImoOperationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoOperationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["operationDateStr"] = this.operationDateStr;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["documentDateStr"] = this.documentDateStr;
        data["documentType"] = this.documentType;
        data["operationType"] = this.operationType;
        data["storageOut"] = this.storageOut;
        data["storageIn"] = this.storageIn;
        data["ordProcess"] = this.ordProcess;
        data["operationDateSort"] = this.operationDateSort ? this.operationDateSort.toISOString() : <any>undefined;
        return data;
    }

    clone(): ImoOperationListDto {
        const json = this.toJSON();
        let result = new ImoOperationListDto();
        result.init(json);
        return result;
    }
}

export interface IImoOperationListDto {
    id: number;
    operationDate: moment.Moment;
    operationDateStr: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    documentDateStr: string | undefined;
    documentType: string | undefined;
    operationType: string | undefined;
    storageOut: string | undefined;
    storageIn: string | undefined;
    ordProcess: number;
    operationDateSort: moment.Moment;
}

export class ImoGestComputeListDto implements IImoGestComputeListDto {
    unprocessedDate: moment.Moment;
    computeDate: moment.Moment | undefined;
    showCompute: boolean;
    operationList: ImoOperationListDto[] | undefined;

    constructor(data?: IImoGestComputeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unprocessedDate = _data["unprocessedDate"] ? moment(_data["unprocessedDate"].toString()) : <any>undefined;
            this.computeDate = _data["computeDate"] ? moment(_data["computeDate"].toString()) : <any>undefined;
            this.showCompute = _data["showCompute"];
            if (Array.isArray(_data["operationList"])) {
                this.operationList = [] as any;
                for (let item of _data["operationList"])
                    this.operationList.push(ImoOperationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImoGestComputeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoGestComputeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unprocessedDate"] = this.unprocessedDate ? this.unprocessedDate.toISOString() : <any>undefined;
        data["computeDate"] = this.computeDate ? this.computeDate.toISOString() : <any>undefined;
        data["showCompute"] = this.showCompute;
        if (Array.isArray(this.operationList)) {
            data["operationList"] = [];
            for (let item of this.operationList)
                data["operationList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImoGestComputeListDto {
        const json = this.toJSON();
        let result = new ImoGestComputeListDto();
        result.init(json);
        return result;
    }
}

export interface IImoGestComputeListDto {
    unprocessedDate: moment.Moment;
    computeDate: moment.Moment | undefined;
    showCompute: boolean;
    operationList: ImoOperationListDto[] | undefined;
}

export class ImoGestDelDetailDto implements IImoGestDelDetailDto {
    dateGest: moment.Moment;

    constructor(data?: IImoGestDelDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateGest = _data["dateGest"] ? moment(_data["dateGest"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ImoGestDelDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoGestDelDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateGest"] = this.dateGest ? this.dateGest.toISOString() : <any>undefined;
        return data;
    }

    clone(): ImoGestDelDetailDto {
        const json = this.toJSON();
        let result = new ImoGestDelDetailDto();
        result.init(json);
        return result;
    }
}

export interface IImoGestDelDetailDto {
    dateGest: moment.Moment;
}

export class ImoGestDelListDto implements IImoGestDelListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    gestDelDetail: ImoGestDelDetailDto[] | undefined;

    constructor(data?: IImoGestDelListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            if (Array.isArray(_data["gestDelDetail"])) {
                this.gestDelDetail = [] as any;
                for (let item of _data["gestDelDetail"])
                    this.gestDelDetail.push(ImoGestDelDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImoGestDelListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoGestDelListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        if (Array.isArray(this.gestDelDetail)) {
            data["gestDelDetail"] = [];
            for (let item of this.gestDelDetail)
                data["gestDelDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImoGestDelListDto {
        const json = this.toJSON();
        let result = new ImoGestDelListDto();
        result.init(json);
        return result;
    }
}

export interface IImoGestDelListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    gestDelDetail: ImoGestDelDetailDto[] | undefined;
}

export class ImoGestRowDto implements IImoGestRowDto {
    imoAssetItemId: number;
    operType: ImoAssetOperType;
    stockDate: moment.Moment;
    tranzQuantity: number;
    quantity: number;
    tranzDuration: number;
    duration: number;
    storageId: number;
    tranzInventoryValue: number;
    inventoryValue: number;
    tranzFiscalInventoryValue: number;
    fiscalInventoryValue: number;
    tranzDeprec: number;
    deprec: number;
    tranzFiscalDeprec: number;
    fiscalDeprec: number;
    inConservare: boolean;

    constructor(data?: IImoGestRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imoAssetItemId = _data["imoAssetItemId"];
            this.operType = _data["operType"];
            this.stockDate = _data["stockDate"] ? moment(_data["stockDate"].toString()) : <any>undefined;
            this.tranzQuantity = _data["tranzQuantity"];
            this.quantity = _data["quantity"];
            this.tranzDuration = _data["tranzDuration"];
            this.duration = _data["duration"];
            this.storageId = _data["storageId"];
            this.tranzInventoryValue = _data["tranzInventoryValue"];
            this.inventoryValue = _data["inventoryValue"];
            this.tranzFiscalInventoryValue = _data["tranzFiscalInventoryValue"];
            this.fiscalInventoryValue = _data["fiscalInventoryValue"];
            this.tranzDeprec = _data["tranzDeprec"];
            this.deprec = _data["deprec"];
            this.tranzFiscalDeprec = _data["tranzFiscalDeprec"];
            this.fiscalDeprec = _data["fiscalDeprec"];
            this.inConservare = _data["inConservare"];
        }
    }

    static fromJS(data: any): ImoGestRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoGestRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imoAssetItemId"] = this.imoAssetItemId;
        data["operType"] = this.operType;
        data["stockDate"] = this.stockDate ? this.stockDate.toISOString() : <any>undefined;
        data["tranzQuantity"] = this.tranzQuantity;
        data["quantity"] = this.quantity;
        data["tranzDuration"] = this.tranzDuration;
        data["duration"] = this.duration;
        data["storageId"] = this.storageId;
        data["tranzInventoryValue"] = this.tranzInventoryValue;
        data["inventoryValue"] = this.inventoryValue;
        data["tranzFiscalInventoryValue"] = this.tranzFiscalInventoryValue;
        data["fiscalInventoryValue"] = this.fiscalInventoryValue;
        data["tranzDeprec"] = this.tranzDeprec;
        data["deprec"] = this.deprec;
        data["tranzFiscalDeprec"] = this.tranzFiscalDeprec;
        data["fiscalDeprec"] = this.fiscalDeprec;
        data["inConservare"] = this.inConservare;
        return data;
    }

    clone(): ImoGestRowDto {
        const json = this.toJSON();
        let result = new ImoGestRowDto();
        result.init(json);
        return result;
    }
}

export interface IImoGestRowDto {
    imoAssetItemId: number;
    operType: ImoAssetOperType;
    stockDate: moment.Moment;
    tranzQuantity: number;
    quantity: number;
    tranzDuration: number;
    duration: number;
    storageId: number;
    tranzInventoryValue: number;
    inventoryValue: number;
    tranzFiscalInventoryValue: number;
    fiscalInventoryValue: number;
    tranzDeprec: number;
    deprec: number;
    tranzFiscalDeprec: number;
    fiscalDeprec: number;
    inConservare: boolean;
}

export class ImoInventariereListDto implements IImoInventariereListDto {
    id: number;
    dateStart: moment.Moment;
    state: State;

    constructor(data?: IImoInventariereListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateStart = _data["dateStart"] ? moment(_data["dateStart"].toString()) : <any>undefined;
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): ImoInventariereListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoInventariereListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        data["state"] = this.state;
        return data;
    }

    clone(): ImoInventariereListDto {
        const json = this.toJSON();
        let result = new ImoInventariereListDto();
        result.init(json);
        return result;
    }
}

export interface IImoInventariereListDto {
    id: number;
    dateStart: moment.Moment;
    state: State;
}

export class ImoInventariereInitDto implements IImoInventariereInitDto {
    dateStart: moment.Moment;
    dateEnd: moment.Moment;
    imoInventariereList: ImoInventariereListDto[] | undefined;

    constructor(data?: IImoInventariereInitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateStart = _data["dateStart"] ? moment(_data["dateStart"].toString()) : <any>undefined;
            this.dateEnd = _data["dateEnd"] ? moment(_data["dateEnd"].toString()) : <any>undefined;
            if (Array.isArray(_data["imoInventariereList"])) {
                this.imoInventariereList = [] as any;
                for (let item of _data["imoInventariereList"])
                    this.imoInventariereList.push(ImoInventariereListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImoInventariereInitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoInventariereInitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        data["dateEnd"] = this.dateEnd ? this.dateEnd.toISOString() : <any>undefined;
        if (Array.isArray(this.imoInventariereList)) {
            data["imoInventariereList"] = [];
            for (let item of this.imoInventariereList)
                data["imoInventariereList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImoInventariereInitDto {
        const json = this.toJSON();
        let result = new ImoInventariereInitDto();
        result.init(json);
        return result;
    }
}

export interface IImoInventariereInitDto {
    dateStart: moment.Moment;
    dateEnd: moment.Moment;
    imoInventariereList: ImoInventariereListDto[] | undefined;
}

export class ImoInventariereDetailDto implements IImoInventariereDetailDto {
    id: number;
    imoInventariereId: number;
    description: string | undefined;
    useStartDate: moment.Moment | undefined;
    inventoryNumber: number;
    inventoryValue: number;
    remainingValue: number;
    stockScriptic: number;
    stockFaptic: number;
    imoAssetStockId: number;
    imoAssetItemId: number;
    storageInId: number | undefined;
    storageIn: string | undefined;
    tenantId: number;

    constructor(data?: IImoInventariereDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imoInventariereId = _data["imoInventariereId"];
            this.description = _data["description"];
            this.useStartDate = _data["useStartDate"] ? moment(_data["useStartDate"].toString()) : <any>undefined;
            this.inventoryNumber = _data["inventoryNumber"];
            this.inventoryValue = _data["inventoryValue"];
            this.remainingValue = _data["remainingValue"];
            this.stockScriptic = _data["stockScriptic"];
            this.stockFaptic = _data["stockFaptic"];
            this.imoAssetStockId = _data["imoAssetStockId"];
            this.imoAssetItemId = _data["imoAssetItemId"];
            this.storageInId = _data["storageInId"];
            this.storageIn = _data["storageIn"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): ImoInventariereDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoInventariereDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imoInventariereId"] = this.imoInventariereId;
        data["description"] = this.description;
        data["useStartDate"] = this.useStartDate ? this.useStartDate.toISOString() : <any>undefined;
        data["inventoryNumber"] = this.inventoryNumber;
        data["inventoryValue"] = this.inventoryValue;
        data["remainingValue"] = this.remainingValue;
        data["stockScriptic"] = this.stockScriptic;
        data["stockFaptic"] = this.stockFaptic;
        data["imoAssetStockId"] = this.imoAssetStockId;
        data["imoAssetItemId"] = this.imoAssetItemId;
        data["storageInId"] = this.storageInId;
        data["storageIn"] = this.storageIn;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): ImoInventariereDetailDto {
        const json = this.toJSON();
        let result = new ImoInventariereDetailDto();
        result.init(json);
        return result;
    }
}

export interface IImoInventariereDetailDto {
    id: number;
    imoInventariereId: number;
    description: string | undefined;
    useStartDate: moment.Moment | undefined;
    inventoryNumber: number;
    inventoryValue: number;
    remainingValue: number;
    stockScriptic: number;
    stockFaptic: number;
    imoAssetStockId: number;
    imoAssetItemId: number;
    storageInId: number | undefined;
    storageIn: string | undefined;
    tenantId: number;
}

export class ImoInventariereEditDto implements IImoInventariereEditDto {
    id: number;
    dateStart: moment.Moment;
    imoInventariereDetails: ImoInventariereDetailDto[] | undefined;

    constructor(data?: IImoInventariereEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateStart = _data["dateStart"] ? moment(_data["dateStart"].toString()) : <any>undefined;
            if (Array.isArray(_data["imoInventariereDetails"])) {
                this.imoInventariereDetails = [] as any;
                for (let item of _data["imoInventariereDetails"])
                    this.imoInventariereDetails.push(ImoInventariereDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImoInventariereEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImoInventariereEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        if (Array.isArray(this.imoInventariereDetails)) {
            data["imoInventariereDetails"] = [];
            for (let item of this.imoInventariereDetails)
                data["imoInventariereDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImoInventariereEditDto {
        const json = this.toJSON();
        let result = new ImoInventariereEditDto();
        result.init(json);
        return result;
    }
}

export interface IImoInventariereEditDto {
    id: number;
    dateStart: moment.Moment;
    imoInventariereDetails: ImoInventariereDetailDto[] | undefined;
}

export class InventoryDDList implements IInventoryDDList {
    id: number;
    invObjectDate: string | undefined;

    constructor(data?: IInventoryDDList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invObjectDate = _data["invObjectDate"];
        }
    }

    static fromJS(data: any): InventoryDDList {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryDDList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invObjectDate"] = this.invObjectDate;
        return data;
    }

    clone(): InventoryDDList {
        const json = this.toJSON();
        let result = new InventoryDDList();
        result.init(json);
        return result;
    }
}

export interface IInventoryDDList {
    id: number;
    invObjectDate: string | undefined;
}

export class ImprumutDto implements IImprumutDto {
    id: number;
    documentType: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    imprumuturiTipuri: string | undefined;
    currency: string | undefined;
    bank: string | undefined;
    loanAccount: string | undefined;
    paymentAccount: string | undefined;
    loanDate: moment.Moment;
    startDate: moment.Moment;
    durata: number;
    imprumuturiTipDurata: string | undefined;
    imprumuturiStare: string | undefined;
    perioadaTipDurata: string | undefined;
    activityType: string | undefined;
    dobanziReferinta: string | undefined;
    tipCreditare: string | undefined;
    periodicitate: number;
    tipRata: string | undefined;
    tipDobanda: string | undefined;
    endDate: moment.Moment;
    imprumuturiTermen: string | undefined;
    suma: number;
    procentDobanda: number;
    marjaFixa: number;
    isFinalDeLuna: boolean;
    dobanziReferintaId: number | undefined;
    thirdParty: string | undefined;
    contContabilId: number;

    constructor(data?: IImprumutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentType = _data["documentType"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.imprumuturiTipuri = _data["imprumuturiTipuri"];
            this.currency = _data["currency"];
            this.bank = _data["bank"];
            this.loanAccount = _data["loanAccount"];
            this.paymentAccount = _data["paymentAccount"];
            this.loanDate = _data["loanDate"] ? moment(_data["loanDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.durata = _data["durata"];
            this.imprumuturiTipDurata = _data["imprumuturiTipDurata"];
            this.imprumuturiStare = _data["imprumuturiStare"];
            this.perioadaTipDurata = _data["perioadaTipDurata"];
            this.activityType = _data["activityType"];
            this.dobanziReferinta = _data["dobanziReferinta"];
            this.tipCreditare = _data["tipCreditare"];
            this.periodicitate = _data["periodicitate"];
            this.tipRata = _data["tipRata"];
            this.tipDobanda = _data["tipDobanda"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.imprumuturiTermen = _data["imprumuturiTermen"];
            this.suma = _data["suma"];
            this.procentDobanda = _data["procentDobanda"];
            this.marjaFixa = _data["marjaFixa"];
            this.isFinalDeLuna = _data["isFinalDeLuna"];
            this.dobanziReferintaId = _data["dobanziReferintaId"];
            this.thirdParty = _data["thirdParty"];
            this.contContabilId = _data["contContabilId"];
        }
    }

    static fromJS(data: any): ImprumutDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentType"] = this.documentType;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["imprumuturiTipuri"] = this.imprumuturiTipuri;
        data["currency"] = this.currency;
        data["bank"] = this.bank;
        data["loanAccount"] = this.loanAccount;
        data["paymentAccount"] = this.paymentAccount;
        data["loanDate"] = this.loanDate ? this.loanDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["durata"] = this.durata;
        data["imprumuturiTipDurata"] = this.imprumuturiTipDurata;
        data["imprumuturiStare"] = this.imprumuturiStare;
        data["perioadaTipDurata"] = this.perioadaTipDurata;
        data["activityType"] = this.activityType;
        data["dobanziReferinta"] = this.dobanziReferinta;
        data["tipCreditare"] = this.tipCreditare;
        data["periodicitate"] = this.periodicitate;
        data["tipRata"] = this.tipRata;
        data["tipDobanda"] = this.tipDobanda;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["imprumuturiTermen"] = this.imprumuturiTermen;
        data["suma"] = this.suma;
        data["procentDobanda"] = this.procentDobanda;
        data["marjaFixa"] = this.marjaFixa;
        data["isFinalDeLuna"] = this.isFinalDeLuna;
        data["dobanziReferintaId"] = this.dobanziReferintaId;
        data["thirdParty"] = this.thirdParty;
        data["contContabilId"] = this.contContabilId;
        return data;
    }

    clone(): ImprumutDto {
        const json = this.toJSON();
        let result = new ImprumutDto();
        result.init(json);
        return result;
    }
}

export interface IImprumutDto {
    id: number;
    documentType: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    imprumuturiTipuri: string | undefined;
    currency: string | undefined;
    bank: string | undefined;
    loanAccount: string | undefined;
    paymentAccount: string | undefined;
    loanDate: moment.Moment;
    startDate: moment.Moment;
    durata: number;
    imprumuturiTipDurata: string | undefined;
    imprumuturiStare: string | undefined;
    perioadaTipDurata: string | undefined;
    activityType: string | undefined;
    dobanziReferinta: string | undefined;
    tipCreditare: string | undefined;
    periodicitate: number;
    tipRata: string | undefined;
    tipDobanda: string | undefined;
    endDate: moment.Moment;
    imprumuturiTermen: string | undefined;
    suma: number;
    procentDobanda: number;
    marjaFixa: number;
    isFinalDeLuna: boolean;
    dobanziReferintaId: number | undefined;
    thirdParty: string | undefined;
    contContabilId: number;
}

export class ImprumutEditDto implements IImprumutEditDto {
    id: number;
    documentTypeId: number | undefined;
    documentNr: number | undefined;
    documentDate: moment.Moment;
    imprumuturiTipuriId: number | undefined;
    currencyId: number;
    bankId: number;
    loanAccountId: number | undefined;
    paymentAccountId: number | undefined;
    dobanziReferintaId: number | undefined;
    activityTypeId: number | undefined;
    thirdPartyId: number | undefined;
    loanDate: moment.Moment;
    startDate: moment.Moment;
    isFinalDeLuna: boolean;
    durata: number;
    imprumuturiTipDurata: ImprumuturiTipDurata;
    perioadaTipDurata: PerioadaTipDurata;
    tipRata: TipRata;
    tipDobanda: TipDobanda;
    tipCreditare: TipCreditare;
    endDate: moment.Moment;
    periodicitate: number;
    imprumuturiTermenId: number | undefined;
    suma: number;
    procentDobanda: number;
    marjaFixa: number;
    contContabilId: number;
    okDelete: boolean;
    accountName: AccountListDDDto;

    constructor(data?: IImprumutEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.imprumuturiTipuriId = _data["imprumuturiTipuriId"];
            this.currencyId = _data["currencyId"];
            this.bankId = _data["bankId"];
            this.loanAccountId = _data["loanAccountId"];
            this.paymentAccountId = _data["paymentAccountId"];
            this.dobanziReferintaId = _data["dobanziReferintaId"];
            this.activityTypeId = _data["activityTypeId"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.loanDate = _data["loanDate"] ? moment(_data["loanDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.isFinalDeLuna = _data["isFinalDeLuna"];
            this.durata = _data["durata"];
            this.imprumuturiTipDurata = _data["imprumuturiTipDurata"];
            this.perioadaTipDurata = _data["perioadaTipDurata"];
            this.tipRata = _data["tipRata"];
            this.tipDobanda = _data["tipDobanda"];
            this.tipCreditare = _data["tipCreditare"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.periodicitate = _data["periodicitate"];
            this.imprumuturiTermenId = _data["imprumuturiTermenId"];
            this.suma = _data["suma"];
            this.procentDobanda = _data["procentDobanda"];
            this.marjaFixa = _data["marjaFixa"];
            this.contContabilId = _data["contContabilId"];
            this.okDelete = _data["okDelete"];
            this.accountName = _data["accountName"] ? AccountListDDDto.fromJS(_data["accountName"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImprumutEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumutEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentTypeId"] = this.documentTypeId;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["imprumuturiTipuriId"] = this.imprumuturiTipuriId;
        data["currencyId"] = this.currencyId;
        data["bankId"] = this.bankId;
        data["loanAccountId"] = this.loanAccountId;
        data["paymentAccountId"] = this.paymentAccountId;
        data["dobanziReferintaId"] = this.dobanziReferintaId;
        data["activityTypeId"] = this.activityTypeId;
        data["thirdPartyId"] = this.thirdPartyId;
        data["loanDate"] = this.loanDate ? this.loanDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["isFinalDeLuna"] = this.isFinalDeLuna;
        data["durata"] = this.durata;
        data["imprumuturiTipDurata"] = this.imprumuturiTipDurata;
        data["perioadaTipDurata"] = this.perioadaTipDurata;
        data["tipRata"] = this.tipRata;
        data["tipDobanda"] = this.tipDobanda;
        data["tipCreditare"] = this.tipCreditare;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["periodicitate"] = this.periodicitate;
        data["imprumuturiTermenId"] = this.imprumuturiTermenId;
        data["suma"] = this.suma;
        data["procentDobanda"] = this.procentDobanda;
        data["marjaFixa"] = this.marjaFixa;
        data["contContabilId"] = this.contContabilId;
        data["okDelete"] = this.okDelete;
        data["accountName"] = this.accountName ? this.accountName.toJSON() : <any>undefined;
        return data;
    }

    clone(): ImprumutEditDto {
        const json = this.toJSON();
        let result = new ImprumutEditDto();
        result.init(json);
        return result;
    }
}

export interface IImprumutEditDto {
    id: number;
    documentTypeId: number | undefined;
    documentNr: number | undefined;
    documentDate: moment.Moment;
    imprumuturiTipuriId: number | undefined;
    currencyId: number;
    bankId: number;
    loanAccountId: number | undefined;
    paymentAccountId: number | undefined;
    dobanziReferintaId: number | undefined;
    activityTypeId: number | undefined;
    thirdPartyId: number | undefined;
    loanDate: moment.Moment;
    startDate: moment.Moment;
    isFinalDeLuna: boolean;
    durata: number;
    imprumuturiTipDurata: ImprumuturiTipDurata;
    perioadaTipDurata: PerioadaTipDurata;
    tipRata: TipRata;
    tipDobanda: TipDobanda;
    tipCreditare: TipCreditare;
    endDate: moment.Moment;
    periodicitate: number;
    imprumuturiTermenId: number | undefined;
    suma: number;
    procentDobanda: number;
    marjaFixa: number;
    contContabilId: number;
    okDelete: boolean;
    accountName: AccountListDDDto;
}

export class ImprumutStateDto implements IImprumutStateDto {
    imprumuturiStare: ImprumuturiStare;
    imprumuturiStareString: string | undefined;
    comentariu: string | undefined;
    operationDate: moment.Moment;
    imprumutId: number | undefined;
    tenantId: number;

    constructor(data?: IImprumutStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imprumuturiStare = _data["imprumuturiStare"];
            this.imprumuturiStareString = _data["imprumuturiStareString"];
            this.comentariu = _data["comentariu"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.imprumutId = _data["imprumutId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): ImprumutStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumutStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imprumuturiStare"] = this.imprumuturiStare;
        data["imprumuturiStareString"] = this.imprumuturiStareString;
        data["comentariu"] = this.comentariu;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["imprumutId"] = this.imprumutId;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): ImprumutStateDto {
        const json = this.toJSON();
        let result = new ImprumutStateDto();
        result.init(json);
        return result;
    }
}

export interface IImprumutStateDto {
    imprumuturiStare: ImprumuturiStare;
    imprumuturiStareString: string | undefined;
    comentariu: string | undefined;
    operationDate: moment.Moment;
    imprumutId: number | undefined;
    tenantId: number;
}

export class ImprumuturiTermenDto implements IImprumuturiTermenDto {
    id: number;
    description: string | undefined;
    minValue: number;
    maxValue: number;

    constructor(data?: IImprumuturiTermenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
        }
    }

    static fromJS(data: any): ImprumuturiTermenDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumuturiTermenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        return data;
    }

    clone(): ImprumuturiTermenDto {
        const json = this.toJSON();
        let result = new ImprumuturiTermenDto();
        result.init(json);
        return result;
    }
}

export interface IImprumuturiTermenDto {
    id: number;
    description: string | undefined;
    minValue: number;
    maxValue: number;
}

export class ImprumuturiTermenEditDto implements IImprumuturiTermenEditDto {
    id: number;
    description: string | undefined;
    minValue: number;
    maxValue: number;
    okDelete: boolean;

    constructor(data?: IImprumuturiTermenEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): ImprumuturiTermenEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumuturiTermenEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): ImprumuturiTermenEditDto {
        const json = this.toJSON();
        let result = new ImprumuturiTermenEditDto();
        result.init(json);
        return result;
    }
}

export interface IImprumuturiTermenEditDto {
    id: number;
    description: string | undefined;
    minValue: number;
    maxValue: number;
    okDelete: boolean;
}

export class ImprumuturiTipuriDto implements IImprumuturiTipuriDto {
    id: number;
    description: string | undefined;

    constructor(data?: IImprumuturiTipuriDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ImprumuturiTipuriDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumuturiTipuriDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        return data;
    }

    clone(): ImprumuturiTipuriDto {
        const json = this.toJSON();
        let result = new ImprumuturiTipuriDto();
        result.init(json);
        return result;
    }
}

export interface IImprumuturiTipuriDto {
    id: number;
    description: string | undefined;
}

export class ImprumuturiTipuriEditDto implements IImprumuturiTipuriEditDto {
    id: number;
    description: string | undefined;
    okDelete: boolean;

    constructor(data?: IImprumuturiTipuriEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): ImprumuturiTipuriEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumuturiTipuriEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): ImprumuturiTipuriEditDto {
        const json = this.toJSON();
        let result = new ImprumuturiTipuriEditDto();
        result.init(json);
        return result;
    }
}

export interface IImprumuturiTipuriEditDto {
    id: number;
    description: string | undefined;
    okDelete: boolean;
}

export class ImprumutTipDetaliuDto implements IImprumutTipDetaliuDto {
    id: number;
    imprumutTipId: number;
    description: string | undefined;
    activityTypeName: string | undefined;
    contImprumut: string | undefined;

    constructor(data?: IImprumutTipDetaliuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imprumutTipId = _data["imprumutTipId"];
            this.description = _data["description"];
            this.activityTypeName = _data["activityTypeName"];
            this.contImprumut = _data["contImprumut"];
        }
    }

    static fromJS(data: any): ImprumutTipDetaliuDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumutTipDetaliuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imprumutTipId"] = this.imprumutTipId;
        data["description"] = this.description;
        data["activityTypeName"] = this.activityTypeName;
        data["contImprumut"] = this.contImprumut;
        return data;
    }

    clone(): ImprumutTipDetaliuDto {
        const json = this.toJSON();
        let result = new ImprumutTipDetaliuDto();
        result.init(json);
        return result;
    }
}

export interface IImprumutTipDetaliuDto {
    id: number;
    imprumutTipId: number;
    description: string | undefined;
    activityTypeName: string | undefined;
    contImprumut: string | undefined;
}

export class ImprumutTipDetaliuEditDto implements IImprumutTipDetaliuEditDto {
    imprumutTipId: number;
    description: string | undefined;
    activityTypeId: number | undefined;
    contImprumut: string | undefined;

    constructor(data?: IImprumutTipDetaliuEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imprumutTipId = _data["imprumutTipId"];
            this.description = _data["description"];
            this.activityTypeId = _data["activityTypeId"];
            this.contImprumut = _data["contImprumut"];
        }
    }

    static fromJS(data: any): ImprumutTipDetaliuEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImprumutTipDetaliuEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imprumutTipId"] = this.imprumutTipId;
        data["description"] = this.description;
        data["activityTypeId"] = this.activityTypeId;
        data["contImprumut"] = this.contImprumut;
        return data;
    }

    clone(): ImprumutTipDetaliuEditDto {
        const json = this.toJSON();
        let result = new ImprumutTipDetaliuEditDto();
        result.init(json);
        return result;
    }
}

export interface IImprumutTipDetaliuEditDto {
    imprumutTipId: number;
    description: string | undefined;
    activityTypeId: number | undefined;
    contImprumut: string | undefined;
}

export class InvObjectListDto implements IInvObjectListDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;
    priceUnit: number;
    inventoryValue: number;
    operationDate: moment.Moment;
    documentNr: number;
    documentDate: moment.Moment;
    documentType: string | undefined;
    categoryName: string | undefined;
    categoryId: number;
    thirdParty: string | undefined;
    invoice: string | undefined;
    processed: boolean;

    constructor(data?: IInvObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.inventoryNr = _data["inventoryNr"];
            this.priceUnit = _data["priceUnit"];
            this.inventoryValue = _data["inventoryValue"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.documentType = _data["documentType"];
            this.categoryName = _data["categoryName"];
            this.categoryId = _data["categoryId"];
            this.thirdParty = _data["thirdParty"];
            this.invoice = _data["invoice"];
            this.processed = _data["processed"];
        }
    }

    static fromJS(data: any): InvObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["inventoryNr"] = this.inventoryNr;
        data["priceUnit"] = this.priceUnit;
        data["inventoryValue"] = this.inventoryValue;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["documentType"] = this.documentType;
        data["categoryName"] = this.categoryName;
        data["categoryId"] = this.categoryId;
        data["thirdParty"] = this.thirdParty;
        data["invoice"] = this.invoice;
        data["processed"] = this.processed;
        return data;
    }

    clone(): InvObjectListDto {
        const json = this.toJSON();
        let result = new InvObjectListDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectListDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;
    priceUnit: number;
    inventoryValue: number;
    operationDate: moment.Moment;
    documentNr: number;
    documentDate: moment.Moment;
    documentType: string | undefined;
    categoryName: string | undefined;
    categoryId: number;
    thirdParty: string | undefined;
    invoice: string | undefined;
    processed: boolean;
}

export class GetInvObjectOutput implements IGetInvObjectOutput {
    getInvObjects: InvObjectListDto[] | undefined;

    constructor(data?: IGetInvObjectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getInvObjects"])) {
                this.getInvObjects = [] as any;
                for (let item of _data["getInvObjects"])
                    this.getInvObjects.push(InvObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInvObjectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvObjectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getInvObjects)) {
            data["getInvObjects"] = [];
            for (let item of this.getInvObjects)
                data["getInvObjects"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetInvObjectOutput {
        const json = this.toJSON();
        let result = new GetInvObjectOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInvObjectOutput {
    getInvObjects: InvObjectListDto[] | undefined;
}

export enum InvObjectOperType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
}

export class InvObjectAddInvoiceDetailDto implements IInvObjectAddInvoiceDetailDto {
    invoiceId: number;
    activityTypeId: number | undefined;
    invoiceDetailsId: number | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    invObjectName: string | undefined;
    quantity: number;
    invValue: number;
    storageInId: number | undefined;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;

    constructor(data?: IInvObjectAddInvoiceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.activityTypeId = _data["activityTypeId"];
            this.invoiceDetailsId = _data["invoiceDetailsId"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.invObjectName = _data["invObjectName"];
            this.quantity = _data["quantity"];
            this.invValue = _data["invValue"];
            this.storageInId = _data["storageInId"];
            this.primDocumentTypeId = _data["primDocumentTypeId"];
            this.primDocumentNr = _data["primDocumentNr"];
            this.primDocumentDate = _data["primDocumentDate"] ? moment(_data["primDocumentDate"].toString()) : <any>undefined;
            this.thirdPartyId = _data["thirdPartyId"];
        }
    }

    static fromJS(data: any): InvObjectAddInvoiceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectAddInvoiceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["activityTypeId"] = this.activityTypeId;
        data["invoiceDetailsId"] = this.invoiceDetailsId;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["invObjectName"] = this.invObjectName;
        data["quantity"] = this.quantity;
        data["invValue"] = this.invValue;
        data["storageInId"] = this.storageInId;
        data["primDocumentTypeId"] = this.primDocumentTypeId;
        data["primDocumentNr"] = this.primDocumentNr;
        data["primDocumentDate"] = this.primDocumentDate ? this.primDocumentDate.toISOString() : <any>undefined;
        data["thirdPartyId"] = this.thirdPartyId;
        return data;
    }

    clone(): InvObjectAddInvoiceDetailDto {
        const json = this.toJSON();
        let result = new InvObjectAddInvoiceDetailDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectAddInvoiceDetailDto {
    invoiceId: number;
    activityTypeId: number | undefined;
    invoiceDetailsId: number | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    invObjectName: string | undefined;
    quantity: number;
    invValue: number;
    storageInId: number | undefined;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
}

export class InvObjectAddDetailDto implements IInvObjectAddDetailDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;
    quantity: number;
    inventoryValue: number;
    invoiceDetailsId: number | undefined;
    invCategoryId: number | undefined;
    invObjectAccountId: number | undefined;
    expenseAccountId: number | undefined;
    storageInId: number | undefined;
    storageIn: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;

    constructor(data?: IInvObjectAddDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.inventoryNr = _data["inventoryNr"];
            this.quantity = _data["quantity"];
            this.inventoryValue = _data["inventoryValue"];
            this.invoiceDetailsId = _data["invoiceDetailsId"];
            this.invCategoryId = _data["invCategoryId"];
            this.invObjectAccountId = _data["invObjectAccountId"];
            this.expenseAccountId = _data["expenseAccountId"];
            this.storageInId = _data["storageInId"];
            this.storageIn = _data["storageIn"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.primDocumentTypeId = _data["primDocumentTypeId"];
            this.primDocumentNr = _data["primDocumentNr"];
            this.primDocumentDate = _data["primDocumentDate"] ? moment(_data["primDocumentDate"].toString()) : <any>undefined;
            this.thirdPartyId = _data["thirdPartyId"];
        }
    }

    static fromJS(data: any): InvObjectAddDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectAddDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["inventoryNr"] = this.inventoryNr;
        data["quantity"] = this.quantity;
        data["inventoryValue"] = this.inventoryValue;
        data["invoiceDetailsId"] = this.invoiceDetailsId;
        data["invCategoryId"] = this.invCategoryId;
        data["invObjectAccountId"] = this.invObjectAccountId;
        data["expenseAccountId"] = this.expenseAccountId;
        data["storageInId"] = this.storageInId;
        data["storageIn"] = this.storageIn;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["primDocumentTypeId"] = this.primDocumentTypeId;
        data["primDocumentNr"] = this.primDocumentNr;
        data["primDocumentDate"] = this.primDocumentDate ? this.primDocumentDate.toISOString() : <any>undefined;
        data["thirdPartyId"] = this.thirdPartyId;
        return data;
    }

    clone(): InvObjectAddDetailDto {
        const json = this.toJSON();
        let result = new InvObjectAddDetailDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectAddDetailDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;
    quantity: number;
    inventoryValue: number;
    invoiceDetailsId: number | undefined;
    invCategoryId: number | undefined;
    invObjectAccountId: number | undefined;
    expenseAccountId: number | undefined;
    storageInId: number | undefined;
    storageIn: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
}

export class InvObjectAddDto implements IInvObjectAddDto {
    operationDate: moment.Moment;
    documentTypeId: number;
    documentType: string | undefined;
    operationType: InvObjectOperType;
    invoiceId: number | undefined;
    invoiceDetail: InvObjectAddInvoiceDetailDto[] | undefined;
    invObjects: InvObjectAddDetailDto[] | undefined;
    showForm1: boolean;
    showForm2: boolean;
    showForm3: boolean;
    finishAdd: boolean;

    constructor(data?: IInvObjectAddDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.operationType = _data["operationType"];
            this.invoiceId = _data["invoiceId"];
            if (Array.isArray(_data["invoiceDetail"])) {
                this.invoiceDetail = [] as any;
                for (let item of _data["invoiceDetail"])
                    this.invoiceDetail.push(InvObjectAddInvoiceDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["invObjects"])) {
                this.invObjects = [] as any;
                for (let item of _data["invObjects"])
                    this.invObjects.push(InvObjectAddDetailDto.fromJS(item));
            }
            this.showForm1 = _data["showForm1"];
            this.showForm2 = _data["showForm2"];
            this.showForm3 = _data["showForm3"];
            this.finishAdd = _data["finishAdd"];
        }
    }

    static fromJS(data: any): InvObjectAddDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectAddDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["operationType"] = this.operationType;
        data["invoiceId"] = this.invoiceId;
        if (Array.isArray(this.invoiceDetail)) {
            data["invoiceDetail"] = [];
            for (let item of this.invoiceDetail)
                data["invoiceDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.invObjects)) {
            data["invObjects"] = [];
            for (let item of this.invObjects)
                data["invObjects"].push(item.toJSON());
        }
        data["showForm1"] = this.showForm1;
        data["showForm2"] = this.showForm2;
        data["showForm3"] = this.showForm3;
        data["finishAdd"] = this.finishAdd;
        return data;
    }

    clone(): InvObjectAddDto {
        const json = this.toJSON();
        let result = new InvObjectAddDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectAddDto {
    operationDate: moment.Moment;
    documentTypeId: number;
    documentType: string | undefined;
    operationType: InvObjectOperType;
    invoiceId: number | undefined;
    invoiceDetail: InvObjectAddInvoiceDetailDto[] | undefined;
    invObjects: InvObjectAddDetailDto[] | undefined;
    showForm1: boolean;
    showForm2: boolean;
    showForm3: boolean;
    finishAdd: boolean;
}

export class InvObjectAddDirectDto implements IInvObjectAddDirectDto {
    id: number;
    operationDate: moment.Moment;
    documentTypeId: number;
    documentType: string | undefined;
    operationType: InvObjectOperType;
    invoiceId: number | undefined;
    finishAdd: boolean;
    name: string | undefined;
    inventoryNr: number;
    quantity: number;
    inventoryValue: number;
    invoiceDetailsId: number | undefined;
    invCategoryId: number | undefined;
    invAccountId: number | undefined;
    expenseAccountId: number | undefined;
    storageInId: number | undefined;
    storageIn: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    processed: boolean;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
    thirdPartyName: string | undefined;

    constructor(data?: IInvObjectAddDirectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.operationType = _data["operationType"];
            this.invoiceId = _data["invoiceId"];
            this.finishAdd = _data["finishAdd"];
            this.name = _data["name"];
            this.inventoryNr = _data["inventoryNr"];
            this.quantity = _data["quantity"];
            this.inventoryValue = _data["inventoryValue"];
            this.invoiceDetailsId = _data["invoiceDetailsId"];
            this.invCategoryId = _data["invCategoryId"];
            this.invAccountId = _data["invAccountId"];
            this.expenseAccountId = _data["expenseAccountId"];
            this.storageInId = _data["storageInId"];
            this.storageIn = _data["storageIn"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.processed = _data["processed"];
            this.primDocumentTypeId = _data["primDocumentTypeId"];
            this.primDocumentNr = _data["primDocumentNr"];
            this.primDocumentDate = _data["primDocumentDate"] ? moment(_data["primDocumentDate"].toString()) : <any>undefined;
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdPartyName = _data["thirdPartyName"];
        }
    }

    static fromJS(data: any): InvObjectAddDirectDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectAddDirectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["operationType"] = this.operationType;
        data["invoiceId"] = this.invoiceId;
        data["finishAdd"] = this.finishAdd;
        data["name"] = this.name;
        data["inventoryNr"] = this.inventoryNr;
        data["quantity"] = this.quantity;
        data["inventoryValue"] = this.inventoryValue;
        data["invoiceDetailsId"] = this.invoiceDetailsId;
        data["invCategoryId"] = this.invCategoryId;
        data["invAccountId"] = this.invAccountId;
        data["expenseAccountId"] = this.expenseAccountId;
        data["storageInId"] = this.storageInId;
        data["storageIn"] = this.storageIn;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["processed"] = this.processed;
        data["primDocumentTypeId"] = this.primDocumentTypeId;
        data["primDocumentNr"] = this.primDocumentNr;
        data["primDocumentDate"] = this.primDocumentDate ? this.primDocumentDate.toISOString() : <any>undefined;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdPartyName"] = this.thirdPartyName;
        return data;
    }

    clone(): InvObjectAddDirectDto {
        const json = this.toJSON();
        let result = new InvObjectAddDirectDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectAddDirectDto {
    id: number;
    operationDate: moment.Moment;
    documentTypeId: number;
    documentType: string | undefined;
    operationType: InvObjectOperType;
    invoiceId: number | undefined;
    finishAdd: boolean;
    name: string | undefined;
    inventoryNr: number;
    quantity: number;
    inventoryValue: number;
    invoiceDetailsId: number | undefined;
    invCategoryId: number | undefined;
    invAccountId: number | undefined;
    expenseAccountId: number | undefined;
    storageInId: number | undefined;
    storageIn: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    processed: boolean;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
    thirdPartyName: string | undefined;
}

export class InvObjectCategoryListDto implements IInvObjectCategoryListDto {
    id: number;
    categoryName: string | undefined;

    constructor(data?: IInvObjectCategoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryName = _data["categoryName"];
        }
    }

    static fromJS(data: any): InvObjectCategoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectCategoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryName"] = this.categoryName;
        return data;
    }

    clone(): InvObjectCategoryListDto {
        const json = this.toJSON();
        let result = new InvObjectCategoryListDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectCategoryListDto {
    id: number;
    categoryName: string | undefined;
}

export class GetInvCategoryOutput implements IGetInvCategoryOutput {
    getCategoryList: InvObjectCategoryListDto[] | undefined;

    constructor(data?: IGetInvCategoryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getCategoryList"])) {
                this.getCategoryList = [] as any;
                for (let item of _data["getCategoryList"])
                    this.getCategoryList.push(InvObjectCategoryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInvCategoryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvCategoryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getCategoryList)) {
            data["getCategoryList"] = [];
            for (let item of this.getCategoryList)
                data["getCategoryList"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetInvCategoryOutput {
        const json = this.toJSON();
        let result = new GetInvCategoryOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInvCategoryOutput {
    getCategoryList: InvObjectCategoryListDto[] | undefined;
}

export class InvObjectCategoryEditDto implements IInvObjectCategoryEditDto {
    id: number;
    categoryName: string | undefined;
    state: State;
    tenantId: number;

    constructor(data?: IInvObjectCategoryEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryName = _data["categoryName"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): InvObjectCategoryEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectCategoryEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryName"] = this.categoryName;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): InvObjectCategoryEditDto {
        const json = this.toJSON();
        let result = new InvObjectCategoryEditDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectCategoryEditDto {
    id: number;
    categoryName: string | undefined;
    state: State;
    tenantId: number;
}

export class InvObjectGestReserveDto implements IInvObjectGestReserveDto {
    invObjectStockId: number;
    operationDate: string | undefined;
    tranzDeprecReserve: number;
    deprecReserve: number;
    tranzReserve: number;
    reserve: number;
    expenseReserve: number;

    constructor(data?: IInvObjectGestReserveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invObjectStockId = _data["invObjectStockId"];
            this.operationDate = _data["operationDate"];
            this.tranzDeprecReserve = _data["tranzDeprecReserve"];
            this.deprecReserve = _data["deprecReserve"];
            this.tranzReserve = _data["tranzReserve"];
            this.reserve = _data["reserve"];
            this.expenseReserve = _data["expenseReserve"];
        }
    }

    static fromJS(data: any): InvObjectGestReserveDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectGestReserveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invObjectStockId"] = this.invObjectStockId;
        data["operationDate"] = this.operationDate;
        data["tranzDeprecReserve"] = this.tranzDeprecReserve;
        data["deprecReserve"] = this.deprecReserve;
        data["tranzReserve"] = this.tranzReserve;
        data["reserve"] = this.reserve;
        data["expenseReserve"] = this.expenseReserve;
        return data;
    }

    clone(): InvObjectGestReserveDto {
        const json = this.toJSON();
        let result = new InvObjectGestReserveDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectGestReserveDto {
    invObjectStockId: number;
    operationDate: string | undefined;
    tranzDeprecReserve: number;
    deprecReserve: number;
    tranzReserve: number;
    reserve: number;
    expenseReserve: number;
}

export class InvObjectGestDetailListDto implements IInvObjectGestDetailListDto {
    id: number;
    invObjectItem: string | undefined;
    stockDate: moment.Moment;
    stockDateStr: string | undefined;
    operType: string | undefined;
    tranzQuantity: number;
    quantity: number;
    tranzDuration: number;
    duration: number;
    storage: string | undefined;
    tranzInventoryValue: number;
    inventoryValue: number;
    tranzFiscalInventoryValue: number;
    fiscalInventoryValue: number;
    tranzDeprec: number;
    deprec: number;
    tranzFiscalDeprec: number;
    fiscalDeprec: number;
    reserveDetail: InvObjectGestReserveDto[] | undefined;
    showReserve: boolean;

    constructor(data?: IInvObjectGestDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invObjectItem = _data["invObjectItem"];
            this.stockDate = _data["stockDate"] ? moment(_data["stockDate"].toString()) : <any>undefined;
            this.stockDateStr = _data["stockDateStr"];
            this.operType = _data["operType"];
            this.tranzQuantity = _data["tranzQuantity"];
            this.quantity = _data["quantity"];
            this.tranzDuration = _data["tranzDuration"];
            this.duration = _data["duration"];
            this.storage = _data["storage"];
            this.tranzInventoryValue = _data["tranzInventoryValue"];
            this.inventoryValue = _data["inventoryValue"];
            this.tranzFiscalInventoryValue = _data["tranzFiscalInventoryValue"];
            this.fiscalInventoryValue = _data["fiscalInventoryValue"];
            this.tranzDeprec = _data["tranzDeprec"];
            this.deprec = _data["deprec"];
            this.tranzFiscalDeprec = _data["tranzFiscalDeprec"];
            this.fiscalDeprec = _data["fiscalDeprec"];
            if (Array.isArray(_data["reserveDetail"])) {
                this.reserveDetail = [] as any;
                for (let item of _data["reserveDetail"])
                    this.reserveDetail.push(InvObjectGestReserveDto.fromJS(item));
            }
            this.showReserve = _data["showReserve"];
        }
    }

    static fromJS(data: any): InvObjectGestDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectGestDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invObjectItem"] = this.invObjectItem;
        data["stockDate"] = this.stockDate ? this.stockDate.toISOString() : <any>undefined;
        data["stockDateStr"] = this.stockDateStr;
        data["operType"] = this.operType;
        data["tranzQuantity"] = this.tranzQuantity;
        data["quantity"] = this.quantity;
        data["tranzDuration"] = this.tranzDuration;
        data["duration"] = this.duration;
        data["storage"] = this.storage;
        data["tranzInventoryValue"] = this.tranzInventoryValue;
        data["inventoryValue"] = this.inventoryValue;
        data["tranzFiscalInventoryValue"] = this.tranzFiscalInventoryValue;
        data["fiscalInventoryValue"] = this.fiscalInventoryValue;
        data["tranzDeprec"] = this.tranzDeprec;
        data["deprec"] = this.deprec;
        data["tranzFiscalDeprec"] = this.tranzFiscalDeprec;
        data["fiscalDeprec"] = this.fiscalDeprec;
        if (Array.isArray(this.reserveDetail)) {
            data["reserveDetail"] = [];
            for (let item of this.reserveDetail)
                data["reserveDetail"].push(item.toJSON());
        }
        data["showReserve"] = this.showReserve;
        return data;
    }

    clone(): InvObjectGestDetailListDto {
        const json = this.toJSON();
        let result = new InvObjectGestDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectGestDetailListDto {
    id: number;
    invObjectItem: string | undefined;
    stockDate: moment.Moment;
    stockDateStr: string | undefined;
    operType: string | undefined;
    tranzQuantity: number;
    quantity: number;
    tranzDuration: number;
    duration: number;
    storage: string | undefined;
    tranzInventoryValue: number;
    inventoryValue: number;
    tranzFiscalInventoryValue: number;
    fiscalInventoryValue: number;
    tranzDeprec: number;
    deprec: number;
    tranzFiscalDeprec: number;
    fiscalDeprec: number;
    reserveDetail: InvObjectGestReserveDto[] | undefined;
    showReserve: boolean;
}

export class InvObjectGestListDto implements IInvObjectGestListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    invObjectId: number | undefined;
    storageId: number | undefined;
    gestDetail: InvObjectGestDetailListDto[] | undefined;

    constructor(data?: IInvObjectGestListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.invObjectId = _data["invObjectId"];
            this.storageId = _data["storageId"];
            if (Array.isArray(_data["gestDetail"])) {
                this.gestDetail = [] as any;
                for (let item of _data["gestDetail"])
                    this.gestDetail.push(InvObjectGestDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvObjectGestListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectGestListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["invObjectId"] = this.invObjectId;
        data["storageId"] = this.storageId;
        if (Array.isArray(this.gestDetail)) {
            data["gestDetail"] = [];
            for (let item of this.gestDetail)
                data["gestDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvObjectGestListDto {
        const json = this.toJSON();
        let result = new InvObjectGestListDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectGestListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    invObjectId: number | undefined;
    storageId: number | undefined;
    gestDetail: InvObjectGestDetailListDto[] | undefined;
}

export class InvObjectStorageDto implements IInvObjectStorageDto {
    id: number;
    storageName: string | undefined;
    centralStorage: boolean;
    tenantId: number;

    constructor(data?: IInvObjectStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storageName = _data["storageName"];
            this.centralStorage = _data["centralStorage"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): InvObjectStorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectStorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storageName"] = this.storageName;
        data["centralStorage"] = this.centralStorage;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): InvObjectStorageDto {
        const json = this.toJSON();
        let result = new InvObjectStorageDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectStorageDto {
    id: number;
    storageName: string | undefined;
    centralStorage: boolean;
    tenantId: number;
}

export class InvObjectOperationListDto implements IInvObjectOperationListDto {
    id: number;
    operationDate: moment.Moment;
    operationDateStr: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    documentDateStr: string | undefined;
    documentType: string | undefined;
    operationType: string | undefined;
    storageOut: string | undefined;
    storageIn: string | undefined;
    ordProcess: number;
    operationDateSort: moment.Moment;

    constructor(data?: IInvObjectOperationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.operationDateStr = _data["operationDateStr"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.documentDateStr = _data["documentDateStr"];
            this.documentType = _data["documentType"];
            this.operationType = _data["operationType"];
            this.storageOut = _data["storageOut"];
            this.storageIn = _data["storageIn"];
            this.ordProcess = _data["ordProcess"];
            this.operationDateSort = _data["operationDateSort"] ? moment(_data["operationDateSort"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InvObjectOperationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectOperationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["operationDateStr"] = this.operationDateStr;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["documentDateStr"] = this.documentDateStr;
        data["documentType"] = this.documentType;
        data["operationType"] = this.operationType;
        data["storageOut"] = this.storageOut;
        data["storageIn"] = this.storageIn;
        data["ordProcess"] = this.ordProcess;
        data["operationDateSort"] = this.operationDateSort ? this.operationDateSort.toISOString() : <any>undefined;
        return data;
    }

    clone(): InvObjectOperationListDto {
        const json = this.toJSON();
        let result = new InvObjectOperationListDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectOperationListDto {
    id: number;
    operationDate: moment.Moment;
    operationDateStr: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    documentDateStr: string | undefined;
    documentType: string | undefined;
    operationType: string | undefined;
    storageOut: string | undefined;
    storageIn: string | undefined;
    ordProcess: number;
    operationDateSort: moment.Moment;
}

export class InvObjectGestComputeListDto implements IInvObjectGestComputeListDto {
    unprocessedDate: moment.Moment;
    computeDate: moment.Moment | undefined;
    showCompute: boolean;
    operationList: InvObjectOperationListDto[] | undefined;

    constructor(data?: IInvObjectGestComputeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unprocessedDate = _data["unprocessedDate"] ? moment(_data["unprocessedDate"].toString()) : <any>undefined;
            this.computeDate = _data["computeDate"] ? moment(_data["computeDate"].toString()) : <any>undefined;
            this.showCompute = _data["showCompute"];
            if (Array.isArray(_data["operationList"])) {
                this.operationList = [] as any;
                for (let item of _data["operationList"])
                    this.operationList.push(InvObjectOperationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvObjectGestComputeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectGestComputeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unprocessedDate"] = this.unprocessedDate ? this.unprocessedDate.toISOString() : <any>undefined;
        data["computeDate"] = this.computeDate ? this.computeDate.toISOString() : <any>undefined;
        data["showCompute"] = this.showCompute;
        if (Array.isArray(this.operationList)) {
            data["operationList"] = [];
            for (let item of this.operationList)
                data["operationList"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvObjectGestComputeListDto {
        const json = this.toJSON();
        let result = new InvObjectGestComputeListDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectGestComputeListDto {
    unprocessedDate: moment.Moment;
    computeDate: moment.Moment | undefined;
    showCompute: boolean;
    operationList: InvObjectOperationListDto[] | undefined;
}

export class InvObjectGestDelDetailDto implements IInvObjectGestDelDetailDto {
    dateGest: moment.Moment;

    constructor(data?: IInvObjectGestDelDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateGest = _data["dateGest"] ? moment(_data["dateGest"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InvObjectGestDelDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectGestDelDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateGest"] = this.dateGest ? this.dateGest.toISOString() : <any>undefined;
        return data;
    }

    clone(): InvObjectGestDelDetailDto {
        const json = this.toJSON();
        let result = new InvObjectGestDelDetailDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectGestDelDetailDto {
    dateGest: moment.Moment;
}

export class InvObjectDelListDto implements IInvObjectDelListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    gestDelDetail: InvObjectGestDelDetailDto[] | undefined;

    constructor(data?: IInvObjectDelListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            if (Array.isArray(_data["gestDelDetail"])) {
                this.gestDelDetail = [] as any;
                for (let item of _data["gestDelDetail"])
                    this.gestDelDetail.push(InvObjectGestDelDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvObjectDelListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectDelListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        if (Array.isArray(this.gestDelDetail)) {
            data["gestDelDetail"] = [];
            for (let item of this.gestDelDetail)
                data["gestDelDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvObjectDelListDto {
        const json = this.toJSON();
        let result = new InvObjectDelListDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectDelListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    gestDelDetail: InvObjectGestDelDetailDto[] | undefined;
}

export class InvObjectInventariereDetDto implements IInvObjectInventariereDetDto {
    id: number;
    invObjectInventariereId: number;
    description: string | undefined;
    operationDate: moment.Moment;
    inventoryNumber: number;
    inventoryValue: number;
    stockScriptic: number;
    stockFaptic: number;
    invObjectStockId: number;
    invObjectItemId: number;
    storageInId: number | undefined;
    storageIn: string | undefined;
    tenantId: number;

    constructor(data?: IInvObjectInventariereDetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invObjectInventariereId = _data["invObjectInventariereId"];
            this.description = _data["description"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.inventoryNumber = _data["inventoryNumber"];
            this.inventoryValue = _data["inventoryValue"];
            this.stockScriptic = _data["stockScriptic"];
            this.stockFaptic = _data["stockFaptic"];
            this.invObjectStockId = _data["invObjectStockId"];
            this.invObjectItemId = _data["invObjectItemId"];
            this.storageInId = _data["storageInId"];
            this.storageIn = _data["storageIn"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): InvObjectInventariereDetDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectInventariereDetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invObjectInventariereId"] = this.invObjectInventariereId;
        data["description"] = this.description;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["inventoryNumber"] = this.inventoryNumber;
        data["inventoryValue"] = this.inventoryValue;
        data["stockScriptic"] = this.stockScriptic;
        data["stockFaptic"] = this.stockFaptic;
        data["invObjectStockId"] = this.invObjectStockId;
        data["invObjectItemId"] = this.invObjectItemId;
        data["storageInId"] = this.storageInId;
        data["storageIn"] = this.storageIn;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): InvObjectInventariereDetDto {
        const json = this.toJSON();
        let result = new InvObjectInventariereDetDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectInventariereDetDto {
    id: number;
    invObjectInventariereId: number;
    description: string | undefined;
    operationDate: moment.Moment;
    inventoryNumber: number;
    inventoryValue: number;
    stockScriptic: number;
    stockFaptic: number;
    invObjectStockId: number;
    invObjectItemId: number;
    storageInId: number | undefined;
    storageIn: string | undefined;
    tenantId: number;
}

export class InvObjectInventariereEditDto implements IInvObjectInventariereEditDto {
    id: number;
    dataInventariere: moment.Moment;
    invObjectInventariereDetails: InvObjectInventariereDetDto[] | undefined;
    tenantId: number;

    constructor(data?: IInvObjectInventariereEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataInventariere = _data["dataInventariere"] ? moment(_data["dataInventariere"].toString()) : <any>undefined;
            if (Array.isArray(_data["invObjectInventariereDetails"])) {
                this.invObjectInventariereDetails = [] as any;
                for (let item of _data["invObjectInventariereDetails"])
                    this.invObjectInventariereDetails.push(InvObjectInventariereDetDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): InvObjectInventariereEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectInventariereEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataInventariere"] = this.dataInventariere ? this.dataInventariere.toISOString() : <any>undefined;
        if (Array.isArray(this.invObjectInventariereDetails)) {
            data["invObjectInventariereDetails"] = [];
            for (let item of this.invObjectInventariereDetails)
                data["invObjectInventariereDetails"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): InvObjectInventariereEditDto {
        const json = this.toJSON();
        let result = new InvObjectInventariereEditDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectInventariereEditDto {
    id: number;
    dataInventariere: moment.Moment;
    invObjectInventariereDetails: InvObjectInventariereDetDto[] | undefined;
    tenantId: number;
}

export class InvObjectInventariereListDto implements IInvObjectInventariereListDto {
    id: number;
    dataInventariere: moment.Moment;
    state: State;
    tenantId: number;

    constructor(data?: IInvObjectInventariereListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataInventariere = _data["dataInventariere"] ? moment(_data["dataInventariere"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): InvObjectInventariereListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectInventariereListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataInventariere"] = this.dataInventariere ? this.dataInventariere.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): InvObjectInventariereListDto {
        const json = this.toJSON();
        let result = new InvObjectInventariereListDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectInventariereListDto {
    id: number;
    dataInventariere: moment.Moment;
    state: State;
    tenantId: number;
}

export class InvObjectInventariereInitDto implements IInvObjectInventariereInitDto {
    dateStart: moment.Moment;
    dateEnd: moment.Moment;
    invObjectInventariereList: InvObjectInventariereListDto[] | undefined;

    constructor(data?: IInvObjectInventariereInitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateStart = _data["dateStart"] ? moment(_data["dateStart"].toString()) : <any>undefined;
            this.dateEnd = _data["dateEnd"] ? moment(_data["dateEnd"].toString()) : <any>undefined;
            if (Array.isArray(_data["invObjectInventariereList"])) {
                this.invObjectInventariereList = [] as any;
                for (let item of _data["invObjectInventariereList"])
                    this.invObjectInventariereList.push(InvObjectInventariereListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvObjectInventariereInitDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectInventariereInitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        data["dateEnd"] = this.dateEnd ? this.dateEnd.toISOString() : <any>undefined;
        if (Array.isArray(this.invObjectInventariereList)) {
            data["invObjectInventariereList"] = [];
            for (let item of this.invObjectInventariereList)
                data["invObjectInventariereList"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvObjectInventariereInitDto {
        const json = this.toJSON();
        let result = new InvObjectInventariereInitDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectInventariereInitDto {
    dateStart: moment.Moment;
    dateEnd: moment.Moment;
    invObjectInventariereList: InvObjectInventariereListDto[] | undefined;
}

export class InvObjectOperListDetailDto implements IInvObjectOperListDetailDto {
    id: number;
    operationType: string | undefined;
    operationTypeId: number;
    operationDate: moment.Moment;
    documentType: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    processed: boolean;
    readonly showReportBtn: boolean;

    constructor(data?: IInvObjectOperListDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationType = _data["operationType"];
            this.operationTypeId = _data["operationTypeId"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentType = _data["documentType"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.processed = _data["processed"];
            (<any>this).showReportBtn = _data["showReportBtn"];
        }
    }

    static fromJS(data: any): InvObjectOperListDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectOperListDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationType"] = this.operationType;
        data["operationTypeId"] = this.operationTypeId;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentType"] = this.documentType;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["processed"] = this.processed;
        data["showReportBtn"] = this.showReportBtn;
        return data;
    }

    clone(): InvObjectOperListDetailDto {
        const json = this.toJSON();
        let result = new InvObjectOperListDetailDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectOperListDetailDto {
    id: number;
    operationType: string | undefined;
    operationTypeId: number;
    operationDate: moment.Moment;
    documentType: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    processed: boolean;
    showReportBtn: boolean;
}

export class InvObjectOperListDto implements IInvObjectOperListDto {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    listDetail: InvObjectOperListDetailDto[] | undefined;

    constructor(data?: IInvObjectOperListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            if (Array.isArray(_data["listDetail"])) {
                this.listDetail = [] as any;
                for (let item of _data["listDetail"])
                    this.listDetail.push(InvObjectOperListDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvObjectOperListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectOperListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        if (Array.isArray(this.listDetail)) {
            data["listDetail"] = [];
            for (let item of this.listDetail)
                data["listDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvObjectOperListDto {
        const json = this.toJSON();
        let result = new InvObjectOperListDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectOperListDto {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    listDetail: InvObjectOperListDetailDto[] | undefined;
}

export class InvObjectOperDetailEditDto implements IInvObjectOperDetailEditDto {
    id: number;
    invObjectItemId: number | undefined;
    selectedInvObjectItemId: number;
    selectedInvObjectItem: string | undefined;
    isSelectedInvObjectItem: boolean;
    invObjectItem: string | undefined;
    quantity: number;
    invValueOld: number;
    fiscalValueOld: number;
    invValueModif: number;
    idOrd: number;
    invoiceDetailId: number | undefined;

    constructor(data?: IInvObjectOperDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invObjectItemId = _data["invObjectItemId"];
            this.selectedInvObjectItemId = _data["selectedInvObjectItemId"];
            this.selectedInvObjectItem = _data["selectedInvObjectItem"];
            this.isSelectedInvObjectItem = _data["isSelectedInvObjectItem"];
            this.invObjectItem = _data["invObjectItem"];
            this.quantity = _data["quantity"];
            this.invValueOld = _data["invValueOld"];
            this.fiscalValueOld = _data["fiscalValueOld"];
            this.invValueModif = _data["invValueModif"];
            this.idOrd = _data["idOrd"];
            this.invoiceDetailId = _data["invoiceDetailId"];
        }
    }

    static fromJS(data: any): InvObjectOperDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectOperDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invObjectItemId"] = this.invObjectItemId;
        data["selectedInvObjectItemId"] = this.selectedInvObjectItemId;
        data["selectedInvObjectItem"] = this.selectedInvObjectItem;
        data["isSelectedInvObjectItem"] = this.isSelectedInvObjectItem;
        data["invObjectItem"] = this.invObjectItem;
        data["quantity"] = this.quantity;
        data["invValueOld"] = this.invValueOld;
        data["fiscalValueOld"] = this.fiscalValueOld;
        data["invValueModif"] = this.invValueModif;
        data["idOrd"] = this.idOrd;
        data["invoiceDetailId"] = this.invoiceDetailId;
        return data;
    }

    clone(): InvObjectOperDetailEditDto {
        const json = this.toJSON();
        let result = new InvObjectOperDetailEditDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectOperDetailEditDto {
    id: number;
    invObjectItemId: number | undefined;
    selectedInvObjectItemId: number;
    selectedInvObjectItem: string | undefined;
    isSelectedInvObjectItem: boolean;
    invObjectItem: string | undefined;
    quantity: number;
    invValueOld: number;
    fiscalValueOld: number;
    invValueModif: number;
    idOrd: number;
    invoiceDetailId: number | undefined;
}

export class InvObjectOperEditDto implements IInvObjectOperEditDto {
    id: number;
    operationTypeId: number | undefined;
    operationType: string | undefined;
    operationDate: moment.Moment;
    operationDateStr: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    documentDateStr: string | undefined;
    documentTypeId: number | undefined;
    documentType: string | undefined;
    invObjectOperType: InvObjectOperType;
    invObjectsStoreInId: number | undefined;
    invObjectsStoreIn: string | undefined;
    invObjectsStoreOutId: number | undefined;
    invObjectsStoreOut: string | undefined;
    personStoreInId: number | undefined;
    personStoreInName: string | undefined;
    personStoreOutId: number | undefined;
    personStoreOutName: string | undefined;
    invoiceId: number | undefined;
    showForm1: boolean;
    showForm2: boolean;
    showForm3: boolean;
    finishAdd: boolean;
    showStorage: boolean;
    showValues: boolean;
    showModifValues: boolean;
    details: InvObjectOperDetailEditDto[] | undefined;

    constructor(data?: IInvObjectOperEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationTypeId = _data["operationTypeId"];
            this.operationType = _data["operationType"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.operationDateStr = _data["operationDateStr"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.documentDateStr = _data["documentDateStr"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.invObjectOperType = _data["invObjectOperType"];
            this.invObjectsStoreInId = _data["invObjectsStoreInId"];
            this.invObjectsStoreIn = _data["invObjectsStoreIn"];
            this.invObjectsStoreOutId = _data["invObjectsStoreOutId"];
            this.invObjectsStoreOut = _data["invObjectsStoreOut"];
            this.personStoreInId = _data["personStoreInId"];
            this.personStoreInName = _data["personStoreInName"];
            this.personStoreOutId = _data["personStoreOutId"];
            this.personStoreOutName = _data["personStoreOutName"];
            this.invoiceId = _data["invoiceId"];
            this.showForm1 = _data["showForm1"];
            this.showForm2 = _data["showForm2"];
            this.showForm3 = _data["showForm3"];
            this.finishAdd = _data["finishAdd"];
            this.showStorage = _data["showStorage"];
            this.showValues = _data["showValues"];
            this.showModifValues = _data["showModifValues"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(InvObjectOperDetailEditDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvObjectOperEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectOperEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationTypeId"] = this.operationTypeId;
        data["operationType"] = this.operationType;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["operationDateStr"] = this.operationDateStr;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["documentDateStr"] = this.documentDateStr;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["invObjectOperType"] = this.invObjectOperType;
        data["invObjectsStoreInId"] = this.invObjectsStoreInId;
        data["invObjectsStoreIn"] = this.invObjectsStoreIn;
        data["invObjectsStoreOutId"] = this.invObjectsStoreOutId;
        data["invObjectsStoreOut"] = this.invObjectsStoreOut;
        data["personStoreInId"] = this.personStoreInId;
        data["personStoreInName"] = this.personStoreInName;
        data["personStoreOutId"] = this.personStoreOutId;
        data["personStoreOutName"] = this.personStoreOutName;
        data["invoiceId"] = this.invoiceId;
        data["showForm1"] = this.showForm1;
        data["showForm2"] = this.showForm2;
        data["showForm3"] = this.showForm3;
        data["finishAdd"] = this.finishAdd;
        data["showStorage"] = this.showStorage;
        data["showValues"] = this.showValues;
        data["showModifValues"] = this.showModifValues;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvObjectOperEditDto {
        const json = this.toJSON();
        let result = new InvObjectOperEditDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectOperEditDto {
    id: number;
    operationTypeId: number | undefined;
    operationType: string | undefined;
    operationDate: moment.Moment;
    operationDateStr: string | undefined;
    documentNr: number;
    documentDate: moment.Moment;
    documentDateStr: string | undefined;
    documentTypeId: number | undefined;
    documentType: string | undefined;
    invObjectOperType: InvObjectOperType;
    invObjectsStoreInId: number | undefined;
    invObjectsStoreIn: string | undefined;
    invObjectsStoreOutId: number | undefined;
    invObjectsStoreOut: string | undefined;
    personStoreInId: number | undefined;
    personStoreInName: string | undefined;
    personStoreOutId: number | undefined;
    personStoreOutName: string | undefined;
    invoiceId: number | undefined;
    showForm1: boolean;
    showForm2: boolean;
    showForm3: boolean;
    finishAdd: boolean;
    showStorage: boolean;
    showValues: boolean;
    showModifValues: boolean;
    details: InvObjectOperDetailEditDto[] | undefined;
}

export class InvObjectsDto implements IInvObjectsDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;

    constructor(data?: IInvObjectsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.inventoryNr = _data["inventoryNr"];
        }
    }

    static fromJS(data: any): InvObjectsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["inventoryNr"] = this.inventoryNr;
        return data;
    }

    clone(): InvObjectsDto {
        const json = this.toJSON();
        let result = new InvObjectsDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectsDto {
    id: number;
    name: string | undefined;
    inventoryNr: number;
}

export class InvObjectOperDocTypeEditDto implements IInvObjectOperDocTypeEditDto {
    id: number;
    operTypeId: number;
    documentTypeId: number;
    appOperation: boolean;

    constructor(data?: IInvObjectOperDocTypeEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operTypeId = _data["operTypeId"];
            this.documentTypeId = _data["documentTypeId"];
            this.appOperation = _data["appOperation"];
        }
    }

    static fromJS(data: any): InvObjectOperDocTypeEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectOperDocTypeEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operTypeId"] = this.operTypeId;
        data["documentTypeId"] = this.documentTypeId;
        data["appOperation"] = this.appOperation;
        return data;
    }

    clone(): InvObjectOperDocTypeEditDto {
        const json = this.toJSON();
        let result = new InvObjectOperDocTypeEditDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectOperDocTypeEditDto {
    id: number;
    operTypeId: number;
    documentTypeId: number;
    appOperation: boolean;
}

export class InvObjectOperDocTypeDto implements IInvObjectOperDocTypeDto {
    id: number;
    operType: string | undefined;
    documentType: string | undefined;
    appOperation: boolean;

    constructor(data?: IInvObjectOperDocTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operType = _data["operType"];
            this.documentType = _data["documentType"];
            this.appOperation = _data["appOperation"];
        }
    }

    static fromJS(data: any): InvObjectOperDocTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectOperDocTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operType"] = this.operType;
        data["documentType"] = this.documentType;
        data["appOperation"] = this.appOperation;
        return data;
    }

    clone(): InvObjectOperDocTypeDto {
        const json = this.toJSON();
        let result = new InvObjectOperDocTypeDto();
        result.init(json);
        return result;
    }
}

export interface IInvObjectOperDocTypeDto {
    id: number;
    operType: string | undefined;
    documentType: string | undefined;
    appOperation: boolean;
}

export class GetInvObjOperDocTypeOutput implements IGetInvObjOperDocTypeOutput {
    getInvObjOperDocType: InvObjectOperDocTypeDto[] | undefined;

    constructor(data?: IGetInvObjOperDocTypeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getInvObjOperDocType"])) {
                this.getInvObjOperDocType = [] as any;
                for (let item of _data["getInvObjOperDocType"])
                    this.getInvObjOperDocType.push(InvObjectOperDocTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInvObjOperDocTypeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvObjOperDocTypeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getInvObjOperDocType)) {
            data["getInvObjOperDocType"] = [];
            for (let item of this.getInvObjOperDocType)
                data["getInvObjOperDocType"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetInvObjOperDocTypeOutput {
        const json = this.toJSON();
        let result = new GetInvObjOperDocTypeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInvObjOperDocTypeOutput {
    getInvObjOperDocType: InvObjectOperDocTypeDto[] | undefined;
}

export class GetInvObjectStorageOutput implements IGetInvObjectStorageOutput {
    getInvObjectStorage: InvObjectStorageDto[] | undefined;

    constructor(data?: IGetInvObjectStorageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getInvObjectStorage"])) {
                this.getInvObjectStorage = [] as any;
                for (let item of _data["getInvObjectStorage"])
                    this.getInvObjectStorage.push(InvObjectStorageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInvObjectStorageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvObjectStorageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getInvObjectStorage)) {
            data["getInvObjectStorage"] = [];
            for (let item of this.getInvObjectStorage)
                data["getInvObjectStorage"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetInvObjectStorageOutput {
        const json = this.toJSON();
        let result = new GetInvObjectStorageOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInvObjectStorageOutput {
    getInvObjectStorage: InvObjectStorageDto[] | undefined;
}

export class ThirdPartyListDDDto implements IThirdPartyListDDDto {
    id: number;
    name: string | undefined;

    constructor(data?: IThirdPartyListDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ThirdPartyListDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThirdPartyListDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ThirdPartyListDDDto {
        const json = this.toJSON();
        let result = new ThirdPartyListDDDto();
        result.init(json);
        return result;
    }
}

export interface IThirdPartyListDDDto {
    id: number;
    name: string | undefined;
}

export class InvoiceElementsDetailsDTO implements IInvoiceElementsDetailsDTO {
    id: number;
    description: string | undefined;
    invoiceElementsType: number;
    invoiceElementsTypeStr: string | undefined;
    thirdPartyAccount: string | undefined;
    correspondentAccount: string | undefined;
    amortizationAccount: string | undefined;
    expenseAmortizAccount: string | undefined;
    state: State;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsCategory: string | undefined;
    readonly showMF: boolean;
    readonly showCA: boolean;

    constructor(data?: IInvoiceElementsDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.invoiceElementsType = _data["invoiceElementsType"];
            this.invoiceElementsTypeStr = _data["invoiceElementsTypeStr"];
            this.thirdPartyAccount = _data["thirdPartyAccount"];
            this.correspondentAccount = _data["correspondentAccount"];
            this.amortizationAccount = _data["amortizationAccount"];
            this.expenseAmortizAccount = _data["expenseAmortizAccount"];
            this.state = _data["state"];
            this.invoiceElementsDetailsCategoryId = _data["invoiceElementsDetailsCategoryId"];
            this.invoiceElementsDetailsCategory = _data["invoiceElementsDetailsCategory"];
            (<any>this).showMF = _data["showMF"];
            (<any>this).showCA = _data["showCA"];
        }
    }

    static fromJS(data: any): InvoiceElementsDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceElementsDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["invoiceElementsType"] = this.invoiceElementsType;
        data["invoiceElementsTypeStr"] = this.invoiceElementsTypeStr;
        data["thirdPartyAccount"] = this.thirdPartyAccount;
        data["correspondentAccount"] = this.correspondentAccount;
        data["amortizationAccount"] = this.amortizationAccount;
        data["expenseAmortizAccount"] = this.expenseAmortizAccount;
        data["state"] = this.state;
        data["invoiceElementsDetailsCategoryId"] = this.invoiceElementsDetailsCategoryId;
        data["invoiceElementsDetailsCategory"] = this.invoiceElementsDetailsCategory;
        data["showMF"] = this.showMF;
        data["showCA"] = this.showCA;
        return data;
    }

    clone(): InvoiceElementsDetailsDTO {
        const json = this.toJSON();
        let result = new InvoiceElementsDetailsDTO();
        result.init(json);
        return result;
    }
}

export interface IInvoiceElementsDetailsDTO {
    id: number;
    description: string | undefined;
    invoiceElementsType: number;
    invoiceElementsTypeStr: string | undefined;
    thirdPartyAccount: string | undefined;
    correspondentAccount: string | undefined;
    amortizationAccount: string | undefined;
    expenseAmortizAccount: string | undefined;
    state: State;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsCategory: string | undefined;
    showMF: boolean;
    showCA: boolean;
}

export enum ItemState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class InvoiceDetailsDTO implements IInvoiceDetailsDTO {
    id: number;
    element: string | undefined;
    quantity: number;
    unitValue: number;
    value: number;
    cotaTVA_Id: number | undefined;
    durationInMonths: number | undefined;
    state: State;
    invoiceElementsDetailsId: number;
    invoiceElementsDetails: InvoiceElementsDetailsDTO;
    itemState: ItemState;
    usedInGest: boolean;
    contaOperationDetailId: number | undefined;
    invoicesId: number;
    valoareTotalaDetaliu: number | undefined;
    dataStartAmortizare: moment.Moment | undefined;

    constructor(data?: IInvoiceDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.element = _data["element"];
            this.quantity = _data["quantity"];
            this.unitValue = _data["unitValue"];
            this.value = _data["value"];
            this.cotaTVA_Id = _data["cotaTVA_Id"];
            this.durationInMonths = _data["durationInMonths"];
            this.state = _data["state"];
            this.invoiceElementsDetailsId = _data["invoiceElementsDetailsId"];
            this.invoiceElementsDetails = _data["invoiceElementsDetails"] ? InvoiceElementsDetailsDTO.fromJS(_data["invoiceElementsDetails"]) : <any>undefined;
            this.itemState = _data["itemState"];
            this.usedInGest = _data["usedInGest"];
            this.contaOperationDetailId = _data["contaOperationDetailId"];
            this.invoicesId = _data["invoicesId"];
            this.valoareTotalaDetaliu = _data["valoareTotalaDetaliu"];
            this.dataStartAmortizare = _data["dataStartAmortizare"] ? moment(_data["dataStartAmortizare"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InvoiceDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["element"] = this.element;
        data["quantity"] = this.quantity;
        data["unitValue"] = this.unitValue;
        data["value"] = this.value;
        data["cotaTVA_Id"] = this.cotaTVA_Id;
        data["durationInMonths"] = this.durationInMonths;
        data["state"] = this.state;
        data["invoiceElementsDetailsId"] = this.invoiceElementsDetailsId;
        data["invoiceElementsDetails"] = this.invoiceElementsDetails ? this.invoiceElementsDetails.toJSON() : <any>undefined;
        data["itemState"] = this.itemState;
        data["usedInGest"] = this.usedInGest;
        data["contaOperationDetailId"] = this.contaOperationDetailId;
        data["invoicesId"] = this.invoicesId;
        data["valoareTotalaDetaliu"] = this.valoareTotalaDetaliu;
        data["dataStartAmortizare"] = this.dataStartAmortizare ? this.dataStartAmortizare.toISOString() : <any>undefined;
        return data;
    }

    clone(): InvoiceDetailsDTO {
        const json = this.toJSON();
        let result = new InvoiceDetailsDTO();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetailsDTO {
    id: number;
    element: string | undefined;
    quantity: number;
    unitValue: number;
    value: number;
    cotaTVA_Id: number | undefined;
    durationInMonths: number | undefined;
    state: State;
    invoiceElementsDetailsId: number;
    invoiceElementsDetails: InvoiceElementsDetailsDTO;
    itemState: ItemState;
    usedInGest: boolean;
    contaOperationDetailId: number | undefined;
    invoicesId: number;
    valoareTotalaDetaliu: number | undefined;
    dataStartAmortizare: moment.Moment | undefined;
}

export class InvoiceDTO implements IInvoiceDTO {
    id: number;
    operationDate: moment.Moment;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    valueLocalCurr: number;
    vatLocalCurr: number;
    dueDate: moment.Moment | undefined;
    description: string | undefined;
    regNumber: string | undefined;
    regDate: moment.Moment | undefined;
    contractNumber: string | undefined;
    thirdPartyId: number | undefined;
    thirdPartyName: string | undefined;
    invoiceDetails: InvoiceDetailsDTO[] | undefined;
    state: State;
    thirdPartyQuality: ThirdPartyQuality;
    thirdPartyQualityStr: string | undefined;
    contaOperationId: number | undefined;
    contaOperationStatus: number;
    currencyId: number;
    currencyName: string | undefined;
    contractsId: number | undefined;
    enableEdit: boolean;
    documentTypeId: number;
    documentType: string | undefined;
    documentTypeShortName: string | undefined;
    startDatePeriod: moment.Moment | undefined;
    endDatePeriod: moment.Moment | undefined;
    activityTypeId: number | undefined;
    decontId: number | undefined;
    hasDecont: boolean;
    restPlata: number;
    fileDocId: number;
    fileDocValue: number;
    decontNumber: number | undefined;
    decontareInLei: boolean;
    cursValutar: number | undefined;
    valoareTotalaFactura: number | undefined;
    monedaFacturaId: number | undefined;
    forcePaid: boolean;
    dataStartAmortizare: moment.Moment | undefined;

    constructor(data?: IInvoiceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceSeries = _data["invoiceSeries"];
            this.value = _data["value"];
            this.valueLocalCurr = _data["valueLocalCurr"];
            this.vatLocalCurr = _data["vatLocalCurr"];
            this.dueDate = _data["dueDate"] ? moment(_data["dueDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.regNumber = _data["regNumber"];
            this.regDate = _data["regDate"] ? moment(_data["regDate"].toString()) : <any>undefined;
            this.contractNumber = _data["contractNumber"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdPartyName = _data["thirdPartyName"];
            if (Array.isArray(_data["invoiceDetails"])) {
                this.invoiceDetails = [] as any;
                for (let item of _data["invoiceDetails"])
                    this.invoiceDetails.push(InvoiceDetailsDTO.fromJS(item));
            }
            this.state = _data["state"];
            this.thirdPartyQuality = _data["thirdPartyQuality"];
            this.thirdPartyQualityStr = _data["thirdPartyQualityStr"];
            this.contaOperationId = _data["contaOperationId"];
            this.contaOperationStatus = _data["contaOperationStatus"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.contractsId = _data["contractsId"];
            this.enableEdit = _data["enableEdit"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.documentTypeShortName = _data["documentTypeShortName"];
            this.startDatePeriod = _data["startDatePeriod"] ? moment(_data["startDatePeriod"].toString()) : <any>undefined;
            this.endDatePeriod = _data["endDatePeriod"] ? moment(_data["endDatePeriod"].toString()) : <any>undefined;
            this.activityTypeId = _data["activityTypeId"];
            this.decontId = _data["decontId"];
            this.hasDecont = _data["hasDecont"];
            this.restPlata = _data["restPlata"];
            this.fileDocId = _data["fileDocId"];
            this.fileDocValue = _data["fileDocValue"];
            this.decontNumber = _data["decontNumber"];
            this.decontareInLei = _data["decontareInLei"];
            this.cursValutar = _data["cursValutar"];
            this.valoareTotalaFactura = _data["valoareTotalaFactura"];
            this.monedaFacturaId = _data["monedaFacturaId"];
            this.forcePaid = _data["forcePaid"];
            this.dataStartAmortizare = _data["dataStartAmortizare"] ? moment(_data["dataStartAmortizare"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InvoiceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceSeries"] = this.invoiceSeries;
        data["value"] = this.value;
        data["valueLocalCurr"] = this.valueLocalCurr;
        data["vatLocalCurr"] = this.vatLocalCurr;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["regNumber"] = this.regNumber;
        data["regDate"] = this.regDate ? this.regDate.toISOString() : <any>undefined;
        data["contractNumber"] = this.contractNumber;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdPartyName"] = this.thirdPartyName;
        if (Array.isArray(this.invoiceDetails)) {
            data["invoiceDetails"] = [];
            for (let item of this.invoiceDetails)
                data["invoiceDetails"].push(item.toJSON());
        }
        data["state"] = this.state;
        data["thirdPartyQuality"] = this.thirdPartyQuality;
        data["thirdPartyQualityStr"] = this.thirdPartyQualityStr;
        data["contaOperationId"] = this.contaOperationId;
        data["contaOperationStatus"] = this.contaOperationStatus;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["contractsId"] = this.contractsId;
        data["enableEdit"] = this.enableEdit;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["documentTypeShortName"] = this.documentTypeShortName;
        data["startDatePeriod"] = this.startDatePeriod ? this.startDatePeriod.toISOString() : <any>undefined;
        data["endDatePeriod"] = this.endDatePeriod ? this.endDatePeriod.toISOString() : <any>undefined;
        data["activityTypeId"] = this.activityTypeId;
        data["decontId"] = this.decontId;
        data["hasDecont"] = this.hasDecont;
        data["restPlata"] = this.restPlata;
        data["fileDocId"] = this.fileDocId;
        data["fileDocValue"] = this.fileDocValue;
        data["decontNumber"] = this.decontNumber;
        data["decontareInLei"] = this.decontareInLei;
        data["cursValutar"] = this.cursValutar;
        data["valoareTotalaFactura"] = this.valoareTotalaFactura;
        data["monedaFacturaId"] = this.monedaFacturaId;
        data["forcePaid"] = this.forcePaid;
        data["dataStartAmortizare"] = this.dataStartAmortizare ? this.dataStartAmortizare.toISOString() : <any>undefined;
        return data;
    }

    clone(): InvoiceDTO {
        const json = this.toJSON();
        let result = new InvoiceDTO();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDTO {
    id: number;
    operationDate: moment.Moment;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    valueLocalCurr: number;
    vatLocalCurr: number;
    dueDate: moment.Moment | undefined;
    description: string | undefined;
    regNumber: string | undefined;
    regDate: moment.Moment | undefined;
    contractNumber: string | undefined;
    thirdPartyId: number | undefined;
    thirdPartyName: string | undefined;
    invoiceDetails: InvoiceDetailsDTO[] | undefined;
    state: State;
    thirdPartyQuality: ThirdPartyQuality;
    thirdPartyQualityStr: string | undefined;
    contaOperationId: number | undefined;
    contaOperationStatus: number;
    currencyId: number;
    currencyName: string | undefined;
    contractsId: number | undefined;
    enableEdit: boolean;
    documentTypeId: number;
    documentType: string | undefined;
    documentTypeShortName: string | undefined;
    startDatePeriod: moment.Moment | undefined;
    endDatePeriod: moment.Moment | undefined;
    activityTypeId: number | undefined;
    decontId: number | undefined;
    hasDecont: boolean;
    restPlata: number;
    fileDocId: number;
    fileDocValue: number;
    decontNumber: number | undefined;
    decontareInLei: boolean;
    cursValutar: number | undefined;
    valoareTotalaFactura: number | undefined;
    monedaFacturaId: number | undefined;
    forcePaid: boolean;
    dataStartAmortizare: moment.Moment | undefined;
}

export enum InvoiceElementAccountType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class InvoiceElementAccountsDTO implements IInvoiceElementAccountsDTO {
    id: number;
    invoiceElementAccountType: InvoiceElementAccountType;
    invoiceElementAccountTypeStr: string | undefined;
    accountId: number;
    accountName: string | undefined;
    state: State;

    constructor(data?: IInvoiceElementAccountsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceElementAccountType = _data["invoiceElementAccountType"];
            this.invoiceElementAccountTypeStr = _data["invoiceElementAccountTypeStr"];
            this.accountId = _data["accountId"];
            this.accountName = _data["accountName"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): InvoiceElementAccountsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceElementAccountsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceElementAccountType"] = this.invoiceElementAccountType;
        data["invoiceElementAccountTypeStr"] = this.invoiceElementAccountTypeStr;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["state"] = this.state;
        return data;
    }

    clone(): InvoiceElementAccountsDTO {
        const json = this.toJSON();
        let result = new InvoiceElementAccountsDTO();
        result.init(json);
        return result;
    }
}

export interface IInvoiceElementAccountsDTO {
    id: number;
    invoiceElementAccountType: InvoiceElementAccountType;
    invoiceElementAccountTypeStr: string | undefined;
    accountId: number;
    accountName: string | undefined;
    state: State;
}

export class InvoiceListDto implements IInvoiceListDto {
    id: number;
    details: string | undefined;
    totalValue: number;
    remainingValue: number;

    constructor(data?: IInvoiceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
            this.totalValue = _data["totalValue"];
            this.remainingValue = _data["remainingValue"];
        }
    }

    static fromJS(data: any): InvoiceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        data["totalValue"] = this.totalValue;
        data["remainingValue"] = this.remainingValue;
        return data;
    }

    clone(): InvoiceListDto {
        const json = this.toJSON();
        let result = new InvoiceListDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceListDto {
    id: number;
    details: string | undefined;
    totalValue: number;
    remainingValue: number;
}

export class InvoiceListForImoAssetDto implements IInvoiceListForImoAssetDto {
    id: number;
    details: string | undefined;
    invValue: number;
    fiscalValue: number;
    duration: number | undefined;

    constructor(data?: IInvoiceListForImoAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
            this.invValue = _data["invValue"];
            this.fiscalValue = _data["fiscalValue"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): InvoiceListForImoAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceListForImoAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        data["invValue"] = this.invValue;
        data["fiscalValue"] = this.fiscalValue;
        data["duration"] = this.duration;
        return data;
    }

    clone(): InvoiceListForImoAssetDto {
        const json = this.toJSON();
        let result = new InvoiceListForImoAssetDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceListForImoAssetDto {
    id: number;
    details: string | undefined;
    invValue: number;
    fiscalValue: number;
    duration: number | undefined;
}

export class InvoiceListForInvObjectDto implements IInvoiceListForInvObjectDto {
    id: number;
    details: string | undefined;
    invValue: number;
    duration: number | undefined;

    constructor(data?: IInvoiceListForInvObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.details = _data["details"];
            this.invValue = _data["invValue"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): InvoiceListForInvObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceListForInvObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["details"] = this.details;
        data["invValue"] = this.invValue;
        data["duration"] = this.duration;
        return data;
    }

    clone(): InvoiceListForInvObjectDto {
        const json = this.toJSON();
        let result = new InvoiceListForInvObjectDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceListForInvObjectDto {
    id: number;
    details: string | undefined;
    invValue: number;
    duration: number | undefined;
}

export class ThirdPartyDTO implements IThirdPartyDTO {
    id: number;
    name: string | undefined;

    constructor(data?: IThirdPartyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ThirdPartyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ThirdPartyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ThirdPartyDTO {
        const json = this.toJSON();
        let result = new ThirdPartyDTO();
        result.init(json);
        return result;
    }
}

export interface IThirdPartyDTO {
    id: number;
    name: string | undefined;
}

export class NirDetailDTO implements INirDetailDTO {
    id: number;
    name: string | undefined;

    constructor(data?: INirDetailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): NirDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NirDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): NirDetailDTO {
        const json = this.toJSON();
        let result = new NirDetailDTO();
        result.init(json);
        return result;
    }
}

export interface INirDetailDTO {
    id: number;
    name: string | undefined;
}

export class GetAssetOutput implements IGetAssetOutput {
    getInvoices: NirDetailDTO[] | undefined;

    constructor(data?: IGetAssetOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getInvoices"])) {
                this.getInvoices = [] as any;
                for (let item of _data["getInvoices"])
                    this.getInvoices.push(NirDetailDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAssetOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getInvoices)) {
            data["getInvoices"] = [];
            for (let item of this.getInvoices)
                data["getInvoices"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAssetOutput {
        const json = this.toJSON();
        let result = new GetAssetOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAssetOutput {
    getInvoices: NirDetailDTO[] | undefined;
}

export class InvoiceElementsDetailsCategoryListDTO implements IInvoiceElementsDetailsCategoryListDTO {
    id: number;
    categoryElementDetName: string | undefined;
    categoryType: string | undefined;
    state: State;

    constructor(data?: IInvoiceElementsDetailsCategoryListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryElementDetName = _data["categoryElementDetName"];
            this.categoryType = _data["categoryType"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): InvoiceElementsDetailsCategoryListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceElementsDetailsCategoryListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryElementDetName"] = this.categoryElementDetName;
        data["categoryType"] = this.categoryType;
        data["state"] = this.state;
        return data;
    }

    clone(): InvoiceElementsDetailsCategoryListDTO {
        const json = this.toJSON();
        let result = new InvoiceElementsDetailsCategoryListDTO();
        result.init(json);
        return result;
    }
}

export interface IInvoiceElementsDetailsCategoryListDTO {
    id: number;
    categoryElementDetName: string | undefined;
    categoryType: string | undefined;
    state: State;
}

export class InvoiceElementsDetailsCategoryEditDTO implements IInvoiceElementsDetailsCategoryEditDTO {
    id: number;
    categoryElementDetName: string | undefined;
    categoryTypeId: number | undefined;
    state: State;

    constructor(data?: IInvoiceElementsDetailsCategoryEditDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryElementDetName = _data["categoryElementDetName"];
            this.categoryTypeId = _data["categoryTypeId"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): InvoiceElementsDetailsCategoryEditDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceElementsDetailsCategoryEditDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryElementDetName"] = this.categoryElementDetName;
        data["categoryTypeId"] = this.categoryTypeId;
        data["state"] = this.state;
        return data;
    }

    clone(): InvoiceElementsDetailsCategoryEditDTO {
        const json = this.toJSON();
        let result = new InvoiceElementsDetailsCategoryEditDTO();
        result.init(json);
        return result;
    }
}

export interface IInvoiceElementsDetailsCategoryEditDTO {
    id: number;
    categoryElementDetName: string | undefined;
    categoryTypeId: number | undefined;
    state: State;
}

export class InvoiceForDecontDTO implements IInvoiceForDecontDTO {
    id: number;
    thirdPartyAccount: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    monedaPlataId: number;
    monedaPlataName: string | undefined;
    selected: boolean;
    fileDocId: number;
    fileDocValue: number;
    state: State;

    constructor(data?: IInvoiceForDecontDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.thirdPartyAccount = _data["thirdPartyAccount"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceSeries = _data["invoiceSeries"];
            this.value = _data["value"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.monedaPlataId = _data["monedaPlataId"];
            this.monedaPlataName = _data["monedaPlataName"];
            this.selected = _data["selected"];
            this.fileDocId = _data["fileDocId"];
            this.fileDocValue = _data["fileDocValue"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): InvoiceForDecontDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceForDecontDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["thirdPartyAccount"] = this.thirdPartyAccount;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceSeries"] = this.invoiceSeries;
        data["value"] = this.value;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["monedaPlataId"] = this.monedaPlataId;
        data["monedaPlataName"] = this.monedaPlataName;
        data["selected"] = this.selected;
        data["fileDocId"] = this.fileDocId;
        data["fileDocValue"] = this.fileDocValue;
        data["state"] = this.state;
        return data;
    }

    clone(): InvoiceForDecontDTO {
        const json = this.toJSON();
        let result = new InvoiceForDecontDTO();
        result.init(json);
        return result;
    }
}

export interface IInvoiceForDecontDTO {
    id: number;
    thirdPartyAccount: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    monedaPlataId: number;
    monedaPlataName: string | undefined;
    selected: boolean;
    fileDocId: number;
    fileDocValue: number;
    state: State;
}

export class AutoInvPInvoices implements IAutoInvPInvoices {
    id: number;
    thirdPartyQualityStr: string | undefined;
    thirdParty: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    vat: number;
    currencyName: string | undefined;
    description: string | undefined;

    constructor(data?: IAutoInvPInvoices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.thirdPartyQualityStr = _data["thirdPartyQualityStr"];
            this.thirdParty = _data["thirdParty"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceSeries = _data["invoiceSeries"];
            this.value = _data["value"];
            this.vat = _data["vat"];
            this.currencyName = _data["currencyName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AutoInvPInvoices {
        data = typeof data === 'object' ? data : {};
        let result = new AutoInvPInvoices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["thirdPartyQualityStr"] = this.thirdPartyQualityStr;
        data["thirdParty"] = this.thirdParty;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceSeries"] = this.invoiceSeries;
        data["value"] = this.value;
        data["vat"] = this.vat;
        data["currencyName"] = this.currencyName;
        data["description"] = this.description;
        return data;
    }

    clone(): AutoInvPInvoices {
        const json = this.toJSON();
        let result = new AutoInvPInvoices();
        result.init(json);
        return result;
    }
}

export interface IAutoInvPInvoices {
    id: number;
    thirdPartyQualityStr: string | undefined;
    thirdParty: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    vat: number;
    currencyName: string | undefined;
    description: string | undefined;
}

export class AutoInvNInvoices implements IAutoInvNInvoices {
    id: number;
    selected: boolean;
    thirdPartyQualityStr: string | undefined;
    thirdParty: string | undefined;
    operationDate: moment.Moment;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    vat: number;
    currencyName: string | undefined;
    description: string | undefined;

    constructor(data?: IAutoInvNInvoices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.selected = _data["selected"];
            this.thirdPartyQualityStr = _data["thirdPartyQualityStr"];
            this.thirdParty = _data["thirdParty"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceSeries = _data["invoiceSeries"];
            this.value = _data["value"];
            this.vat = _data["vat"];
            this.currencyName = _data["currencyName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AutoInvNInvoices {
        data = typeof data === 'object' ? data : {};
        let result = new AutoInvNInvoices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["selected"] = this.selected;
        data["thirdPartyQualityStr"] = this.thirdPartyQualityStr;
        data["thirdParty"] = this.thirdParty;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceSeries"] = this.invoiceSeries;
        data["value"] = this.value;
        data["vat"] = this.vat;
        data["currencyName"] = this.currencyName;
        data["description"] = this.description;
        return data;
    }

    clone(): AutoInvNInvoices {
        const json = this.toJSON();
        let result = new AutoInvNInvoices();
        result.init(json);
        return result;
    }
}

export interface IAutoInvNInvoices {
    id: number;
    selected: boolean;
    thirdPartyQualityStr: string | undefined;
    thirdParty: string | undefined;
    operationDate: moment.Moment;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    vat: number;
    currencyName: string | undefined;
    description: string | undefined;
}

export class AutoInvDInvoices implements IAutoInvDInvoices {
    id: number;
    thirdPartyQualityStr: string | undefined;
    thirdParty: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    vat: number;
    currencyName: string | undefined;
    description: string | undefined;

    constructor(data?: IAutoInvDInvoices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.thirdPartyQualityStr = _data["thirdPartyQualityStr"];
            this.thirdParty = _data["thirdParty"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceSeries = _data["invoiceSeries"];
            this.value = _data["value"];
            this.vat = _data["vat"];
            this.currencyName = _data["currencyName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AutoInvDInvoices {
        data = typeof data === 'object' ? data : {};
        let result = new AutoInvDInvoices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["thirdPartyQualityStr"] = this.thirdPartyQualityStr;
        data["thirdParty"] = this.thirdParty;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceSeries"] = this.invoiceSeries;
        data["value"] = this.value;
        data["vat"] = this.vat;
        data["currencyName"] = this.currencyName;
        data["description"] = this.description;
        return data;
    }

    clone(): AutoInvDInvoices {
        const json = this.toJSON();
        let result = new AutoInvDInvoices();
        result.init(json);
        return result;
    }
}

export interface IAutoInvDInvoices {
    id: number;
    thirdPartyQualityStr: string | undefined;
    thirdParty: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    vat: number;
    currencyName: string | undefined;
    description: string | undefined;
}

export class AutoInvForm implements IAutoInvForm {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    invoices: AutoInvPInvoices[] | undefined;
    notProcessedInvoices: AutoInvNInvoices[] | undefined;
    deletedInvoices: AutoInvDInvoices[] | undefined;
    showProcessedForm: boolean;
    showNotProcessedForm: boolean;
    showDeleteForm: boolean;

    constructor(data?: IAutoInvForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices.push(AutoInvPInvoices.fromJS(item));
            }
            if (Array.isArray(_data["notProcessedInvoices"])) {
                this.notProcessedInvoices = [] as any;
                for (let item of _data["notProcessedInvoices"])
                    this.notProcessedInvoices.push(AutoInvNInvoices.fromJS(item));
            }
            if (Array.isArray(_data["deletedInvoices"])) {
                this.deletedInvoices = [] as any;
                for (let item of _data["deletedInvoices"])
                    this.deletedInvoices.push(AutoInvDInvoices.fromJS(item));
            }
            this.showProcessedForm = _data["showProcessedForm"];
            this.showNotProcessedForm = _data["showNotProcessedForm"];
            this.showDeleteForm = _data["showDeleteForm"];
        }
    }

    static fromJS(data: any): AutoInvForm {
        data = typeof data === 'object' ? data : {};
        let result = new AutoInvForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        if (Array.isArray(this.notProcessedInvoices)) {
            data["notProcessedInvoices"] = [];
            for (let item of this.notProcessedInvoices)
                data["notProcessedInvoices"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedInvoices)) {
            data["deletedInvoices"] = [];
            for (let item of this.deletedInvoices)
                data["deletedInvoices"].push(item.toJSON());
        }
        data["showProcessedForm"] = this.showProcessedForm;
        data["showNotProcessedForm"] = this.showNotProcessedForm;
        data["showDeleteForm"] = this.showDeleteForm;
        return data;
    }

    clone(): AutoInvForm {
        const json = this.toJSON();
        let result = new AutoInvForm();
        result.init(json);
        return result;
    }
}

export interface IAutoInvForm {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    invoices: AutoInvPInvoices[] | undefined;
    notProcessedInvoices: AutoInvNInvoices[] | undefined;
    deletedInvoices: AutoInvDInvoices[] | undefined;
    showProcessedForm: boolean;
    showNotProcessedForm: boolean;
    showDeleteForm: boolean;
}

export class IssuerDto implements IIssuerDto {
    id: number;
    ibanAbrv: string | undefined;
    bic: string | undefined;
    issuerType: number;
    legalPersonId: number;
    tenantId: number;

    constructor(data?: IIssuerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ibanAbrv = _data["ibanAbrv"];
            this.bic = _data["bic"];
            this.issuerType = _data["issuerType"];
            this.legalPersonId = _data["legalPersonId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IssuerDto {
        data = typeof data === 'object' ? data : {};
        let result = new IssuerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ibanAbrv"] = this.ibanAbrv;
        data["bic"] = this.bic;
        data["issuerType"] = this.issuerType;
        data["legalPersonId"] = this.legalPersonId;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IssuerDto {
        const json = this.toJSON();
        let result = new IssuerDto();
        result.init(json);
        return result;
    }
}

export interface IIssuerDto {
    id: number;
    ibanAbrv: string | undefined;
    bic: string | undefined;
    issuerType: number;
    legalPersonId: number;
    tenantId: number;
}

export class IssuerListDto implements IIssuerListDto {
    id: number;
    issuerType: string | undefined;
    id1: string | undefined;
    id2: string | undefined;
    fullName: string | undefined;
    codStatistic: string | undefined;

    constructor(data?: IIssuerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.issuerType = _data["issuerType"];
            this.id1 = _data["id1"];
            this.id2 = _data["id2"];
            this.fullName = _data["fullName"];
            this.codStatistic = _data["codStatistic"];
        }
    }

    static fromJS(data: any): IssuerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new IssuerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["issuerType"] = this.issuerType;
        data["id1"] = this.id1;
        data["id2"] = this.id2;
        data["fullName"] = this.fullName;
        data["codStatistic"] = this.codStatistic;
        return data;
    }

    clone(): IssuerListDto {
        const json = this.toJSON();
        let result = new IssuerListDto();
        result.init(json);
        return result;
    }
}

export interface IIssuerListDto {
    id: number;
    issuerType: string | undefined;
    id1: string | undefined;
    id2: string | undefined;
    fullName: string | undefined;
    codStatistic: string | undefined;
}

export class IssuerDetailsDto implements IIssuerDetailsDto {
    id: number;
    issuerType: IssuerType;
    ibanAbrv: string | undefined;
    bic: string | undefined;
    bnR_SectorId: number | undefined;

    constructor(data?: IIssuerDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.issuerType = _data["issuerType"];
            this.ibanAbrv = _data["ibanAbrv"];
            this.bic = _data["bic"];
            this.bnR_SectorId = _data["bnR_SectorId"];
        }
    }

    static fromJS(data: any): IssuerDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IssuerDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["issuerType"] = this.issuerType;
        data["ibanAbrv"] = this.ibanAbrv;
        data["bic"] = this.bic;
        data["bnR_SectorId"] = this.bnR_SectorId;
        return data;
    }

    clone(): IssuerDetailsDto {
        const json = this.toJSON();
        let result = new IssuerDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IIssuerDetailsDto {
    id: number;
    issuerType: IssuerType;
    ibanAbrv: string | undefined;
    bic: string | undefined;
    bnR_SectorId: number | undefined;
}

export class PersonIssuerEditDto implements IPersonIssuerEditDto {
    id: number;
    id1: string | undefined;
    id2: string | undefined;
    addressStreet: string | undefined;
    addressNo: string | undefined;
    addressBlock: string | undefined;
    addressFloor: string | undefined;
    addressApartment: string | undefined;
    addressZipCode: string | undefined;
    addressLocality: string | undefined;
    definedById: number;
    addressRegionId: number | undefined;
    addressCountryId: number | undefined;
    name: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    personType: string | undefined;
    readonly isNaturalPerson: boolean;
    isVATPayer: boolean;
    startDateVATPayment: moment.Moment | undefined;
    isVATCollector: boolean;
    vatCollectedStartDate: moment.Moment | undefined;
    showForm1: boolean;
    showForm2: boolean;
    showForm3: boolean;
    issuerDetails: IssuerDetailsDto;

    constructor(data?: IPersonIssuerEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.id1 = _data["id1"];
            this.id2 = _data["id2"];
            this.addressStreet = _data["addressStreet"];
            this.addressNo = _data["addressNo"];
            this.addressBlock = _data["addressBlock"];
            this.addressFloor = _data["addressFloor"];
            this.addressApartment = _data["addressApartment"];
            this.addressZipCode = _data["addressZipCode"];
            this.addressLocality = _data["addressLocality"];
            this.definedById = _data["definedById"];
            this.addressRegionId = _data["addressRegionId"];
            this.addressCountryId = _data["addressCountryId"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.personType = _data["personType"];
            (<any>this).isNaturalPerson = _data["isNaturalPerson"];
            this.isVATPayer = _data["isVATPayer"];
            this.startDateVATPayment = _data["startDateVATPayment"] ? moment(_data["startDateVATPayment"].toString()) : <any>undefined;
            this.isVATCollector = _data["isVATCollector"];
            this.vatCollectedStartDate = _data["vatCollectedStartDate"] ? moment(_data["vatCollectedStartDate"].toString()) : <any>undefined;
            this.showForm1 = _data["showForm1"];
            this.showForm2 = _data["showForm2"];
            this.showForm3 = _data["showForm3"];
            this.issuerDetails = _data["issuerDetails"] ? IssuerDetailsDto.fromJS(_data["issuerDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PersonIssuerEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonIssuerEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["id1"] = this.id1;
        data["id2"] = this.id2;
        data["addressStreet"] = this.addressStreet;
        data["addressNo"] = this.addressNo;
        data["addressBlock"] = this.addressBlock;
        data["addressFloor"] = this.addressFloor;
        data["addressApartment"] = this.addressApartment;
        data["addressZipCode"] = this.addressZipCode;
        data["addressLocality"] = this.addressLocality;
        data["definedById"] = this.definedById;
        data["addressRegionId"] = this.addressRegionId;
        data["addressCountryId"] = this.addressCountryId;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["personType"] = this.personType;
        data["isNaturalPerson"] = this.isNaturalPerson;
        data["isVATPayer"] = this.isVATPayer;
        data["startDateVATPayment"] = this.startDateVATPayment ? this.startDateVATPayment.toISOString() : <any>undefined;
        data["isVATCollector"] = this.isVATCollector;
        data["vatCollectedStartDate"] = this.vatCollectedStartDate ? this.vatCollectedStartDate.toISOString() : <any>undefined;
        data["showForm1"] = this.showForm1;
        data["showForm2"] = this.showForm2;
        data["showForm3"] = this.showForm3;
        data["issuerDetails"] = this.issuerDetails ? this.issuerDetails.toJSON() : <any>undefined;
        return data;
    }

    clone(): PersonIssuerEditDto {
        const json = this.toJSON();
        let result = new PersonIssuerEditDto();
        result.init(json);
        return result;
    }
}

export interface IPersonIssuerEditDto {
    id: number;
    id1: string | undefined;
    id2: string | undefined;
    addressStreet: string | undefined;
    addressNo: string | undefined;
    addressBlock: string | undefined;
    addressFloor: string | undefined;
    addressApartment: string | undefined;
    addressZipCode: string | undefined;
    addressLocality: string | undefined;
    definedById: number;
    addressRegionId: number | undefined;
    addressCountryId: number | undefined;
    name: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    personType: string | undefined;
    isNaturalPerson: boolean;
    isVATPayer: boolean;
    startDateVATPayment: moment.Moment | undefined;
    isVATCollector: boolean;
    vatCollectedStartDate: moment.Moment | undefined;
    showForm1: boolean;
    showForm2: boolean;
    showForm3: boolean;
    issuerDetails: IssuerDetailsDto;
}

export class LichidBenziDto implements ILichidBenziDto {
    id: number;
    descriere: string | undefined;
    state: State;
    tenantId: number;

    constructor(data?: ILichidBenziDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descriere = _data["descriere"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): LichidBenziDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichidBenziDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descriere"] = this.descriere;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): LichidBenziDto {
        const json = this.toJSON();
        let result = new LichidBenziDto();
        result.init(json);
        return result;
    }
}

export interface ILichidBenziDto {
    id: number;
    descriere: string | undefined;
    state: State;
    tenantId: number;
}

export class LichidCalcListDetDto implements ILichidCalcListDetDto {
    lichidConfigId: number;
    lichidCalcId: number;
    descriere: string | undefined;
    randTotal: boolean;
    valoareBanda1: number;
    valoareBanda2: number;
    valoareBanda3: number;
    valoareBanda4: number;
    valoareBanda5: number;
    totalActualiz: number;
    totalInit: number;
    tenantId: number;

    constructor(data?: ILichidCalcListDetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lichidConfigId = _data["lichidConfigId"];
            this.lichidCalcId = _data["lichidCalcId"];
            this.descriere = _data["descriere"];
            this.randTotal = _data["randTotal"];
            this.valoareBanda1 = _data["valoareBanda1"];
            this.valoareBanda2 = _data["valoareBanda2"];
            this.valoareBanda3 = _data["valoareBanda3"];
            this.valoareBanda4 = _data["valoareBanda4"];
            this.valoareBanda5 = _data["valoareBanda5"];
            this.totalActualiz = _data["totalActualiz"];
            this.totalInit = _data["totalInit"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): LichidCalcListDetDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichidCalcListDetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichidConfigId"] = this.lichidConfigId;
        data["lichidCalcId"] = this.lichidCalcId;
        data["descriere"] = this.descriere;
        data["randTotal"] = this.randTotal;
        data["valoareBanda1"] = this.valoareBanda1;
        data["valoareBanda2"] = this.valoareBanda2;
        data["valoareBanda3"] = this.valoareBanda3;
        data["valoareBanda4"] = this.valoareBanda4;
        data["valoareBanda5"] = this.valoareBanda5;
        data["totalActualiz"] = this.totalActualiz;
        data["totalInit"] = this.totalInit;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): LichidCalcListDetDto {
        const json = this.toJSON();
        let result = new LichidCalcListDetDto();
        result.init(json);
        return result;
    }
}

export interface ILichidCalcListDetDto {
    lichidConfigId: number;
    lichidCalcId: number;
    descriere: string | undefined;
    randTotal: boolean;
    valoareBanda1: number;
    valoareBanda2: number;
    valoareBanda3: number;
    valoareBanda4: number;
    valoareBanda5: number;
    totalActualiz: number;
    totalInit: number;
    tenantId: number;
}

export class LichidCalcDetDto implements ILichidCalcDetDto {
    lichidCalcId: number;
    descriere: string | undefined;
    valoare: number;

    constructor(data?: ILichidCalcDetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lichidCalcId = _data["lichidCalcId"];
            this.descriere = _data["descriere"];
            this.valoare = _data["valoare"];
        }
    }

    static fromJS(data: any): LichidCalcDetDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichidCalcDetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichidCalcId"] = this.lichidCalcId;
        data["descriere"] = this.descriere;
        data["valoare"] = this.valoare;
        return data;
    }

    clone(): LichidCalcDetDto {
        const json = this.toJSON();
        let result = new LichidCalcDetDto();
        result.init(json);
        return result;
    }
}

export interface ILichidCalcDetDto {
    lichidCalcId: number;
    descriere: string | undefined;
    valoare: number;
}

export class LichidCalcSavedBalancetDto implements ILichidCalcSavedBalancetDto {
    savedBalanceId: number;
    savedBalanceDate: moment.Moment;
    savedBalanceDesc: string | undefined;
    tenantId: number;

    constructor(data?: ILichidCalcSavedBalancetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.savedBalanceId = _data["savedBalanceId"];
            this.savedBalanceDate = _data["savedBalanceDate"] ? moment(_data["savedBalanceDate"].toString()) : <any>undefined;
            this.savedBalanceDesc = _data["savedBalanceDesc"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): LichidCalcSavedBalancetDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichidCalcSavedBalancetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["savedBalanceId"] = this.savedBalanceId;
        data["savedBalanceDate"] = this.savedBalanceDate ? this.savedBalanceDate.toISOString() : <any>undefined;
        data["savedBalanceDesc"] = this.savedBalanceDesc;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): LichidCalcSavedBalancetDto {
        const json = this.toJSON();
        let result = new LichidCalcSavedBalancetDto();
        result.init(json);
        return result;
    }
}

export interface ILichidCalcSavedBalancetDto {
    savedBalanceId: number;
    savedBalanceDate: moment.Moment;
    savedBalanceDesc: string | undefined;
    tenantId: number;
}

export class LichidCalcInitDto implements ILichidCalcInitDto {
    lichidCalcSavedBalanceList: LichidCalcSavedBalancetDto[] | undefined;
    showLichidType: boolean;
    showDetails: boolean;
    showLichidCalcSavedBalanceList: boolean;
    showLichidCalcCurrList: boolean;
    showLichidCalcList: boolean;
    tenantId: number;

    constructor(data?: ILichidCalcInitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lichidCalcSavedBalanceList"])) {
                this.lichidCalcSavedBalanceList = [] as any;
                for (let item of _data["lichidCalcSavedBalanceList"])
                    this.lichidCalcSavedBalanceList.push(LichidCalcSavedBalancetDto.fromJS(item));
            }
            this.showLichidType = _data["showLichidType"];
            this.showDetails = _data["showDetails"];
            this.showLichidCalcSavedBalanceList = _data["showLichidCalcSavedBalanceList"];
            this.showLichidCalcCurrList = _data["showLichidCalcCurrList"];
            this.showLichidCalcList = _data["showLichidCalcList"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): LichidCalcInitDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichidCalcInitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lichidCalcSavedBalanceList)) {
            data["lichidCalcSavedBalanceList"] = [];
            for (let item of this.lichidCalcSavedBalanceList)
                data["lichidCalcSavedBalanceList"].push(item.toJSON());
        }
        data["showLichidType"] = this.showLichidType;
        data["showDetails"] = this.showDetails;
        data["showLichidCalcSavedBalanceList"] = this.showLichidCalcSavedBalanceList;
        data["showLichidCalcCurrList"] = this.showLichidCalcCurrList;
        data["showLichidCalcList"] = this.showLichidCalcList;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): LichidCalcInitDto {
        const json = this.toJSON();
        let result = new LichidCalcInitDto();
        result.init(json);
        return result;
    }
}

export interface ILichidCalcInitDto {
    lichidCalcSavedBalanceList: LichidCalcSavedBalancetDto[] | undefined;
    showLichidType: boolean;
    showDetails: boolean;
    showLichidCalcSavedBalanceList: boolean;
    showLichidCalcCurrList: boolean;
    showLichidCalcList: boolean;
    tenantId: number;
}

export class LichidCalcCurrDetDto implements ILichidCalcCurrDetDto {
    lichidCalcCurrId: number;
    descriere: string | undefined;
    valoare: number;

    constructor(data?: ILichidCalcCurrDetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lichidCalcCurrId = _data["lichidCalcCurrId"];
            this.descriere = _data["descriere"];
            this.valoare = _data["valoare"];
        }
    }

    static fromJS(data: any): LichidCalcCurrDetDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichidCalcCurrDetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichidCalcCurrId"] = this.lichidCalcCurrId;
        data["descriere"] = this.descriere;
        data["valoare"] = this.valoare;
        return data;
    }

    clone(): LichidCalcCurrDetDto {
        const json = this.toJSON();
        let result = new LichidCalcCurrDetDto();
        result.init(json);
        return result;
    }
}

export interface ILichidCalcCurrDetDto {
    lichidCalcCurrId: number;
    descriere: string | undefined;
    valoare: number;
}

export class LichidCalcCurrListDto implements ILichidCalcCurrListDto {
    lichidConfigId: number;
    lichidCalcId: number;
    descriere: string | undefined;
    randTotal: boolean;
    valoareRON: number;
    valoareEUR: number;
    valoareUSD: number;
    valoareGBP: number;
    valoareAlteMonede: number;
    totalActualiz: number;
    totalInit: number;
    tenantId: number;

    constructor(data?: ILichidCalcCurrListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lichidConfigId = _data["lichidConfigId"];
            this.lichidCalcId = _data["lichidCalcId"];
            this.descriere = _data["descriere"];
            this.randTotal = _data["randTotal"];
            this.valoareRON = _data["valoareRON"];
            this.valoareEUR = _data["valoareEUR"];
            this.valoareUSD = _data["valoareUSD"];
            this.valoareGBP = _data["valoareGBP"];
            this.valoareAlteMonede = _data["valoareAlteMonede"];
            this.totalActualiz = _data["totalActualiz"];
            this.totalInit = _data["totalInit"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): LichidCalcCurrListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichidCalcCurrListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichidConfigId"] = this.lichidConfigId;
        data["lichidCalcId"] = this.lichidCalcId;
        data["descriere"] = this.descriere;
        data["randTotal"] = this.randTotal;
        data["valoareRON"] = this.valoareRON;
        data["valoareEUR"] = this.valoareEUR;
        data["valoareUSD"] = this.valoareUSD;
        data["valoareGBP"] = this.valoareGBP;
        data["valoareAlteMonede"] = this.valoareAlteMonede;
        data["totalActualiz"] = this.totalActualiz;
        data["totalInit"] = this.totalInit;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): LichidCalcCurrListDto {
        const json = this.toJSON();
        let result = new LichidCalcCurrListDto();
        result.init(json);
        return result;
    }
}

export interface ILichidCalcCurrListDto {
    lichidConfigId: number;
    lichidCalcId: number;
    descriere: string | undefined;
    randTotal: boolean;
    valoareRON: number;
    valoareEUR: number;
    valoareUSD: number;
    valoareGBP: number;
    valoareAlteMonede: number;
    totalActualiz: number;
    totalInit: number;
    tenantId: number;
}

export class LichidConfigDto implements ILichidConfigDto {
    id: number;
    denumireRand: string | undefined;
    codRand: string | undefined;
    eDinConta: boolean;
    formulaConta: string | undefined;
    formulaTotal: string | undefined;
    tipInstrument: string | undefined;
    lichidBenziId: number | undefined;
    orderView: number;
    state: State;
    tenantId: number;

    constructor(data?: ILichidConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.denumireRand = _data["denumireRand"];
            this.codRand = _data["codRand"];
            this.eDinConta = _data["eDinConta"];
            this.formulaConta = _data["formulaConta"];
            this.formulaTotal = _data["formulaTotal"];
            this.tipInstrument = _data["tipInstrument"];
            this.lichidBenziId = _data["lichidBenziId"];
            this.orderView = _data["orderView"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): LichidConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichidConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["denumireRand"] = this.denumireRand;
        data["codRand"] = this.codRand;
        data["eDinConta"] = this.eDinConta;
        data["formulaConta"] = this.formulaConta;
        data["formulaTotal"] = this.formulaTotal;
        data["tipInstrument"] = this.tipInstrument;
        data["lichidBenziId"] = this.lichidBenziId;
        data["orderView"] = this.orderView;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): LichidConfigDto {
        const json = this.toJSON();
        let result = new LichidConfigDto();
        result.init(json);
        return result;
    }
}

export interface ILichidConfigDto {
    id: number;
    denumireRand: string | undefined;
    codRand: string | undefined;
    eDinConta: boolean;
    formulaConta: string | undefined;
    formulaTotal: string | undefined;
    tipInstrument: string | undefined;
    lichidBenziId: number | undefined;
    orderView: number;
    state: State;
    tenantId: number;
}

export class NotificareDto implements INotificareDto {
    notificareId: number;
    departamentId: number | undefined;
    idPersonal: number | undefined;
    stareNotificareId: number;
    mesaj: string | undefined;
    userVizualizareId: number;
    dataVizualizare: moment.Moment;
    tenantId: number;

    constructor(data?: INotificareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificareId = _data["notificareId"];
            this.departamentId = _data["departamentId"];
            this.idPersonal = _data["idPersonal"];
            this.stareNotificareId = _data["stareNotificareId"];
            this.mesaj = _data["mesaj"];
            this.userVizualizareId = _data["userVizualizareId"];
            this.dataVizualizare = _data["dataVizualizare"] ? moment(_data["dataVizualizare"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): NotificareDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificareId"] = this.notificareId;
        data["departamentId"] = this.departamentId;
        data["idPersonal"] = this.idPersonal;
        data["stareNotificareId"] = this.stareNotificareId;
        data["mesaj"] = this.mesaj;
        data["userVizualizareId"] = this.userVizualizareId;
        data["dataVizualizare"] = this.dataVizualizare ? this.dataVizualizare.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): NotificareDto {
        const json = this.toJSON();
        let result = new NotificareDto();
        result.init(json);
        return result;
    }
}

export interface INotificareDto {
    notificareId: number;
    departamentId: number | undefined;
    idPersonal: number | undefined;
    stareNotificareId: number;
    mesaj: string | undefined;
    userVizualizareId: number;
    dataVizualizare: moment.Moment;
    tenantId: number;
}

export enum TipOperatieDobandaComision {
    _0 = 0,
    _1 = 1,
}

export class OperatieDobandaComisionDto implements IOperatieDobandaComisionDto {
    id: number;
    imprumutId: number | undefined;
    operGenerateId: number | undefined;
    tipOperatieDobandaComision: TipOperatieDobandaComision;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    state: State;

    constructor(data?: IOperatieDobandaComisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imprumutId = _data["imprumutId"];
            this.operGenerateId = _data["operGenerateId"];
            this.tipOperatieDobandaComision = _data["tipOperatieDobandaComision"];
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): OperatieDobandaComisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperatieDobandaComisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imprumutId"] = this.imprumutId;
        data["operGenerateId"] = this.operGenerateId;
        data["tipOperatieDobandaComision"] = this.tipOperatieDobandaComision;
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["state"] = this.state;
        return data;
    }

    clone(): OperatieDobandaComisionDto {
        const json = this.toJSON();
        let result = new OperatieDobandaComisionDto();
        result.init(json);
        return result;
    }
}

export interface IOperatieDobandaComisionDto {
    id: number;
    imprumutId: number | undefined;
    operGenerateId: number | undefined;
    tipOperatieDobandaComision: TipOperatieDobandaComision;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    state: State;
}

export class OperatieDobandaComisionDtoList implements IOperatieDobandaComisionDtoList {
    operatieComision: OperatieDobandaComisionDto[] | undefined;
    operatieDobanda: OperatieDobandaComisionDto[] | undefined;
    operatieDobandaComision: OperatieDobandaComisionDto[] | undefined;

    constructor(data?: IOperatieDobandaComisionDtoList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["operatieComision"])) {
                this.operatieComision = [] as any;
                for (let item of _data["operatieComision"])
                    this.operatieComision.push(OperatieDobandaComisionDto.fromJS(item));
            }
            if (Array.isArray(_data["operatieDobanda"])) {
                this.operatieDobanda = [] as any;
                for (let item of _data["operatieDobanda"])
                    this.operatieDobanda.push(OperatieDobandaComisionDto.fromJS(item));
            }
            if (Array.isArray(_data["operatieDobandaComision"])) {
                this.operatieDobandaComision = [] as any;
                for (let item of _data["operatieDobandaComision"])
                    this.operatieDobandaComision.push(OperatieDobandaComisionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OperatieDobandaComisionDtoList {
        data = typeof data === 'object' ? data : {};
        let result = new OperatieDobandaComisionDtoList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.operatieComision)) {
            data["operatieComision"] = [];
            for (let item of this.operatieComision)
                data["operatieComision"].push(item.toJSON());
        }
        if (Array.isArray(this.operatieDobanda)) {
            data["operatieDobanda"] = [];
            for (let item of this.operatieDobanda)
                data["operatieDobanda"].push(item.toJSON());
        }
        if (Array.isArray(this.operatieDobandaComision)) {
            data["operatieDobandaComision"] = [];
            for (let item of this.operatieDobandaComision)
                data["operatieDobandaComision"].push(item.toJSON());
        }
        return data;
    }

    clone(): OperatieDobandaComisionDtoList {
        const json = this.toJSON();
        let result = new OperatieDobandaComisionDtoList();
        result.init(json);
        return result;
    }
}

export interface IOperatieDobandaComisionDtoList {
    operatieComision: OperatieDobandaComisionDto[] | undefined;
    operatieDobanda: OperatieDobandaComisionDto[] | undefined;
    operatieDobandaComision: OperatieDobandaComisionDto[] | undefined;
}

export class OperationDetailsDTO implements IOperationDetailsDTO {
    id: number;
    value: number;
    valueCurr: number;
    vat: number;
    details: string | undefined;
    debitId: number;
    debit: string | undefined;
    debitName: string | undefined;
    creditId: number;
    credit: string | undefined;
    creditName: string | undefined;
    detailNr: number | undefined;
    operGenerateId: number | undefined;

    constructor(data?: IOperationDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.valueCurr = _data["valueCurr"];
            this.vat = _data["vat"];
            this.details = _data["details"];
            this.debitId = _data["debitId"];
            this.debit = _data["debit"];
            this.debitName = _data["debitName"];
            this.creditId = _data["creditId"];
            this.credit = _data["credit"];
            this.creditName = _data["creditName"];
            this.detailNr = _data["detailNr"];
            this.operGenerateId = _data["operGenerateId"];
        }
    }

    static fromJS(data: any): OperationDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OperationDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["valueCurr"] = this.valueCurr;
        data["vat"] = this.vat;
        data["details"] = this.details;
        data["debitId"] = this.debitId;
        data["debit"] = this.debit;
        data["debitName"] = this.debitName;
        data["creditId"] = this.creditId;
        data["credit"] = this.credit;
        data["creditName"] = this.creditName;
        data["detailNr"] = this.detailNr;
        data["operGenerateId"] = this.operGenerateId;
        return data;
    }

    clone(): OperationDetailsDTO {
        const json = this.toJSON();
        let result = new OperationDetailsDTO();
        result.init(json);
        return result;
    }
}

export interface IOperationDetailsDTO {
    id: number;
    value: number;
    valueCurr: number;
    vat: number;
    details: string | undefined;
    debitId: number;
    debit: string | undefined;
    debitName: string | undefined;
    creditId: number;
    credit: string | undefined;
    creditName: string | undefined;
    detailNr: number | undefined;
    operGenerateId: number | undefined;
}

export class OperationDTO implements IOperationDTO {
    id: number;
    operationDate: moment.Moment;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    closingMonth: boolean;
    operationsDetails: OperationDetailsDTO[] | undefined;
    documentTypeId: number;
    documentType: string | undefined;
    currencyId: number;
    currencyName: string | undefined;
    operationTypeId: number | undefined;
    operationType: string | undefined;
    operationDefinitionId: number | undefined;
    appClientId: number;
    value: number;
    valueCurr: number;
    showDetail: boolean;
    externalOperation: boolean;

    constructor(data?: IOperationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.closingMonth = _data["closingMonth"];
            if (Array.isArray(_data["operationsDetails"])) {
                this.operationsDetails = [] as any;
                for (let item of _data["operationsDetails"])
                    this.operationsDetails.push(OperationDetailsDTO.fromJS(item));
            }
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.operationTypeId = _data["operationTypeId"];
            this.operationType = _data["operationType"];
            this.operationDefinitionId = _data["operationDefinitionId"];
            this.appClientId = _data["appClientId"];
            this.value = _data["value"];
            this.valueCurr = _data["valueCurr"];
            this.showDetail = _data["showDetail"];
            this.externalOperation = _data["externalOperation"];
        }
    }

    static fromJS(data: any): OperationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OperationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["closingMonth"] = this.closingMonth;
        if (Array.isArray(this.operationsDetails)) {
            data["operationsDetails"] = [];
            for (let item of this.operationsDetails)
                data["operationsDetails"].push(item.toJSON());
        }
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["operationTypeId"] = this.operationTypeId;
        data["operationType"] = this.operationType;
        data["operationDefinitionId"] = this.operationDefinitionId;
        data["appClientId"] = this.appClientId;
        data["value"] = this.value;
        data["valueCurr"] = this.valueCurr;
        data["showDetail"] = this.showDetail;
        data["externalOperation"] = this.externalOperation;
        return data;
    }

    clone(): OperationDTO {
        const json = this.toJSON();
        let result = new OperationDTO();
        result.init(json);
        return result;
    }
}

export interface IOperationDTO {
    id: number;
    operationDate: moment.Moment;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    closingMonth: boolean;
    operationsDetails: OperationDetailsDTO[] | undefined;
    documentTypeId: number;
    documentType: string | undefined;
    currencyId: number;
    currencyName: string | undefined;
    operationTypeId: number | undefined;
    operationType: string | undefined;
    operationDefinitionId: number | undefined;
    appClientId: number;
    value: number;
    valueCurr: number;
    showDetail: boolean;
    externalOperation: boolean;
}

export class OperationSearchDto implements IOperationSearchDto {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    account1: string | undefined;
    account2: string | undefined;
    documentTypeId: number | undefined;
    operationTypeId: number | undefined;
    documentNumber: string | undefined;
    value: number | undefined;
    operationId: number | undefined;
    explication: string | undefined;
    operations: OperationDTO[] | undefined;

    constructor(data?: IOperationSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.account1 = _data["account1"];
            this.account2 = _data["account2"];
            this.documentTypeId = _data["documentTypeId"];
            this.operationTypeId = _data["operationTypeId"];
            this.documentNumber = _data["documentNumber"];
            this.value = _data["value"];
            this.operationId = _data["operationId"];
            this.explication = _data["explication"];
            if (Array.isArray(_data["operations"])) {
                this.operations = [] as any;
                for (let item of _data["operations"])
                    this.operations.push(OperationDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OperationSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["account1"] = this.account1;
        data["account2"] = this.account2;
        data["documentTypeId"] = this.documentTypeId;
        data["operationTypeId"] = this.operationTypeId;
        data["documentNumber"] = this.documentNumber;
        data["value"] = this.value;
        data["operationId"] = this.operationId;
        data["explication"] = this.explication;
        if (Array.isArray(this.operations)) {
            data["operations"] = [];
            for (let item of this.operations)
                data["operations"].push(item.toJSON());
        }
        return data;
    }

    clone(): OperationSearchDto {
        const json = this.toJSON();
        let result = new OperationSearchDto();
        result.init(json);
        return result;
    }
}

export interface IOperationSearchDto {
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    account1: string | undefined;
    account2: string | undefined;
    documentTypeId: number | undefined;
    operationTypeId: number | undefined;
    documentNumber: string | undefined;
    value: number | undefined;
    operationId: number | undefined;
    explication: string | undefined;
    operations: OperationDTO[] | undefined;
}

export class OperationEditDetailsDto implements IOperationEditDetailsDto {
    id: number;
    value: number;
    valueCurr: number;
    vat: number;
    details: string | undefined;
    debitId: number;
    debitName: string | undefined;
    creditId: number;
    creditName: string | undefined;
    idOrd: number;
    detailNr: number | undefined;
    operGenerateId: number | undefined;
    showInvoiceDetails: boolean;
    invoiceElementsDetailsId: number | undefined;
    invoiceElementsDetailsCategoryId: number | undefined;

    constructor(data?: IOperationEditDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.valueCurr = _data["valueCurr"];
            this.vat = _data["vat"];
            this.details = _data["details"];
            this.debitId = _data["debitId"];
            this.debitName = _data["debitName"];
            this.creditId = _data["creditId"];
            this.creditName = _data["creditName"];
            this.idOrd = _data["idOrd"];
            this.detailNr = _data["detailNr"];
            this.operGenerateId = _data["operGenerateId"];
            this.showInvoiceDetails = _data["showInvoiceDetails"];
            this.invoiceElementsDetailsId = _data["invoiceElementsDetailsId"];
            this.invoiceElementsDetailsCategoryId = _data["invoiceElementsDetailsCategoryId"];
        }
    }

    static fromJS(data: any): OperationEditDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationEditDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["valueCurr"] = this.valueCurr;
        data["vat"] = this.vat;
        data["details"] = this.details;
        data["debitId"] = this.debitId;
        data["debitName"] = this.debitName;
        data["creditId"] = this.creditId;
        data["creditName"] = this.creditName;
        data["idOrd"] = this.idOrd;
        data["detailNr"] = this.detailNr;
        data["operGenerateId"] = this.operGenerateId;
        data["showInvoiceDetails"] = this.showInvoiceDetails;
        data["invoiceElementsDetailsId"] = this.invoiceElementsDetailsId;
        data["invoiceElementsDetailsCategoryId"] = this.invoiceElementsDetailsCategoryId;
        return data;
    }

    clone(): OperationEditDetailsDto {
        const json = this.toJSON();
        let result = new OperationEditDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IOperationEditDetailsDto {
    id: number;
    value: number;
    valueCurr: number;
    vat: number;
    details: string | undefined;
    debitId: number;
    debitName: string | undefined;
    creditId: number;
    creditName: string | undefined;
    idOrd: number;
    detailNr: number | undefined;
    operGenerateId: number | undefined;
    showInvoiceDetails: boolean;
    invoiceElementsDetailsId: number | undefined;
    invoiceElementsDetailsCategoryId: number | undefined;
}

export class OperationLast10DTO implements IOperationLast10DTO {
    id: number;
    operationDate: moment.Moment;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    closingMonth: boolean;
    documentTypeId: number;
    documentType: string | undefined;
    operationTypeId: number | undefined;
    operationType: string | undefined;
    currencyId: number;
    currencyName: string | undefined;
    operationDefinitionId: number | undefined;
    value: number;
    valueCurr: number;
    showDetail: boolean;

    constructor(data?: IOperationLast10DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.closingMonth = _data["closingMonth"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.operationTypeId = _data["operationTypeId"];
            this.operationType = _data["operationType"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.operationDefinitionId = _data["operationDefinitionId"];
            this.value = _data["value"];
            this.valueCurr = _data["valueCurr"];
            this.showDetail = _data["showDetail"];
        }
    }

    static fromJS(data: any): OperationLast10DTO {
        data = typeof data === 'object' ? data : {};
        let result = new OperationLast10DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["closingMonth"] = this.closingMonth;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["operationTypeId"] = this.operationTypeId;
        data["operationType"] = this.operationType;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["operationDefinitionId"] = this.operationDefinitionId;
        data["value"] = this.value;
        data["valueCurr"] = this.valueCurr;
        data["showDetail"] = this.showDetail;
        return data;
    }

    clone(): OperationLast10DTO {
        const json = this.toJSON();
        let result = new OperationLast10DTO();
        result.init(json);
        return result;
    }
}

export interface IOperationLast10DTO {
    id: number;
    operationDate: moment.Moment;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    closingMonth: boolean;
    documentTypeId: number;
    documentType: string | undefined;
    operationTypeId: number | undefined;
    operationType: string | undefined;
    currencyId: number;
    currencyName: string | undefined;
    operationDefinitionId: number | undefined;
    value: number;
    valueCurr: number;
    showDetail: boolean;
}

export class OperationEditDto implements IOperationEditDto {
    id: number;
    operationDate: moment.Moment;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    closingMonth: boolean;
    documentTypeId: number;
    currencyId: number;
    localCurrencyId: number;
    operationTypeId: number | undefined;
    exchangeRate: number;
    operationDefinitionId: number | undefined;
    operationParentId: number | undefined;
    operationDetails: OperationEditDetailsDto[] | undefined;
    last10: OperationLast10DTO[] | undefined;

    constructor(data?: IOperationEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.closingMonth = _data["closingMonth"];
            this.documentTypeId = _data["documentTypeId"];
            this.currencyId = _data["currencyId"];
            this.localCurrencyId = _data["localCurrencyId"];
            this.operationTypeId = _data["operationTypeId"];
            this.exchangeRate = _data["exchangeRate"];
            this.operationDefinitionId = _data["operationDefinitionId"];
            this.operationParentId = _data["operationParentId"];
            if (Array.isArray(_data["operationDetails"])) {
                this.operationDetails = [] as any;
                for (let item of _data["operationDetails"])
                    this.operationDetails.push(OperationEditDetailsDto.fromJS(item));
            }
            if (Array.isArray(_data["last10"])) {
                this.last10 = [] as any;
                for (let item of _data["last10"])
                    this.last10.push(OperationLast10DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OperationEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["closingMonth"] = this.closingMonth;
        data["documentTypeId"] = this.documentTypeId;
        data["currencyId"] = this.currencyId;
        data["localCurrencyId"] = this.localCurrencyId;
        data["operationTypeId"] = this.operationTypeId;
        data["exchangeRate"] = this.exchangeRate;
        data["operationDefinitionId"] = this.operationDefinitionId;
        data["operationParentId"] = this.operationParentId;
        if (Array.isArray(this.operationDetails)) {
            data["operationDetails"] = [];
            for (let item of this.operationDetails)
                data["operationDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.last10)) {
            data["last10"] = [];
            for (let item of this.last10)
                data["last10"].push(item.toJSON());
        }
        return data;
    }

    clone(): OperationEditDto {
        const json = this.toJSON();
        let result = new OperationEditDto();
        result.init(json);
        return result;
    }
}

export interface IOperationEditDto {
    id: number;
    operationDate: moment.Moment;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    closingMonth: boolean;
    documentTypeId: number;
    currencyId: number;
    localCurrencyId: number;
    operationTypeId: number | undefined;
    exchangeRate: number;
    operationDefinitionId: number | undefined;
    operationParentId: number | undefined;
    operationDetails: OperationEditDetailsDto[] | undefined;
    last10: OperationLast10DTO[] | undefined;
}

export class SoldOperationDto implements ISoldOperationDto {
    soldInitial: number;
    currentDate: moment.Moment;
    soldInitialType: string | undefined;

    constructor(data?: ISoldOperationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.soldInitial = _data["soldInitial"];
            this.currentDate = _data["currentDate"] ? moment(_data["currentDate"].toString()) : <any>undefined;
            this.soldInitialType = _data["soldInitialType"];
        }
    }

    static fromJS(data: any): SoldOperationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoldOperationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["soldInitial"] = this.soldInitial;
        data["currentDate"] = this.currentDate ? this.currentDate.toISOString() : <any>undefined;
        data["soldInitialType"] = this.soldInitialType;
        return data;
    }

    clone(): SoldOperationDto {
        const json = this.toJSON();
        let result = new SoldOperationDto();
        result.init(json);
        return result;
    }
}

export interface ISoldOperationDto {
    soldInitial: number;
    currentDate: moment.Moment;
    soldInitialType: string | undefined;
}

export class OperationDefinitionDetailsDto implements IOperationDefinitionDetailsDto {
    id: number;
    observations: string | undefined;
    debitId: number;
    debitName: string | undefined;
    creditId: number;
    creditName: string | undefined;
    tenantId: number;
    operationDefinitionId: number;

    constructor(data?: IOperationDefinitionDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.observations = _data["observations"];
            this.debitId = _data["debitId"];
            this.debitName = _data["debitName"];
            this.creditId = _data["creditId"];
            this.creditName = _data["creditName"];
            this.tenantId = _data["tenantId"];
            this.operationDefinitionId = _data["operationDefinitionId"];
        }
    }

    static fromJS(data: any): OperationDefinitionDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationDefinitionDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["observations"] = this.observations;
        data["debitId"] = this.debitId;
        data["debitName"] = this.debitName;
        data["creditId"] = this.creditId;
        data["creditName"] = this.creditName;
        data["tenantId"] = this.tenantId;
        data["operationDefinitionId"] = this.operationDefinitionId;
        return data;
    }

    clone(): OperationDefinitionDetailsDto {
        const json = this.toJSON();
        let result = new OperationDefinitionDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IOperationDefinitionDetailsDto {
    id: number;
    observations: string | undefined;
    debitId: number;
    debitName: string | undefined;
    creditId: number;
    creditName: string | undefined;
    tenantId: number;
    operationDefinitionId: number;
}

export class OperationDefinitionDto implements IOperationDefinitionDto {
    id: number;
    name: string | undefined;
    status: State;
    documentTypeId: number;
    currencyId: number;
    operationDetails: OperationDefinitionDetailsDto[] | undefined;
    tenantId: number;

    constructor(data?: IOperationDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.documentTypeId = _data["documentTypeId"];
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["operationDetails"])) {
                this.operationDetails = [] as any;
                for (let item of _data["operationDetails"])
                    this.operationDetails.push(OperationDefinitionDetailsDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): OperationDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["status"] = this.status;
        data["documentTypeId"] = this.documentTypeId;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.operationDetails)) {
            data["operationDetails"] = [];
            for (let item of this.operationDetails)
                data["operationDetails"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): OperationDefinitionDto {
        const json = this.toJSON();
        let result = new OperationDefinitionDto();
        result.init(json);
        return result;
    }
}

export interface IOperationDefinitionDto {
    id: number;
    name: string | undefined;
    status: State;
    documentTypeId: number;
    currencyId: number;
    operationDetails: OperationDefinitionDetailsDto[] | undefined;
    tenantId: number;
}

export class OperationTypesEditDto implements IOperationTypesEditDto {
    id: number;
    name: string | undefined;
    appClientId: number;

    constructor(data?: IOperationTypesEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.appClientId = _data["appClientId"];
        }
    }

    static fromJS(data: any): OperationTypesEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationTypesEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["appClientId"] = this.appClientId;
        return data;
    }

    clone(): OperationTypesEditDto {
        const json = this.toJSON();
        let result = new OperationTypesEditDto();
        result.init(json);
        return result;
    }
}

export interface IOperationTypesEditDto {
    id: number;
    name: string | undefined;
    appClientId: number;
}

export class OperationTypesListDto implements IOperationTypesListDto {
    id: number;
    name: string | undefined;

    constructor(data?: IOperationTypesListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OperationTypesListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationTypesListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): OperationTypesListDto {
        const json = this.toJSON();
        let result = new OperationTypesListDto();
        result.init(json);
        return result;
    }
}

export interface IOperationTypesListDto {
    id: number;
    name: string | undefined;
}

export class OperGenerateListDto implements IOperGenerateListDto {
    id: number;
    categorieOperatie: string | undefined;
    tipOperatie: string | undefined;
    dataOperatie: moment.Moment;
    showDetail: boolean;

    constructor(data?: IOperGenerateListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categorieOperatie = _data["categorieOperatie"];
            this.tipOperatie = _data["tipOperatie"];
            this.dataOperatie = _data["dataOperatie"] ? moment(_data["dataOperatie"].toString()) : <any>undefined;
            this.showDetail = _data["showDetail"];
        }
    }

    static fromJS(data: any): OperGenerateListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperGenerateListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categorieOperatie"] = this.categorieOperatie;
        data["tipOperatie"] = this.tipOperatie;
        data["dataOperatie"] = this.dataOperatie ? this.dataOperatie.toISOString() : <any>undefined;
        data["showDetail"] = this.showDetail;
        return data;
    }

    clone(): OperGenerateListDto {
        const json = this.toJSON();
        let result = new OperGenerateListDto();
        result.init(json);
        return result;
    }
}

export interface IOperGenerateListDto {
    id: number;
    categorieOperatie: string | undefined;
    tipOperatie: string | undefined;
    dataOperatie: moment.Moment;
    showDetail: boolean;
}

export class OperGenerateAddListDto implements IOperGenerateAddListDto {
    selected: boolean;
    categorieOperatie: string | undefined;
    tipOperatieId: number;
    tipOperatie: string | undefined;
    tipOperatieShort: string | undefined;
    dataOperatie: moment.Moment;
    execOrder: number;

    constructor(data?: IOperGenerateAddListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.selected = _data["selected"];
            this.categorieOperatie = _data["categorieOperatie"];
            this.tipOperatieId = _data["tipOperatieId"];
            this.tipOperatie = _data["tipOperatie"];
            this.tipOperatieShort = _data["tipOperatieShort"];
            this.dataOperatie = _data["dataOperatie"] ? moment(_data["dataOperatie"].toString()) : <any>undefined;
            this.execOrder = _data["execOrder"];
        }
    }

    static fromJS(data: any): OperGenerateAddListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperGenerateAddListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["selected"] = this.selected;
        data["categorieOperatie"] = this.categorieOperatie;
        data["tipOperatieId"] = this.tipOperatieId;
        data["tipOperatie"] = this.tipOperatie;
        data["tipOperatieShort"] = this.tipOperatieShort;
        data["dataOperatie"] = this.dataOperatie ? this.dataOperatie.toISOString() : <any>undefined;
        data["execOrder"] = this.execOrder;
        return data;
    }

    clone(): OperGenerateAddListDto {
        const json = this.toJSON();
        let result = new OperGenerateAddListDto();
        result.init(json);
        return result;
    }
}

export interface IOperGenerateAddListDto {
    selected: boolean;
    categorieOperatie: string | undefined;
    tipOperatieId: number;
    tipOperatie: string | undefined;
    tipOperatieShort: string | undefined;
    dataOperatie: moment.Moment;
    execOrder: number;
}

export class OperGenerateAddDto implements IOperGenerateAddDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    operatiiPropuse: OperGenerateAddListDto[] | undefined;

    constructor(data?: IOperGenerateAddDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["operatiiPropuse"])) {
                this.operatiiPropuse = [] as any;
                for (let item of _data["operatiiPropuse"])
                    this.operatiiPropuse.push(OperGenerateAddListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OperGenerateAddDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperGenerateAddDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.operatiiPropuse)) {
            data["operatiiPropuse"] = [];
            for (let item of this.operatiiPropuse)
                data["operatiiPropuse"].push(item.toJSON());
        }
        return data;
    }

    clone(): OperGenerateAddDto {
        const json = this.toJSON();
        let result = new OperGenerateAddDto();
        result.init(json);
        return result;
    }
}

export interface IOperGenerateAddDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    operatiiPropuse: OperGenerateAddListDto[] | undefined;
}

export class PaapDepartamentListDto implements IPaapDepartamentListDto {
    departamentName: string | undefined;
    paapListDetails: PaapDto[] | undefined;

    constructor(data?: IPaapDepartamentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departamentName = _data["departamentName"];
            if (Array.isArray(_data["paapListDetails"])) {
                this.paapListDetails = [] as any;
                for (let item of _data["paapListDetails"])
                    this.paapListDetails.push(PaapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaapDepartamentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapDepartamentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departamentName"] = this.departamentName;
        if (Array.isArray(this.paapListDetails)) {
            data["paapListDetails"] = [];
            for (let item of this.paapListDetails)
                data["paapListDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaapDepartamentListDto {
        const json = this.toJSON();
        let result = new PaapDepartamentListDto();
        result.init(json);
        return result;
    }
}

export interface IPaapDepartamentListDto {
    departamentName: string | undefined;
    paapListDetails: PaapDto[] | undefined;
}

export class PaapEditDto implements IPaapEditDto {
    id: number;
    descriere: string | undefined;
    comentarii: string | undefined;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsId: number | undefined;
    obiectTranzactieId: number | undefined;
    departamentId: number | undefined;
    currencyId: number | undefined;
    imoAssetClassCodeId: number | undefined;
    cotaTVA_Id: number | undefined;
    localCurrencyId: number | undefined;
    codCPV: string | undefined;
    valoareEstimataFaraTvaLei: number;
    valoareTotalaValuta: number;
    valoareTotalaLei: number;
    availableValue: number | undefined;
    sursaFinantareId: number | undefined;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    firstInstalmentDate: moment.Moment;
    modalitateDerulareId: number | undefined;
    contractsPaymentInstalmentFreqId: number | undefined;
    durationInMonths: number | undefined;
    nrTranse: number;
    transe: BVC_PAAPTranseDto[] | undefined;
    state: State;
    tenantId: number;

    constructor(data?: IPaapEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descriere = _data["descriere"];
            this.comentarii = _data["comentarii"];
            this.invoiceElementsDetailsCategoryId = _data["invoiceElementsDetailsCategoryId"];
            this.invoiceElementsDetailsId = _data["invoiceElementsDetailsId"];
            this.obiectTranzactieId = _data["obiectTranzactieId"];
            this.departamentId = _data["departamentId"];
            this.currencyId = _data["currencyId"];
            this.imoAssetClassCodeId = _data["imoAssetClassCodeId"];
            this.cotaTVA_Id = _data["cotaTVA_Id"];
            this.localCurrencyId = _data["localCurrencyId"];
            this.codCPV = _data["codCPV"];
            this.valoareEstimataFaraTvaLei = _data["valoareEstimataFaraTvaLei"];
            this.valoareTotalaValuta = _data["valoareTotalaValuta"];
            this.valoareTotalaLei = _data["valoareTotalaLei"];
            this.availableValue = _data["availableValue"];
            this.sursaFinantareId = _data["sursaFinantareId"];
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.firstInstalmentDate = _data["firstInstalmentDate"] ? moment(_data["firstInstalmentDate"].toString()) : <any>undefined;
            this.modalitateDerulareId = _data["modalitateDerulareId"];
            this.contractsPaymentInstalmentFreqId = _data["contractsPaymentInstalmentFreqId"];
            this.durationInMonths = _data["durationInMonths"];
            this.nrTranse = _data["nrTranse"];
            if (Array.isArray(_data["transe"])) {
                this.transe = [] as any;
                for (let item of _data["transe"])
                    this.transe.push(BVC_PAAPTranseDto.fromJS(item));
            }
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): PaapEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descriere"] = this.descriere;
        data["comentarii"] = this.comentarii;
        data["invoiceElementsDetailsCategoryId"] = this.invoiceElementsDetailsCategoryId;
        data["invoiceElementsDetailsId"] = this.invoiceElementsDetailsId;
        data["obiectTranzactieId"] = this.obiectTranzactieId;
        data["departamentId"] = this.departamentId;
        data["currencyId"] = this.currencyId;
        data["imoAssetClassCodeId"] = this.imoAssetClassCodeId;
        data["cotaTVA_Id"] = this.cotaTVA_Id;
        data["localCurrencyId"] = this.localCurrencyId;
        data["codCPV"] = this.codCPV;
        data["valoareEstimataFaraTvaLei"] = this.valoareEstimataFaraTvaLei;
        data["valoareTotalaValuta"] = this.valoareTotalaValuta;
        data["valoareTotalaLei"] = this.valoareTotalaLei;
        data["availableValue"] = this.availableValue;
        data["sursaFinantareId"] = this.sursaFinantareId;
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["firstInstalmentDate"] = this.firstInstalmentDate ? this.firstInstalmentDate.toISOString() : <any>undefined;
        data["modalitateDerulareId"] = this.modalitateDerulareId;
        data["contractsPaymentInstalmentFreqId"] = this.contractsPaymentInstalmentFreqId;
        data["durationInMonths"] = this.durationInMonths;
        data["nrTranse"] = this.nrTranse;
        if (Array.isArray(this.transe)) {
            data["transe"] = [];
            for (let item of this.transe)
                data["transe"].push(item.toJSON());
        }
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): PaapEditDto {
        const json = this.toJSON();
        let result = new PaapEditDto();
        result.init(json);
        return result;
    }
}

export interface IPaapEditDto {
    id: number;
    descriere: string | undefined;
    comentarii: string | undefined;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsId: number | undefined;
    obiectTranzactieId: number | undefined;
    departamentId: number | undefined;
    currencyId: number | undefined;
    imoAssetClassCodeId: number | undefined;
    cotaTVA_Id: number | undefined;
    localCurrencyId: number | undefined;
    codCPV: string | undefined;
    valoareEstimataFaraTvaLei: number;
    valoareTotalaValuta: number;
    valoareTotalaLei: number;
    availableValue: number | undefined;
    sursaFinantareId: number | undefined;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    firstInstalmentDate: moment.Moment;
    modalitateDerulareId: number | undefined;
    contractsPaymentInstalmentFreqId: number | undefined;
    durationInMonths: number | undefined;
    nrTranse: number;
    transe: BVC_PAAPTranseDto[] | undefined;
    state: State;
    tenantId: number;
}

export class PaapStateListDto implements IPaapStateListDto {
    paap_State: string | undefined;
    valoareEstimataFaraTvaLei: number;
    valoareTotalaLei: number;
    currencyName: string | undefined;
    valoareTotalaValuta: number;
    tva: number;
    dataEnd: moment.Moment;
    comentarii: string | undefined;

    constructor(data?: IPaapStateListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paap_State = _data["paap_State"];
            this.valoareEstimataFaraTvaLei = _data["valoareEstimataFaraTvaLei"];
            this.valoareTotalaLei = _data["valoareTotalaLei"];
            this.currencyName = _data["currencyName"];
            this.valoareTotalaValuta = _data["valoareTotalaValuta"];
            this.tva = _data["tva"];
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.comentarii = _data["comentarii"];
        }
    }

    static fromJS(data: any): PaapStateListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapStateListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paap_State"] = this.paap_State;
        data["valoareEstimataFaraTvaLei"] = this.valoareEstimataFaraTvaLei;
        data["valoareTotalaLei"] = this.valoareTotalaLei;
        data["currencyName"] = this.currencyName;
        data["valoareTotalaValuta"] = this.valoareTotalaValuta;
        data["tva"] = this.tva;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["comentarii"] = this.comentarii;
        return data;
    }

    clone(): PaapStateListDto {
        const json = this.toJSON();
        let result = new PaapStateListDto();
        result.init(json);
        return result;
    }
}

export interface IPaapStateListDto {
    paap_State: string | undefined;
    valoareEstimataFaraTvaLei: number;
    valoareTotalaLei: number;
    currencyName: string | undefined;
    valoareTotalaValuta: number;
    tva: number;
    dataEnd: moment.Moment;
    comentarii: string | undefined;
}

export enum PAAP_State {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class PaapStateEditDto implements IPaapStateEditDto {
    id: number;
    paapId: number;
    operationDate: moment.Moment | undefined;
    tenantId: number;
    paap_State: PAAP_State;
    state: State;
    dataEnd: moment.Moment;
    comentarii: string | undefined;

    constructor(data?: IPaapStateEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paapId = _data["paapId"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.paap_State = _data["paap_State"];
            this.state = _data["state"];
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.comentarii = _data["comentarii"];
        }
    }

    static fromJS(data: any): PaapStateEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapStateEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paapId"] = this.paapId;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["paap_State"] = this.paap_State;
        data["state"] = this.state;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["comentarii"] = this.comentarii;
        return data;
    }

    clone(): PaapStateEditDto {
        const json = this.toJSON();
        let result = new PaapStateEditDto();
        result.init(json);
        return result;
    }
}

export interface IPaapStateEditDto {
    id: number;
    paapId: number;
    operationDate: moment.Moment | undefined;
    tenantId: number;
    paap_State: PAAP_State;
    state: State;
    dataEnd: moment.Moment;
    comentarii: string | undefined;
}

export class InvoiceDetailPAAPDto implements IInvoiceDetailPAAPDto {
    id: number;
    thirdPartyAccount: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    detailValue: number;
    detailValueLocalCurr: number | undefined;
    selected: boolean;

    constructor(data?: IInvoiceDetailPAAPDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.thirdPartyAccount = _data["thirdPartyAccount"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceSeries = _data["invoiceSeries"];
            this.value = _data["value"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.detailValue = _data["detailValue"];
            this.detailValueLocalCurr = _data["detailValueLocalCurr"];
            this.selected = _data["selected"];
        }
    }

    static fromJS(data: any): InvoiceDetailPAAPDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetailPAAPDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["thirdPartyAccount"] = this.thirdPartyAccount;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceSeries"] = this.invoiceSeries;
        data["value"] = this.value;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["detailValue"] = this.detailValue;
        data["detailValueLocalCurr"] = this.detailValueLocalCurr;
        data["selected"] = this.selected;
        return data;
    }

    clone(): InvoiceDetailPAAPDto {
        const json = this.toJSON();
        let result = new InvoiceDetailPAAPDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetailPAAPDto {
    id: number;
    thirdPartyAccount: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    detailValue: number;
    detailValueLocalCurr: number | undefined;
    selected: boolean;
}

export class InvoiceDetailsForPAAPDto implements IInvoiceDetailsForPAAPDto {
    invoiceDetailsAllocatedForPAAP: InvoiceDetailPAAPDto[] | undefined;
    invoiceDetailsAvailableForPAAP: InvoiceDetailPAAPDto[] | undefined;

    constructor(data?: IInvoiceDetailsForPAAPDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["invoiceDetailsAllocatedForPAAP"])) {
                this.invoiceDetailsAllocatedForPAAP = [] as any;
                for (let item of _data["invoiceDetailsAllocatedForPAAP"])
                    this.invoiceDetailsAllocatedForPAAP.push(InvoiceDetailPAAPDto.fromJS(item));
            }
            if (Array.isArray(_data["invoiceDetailsAvailableForPAAP"])) {
                this.invoiceDetailsAvailableForPAAP = [] as any;
                for (let item of _data["invoiceDetailsAvailableForPAAP"])
                    this.invoiceDetailsAvailableForPAAP.push(InvoiceDetailPAAPDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceDetailsForPAAPDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetailsForPAAPDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.invoiceDetailsAllocatedForPAAP)) {
            data["invoiceDetailsAllocatedForPAAP"] = [];
            for (let item of this.invoiceDetailsAllocatedForPAAP)
                data["invoiceDetailsAllocatedForPAAP"].push(item.toJSON());
        }
        if (Array.isArray(this.invoiceDetailsAvailableForPAAP)) {
            data["invoiceDetailsAvailableForPAAP"] = [];
            for (let item of this.invoiceDetailsAvailableForPAAP)
                data["invoiceDetailsAvailableForPAAP"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvoiceDetailsForPAAPDto {
        const json = this.toJSON();
        let result = new InvoiceDetailsForPAAPDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetailsForPAAPDto {
    invoiceDetailsAllocatedForPAAP: InvoiceDetailPAAPDto[] | undefined;
    invoiceDetailsAvailableForPAAP: InvoiceDetailPAAPDto[] | undefined;
}

export class AmanarePaapEditDto implements IAmanarePaapEditDto {
    paapId: number;
    dataEnd: moment.Moment;
    comentarii: string | undefined;

    constructor(data?: IAmanarePaapEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paapId = _data["paapId"];
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.comentarii = _data["comentarii"];
        }
    }

    static fromJS(data: any): AmanarePaapEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AmanarePaapEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paapId"] = this.paapId;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["comentarii"] = this.comentarii;
        return data;
    }

    clone(): AmanarePaapEditDto {
        const json = this.toJSON();
        let result = new AmanarePaapEditDto();
        result.init(json);
        return result;
    }
}

export interface IAmanarePaapEditDto {
    paapId: number;
    dataEnd: moment.Moment;
    comentarii: string | undefined;
}

export class RealocarePaapDto implements IRealocarePaapDto {
    valoareTotala: number;
    transe: BVC_PAAPTranseDto[] | undefined;
    paapId: number;
    dataEnd: moment.Moment;
    comentarii: string | undefined;

    constructor(data?: IRealocarePaapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valoareTotala = _data["valoareTotala"];
            if (Array.isArray(_data["transe"])) {
                this.transe = [] as any;
                for (let item of _data["transe"])
                    this.transe.push(BVC_PAAPTranseDto.fromJS(item));
            }
            this.paapId = _data["paapId"];
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.comentarii = _data["comentarii"];
        }
    }

    static fromJS(data: any): RealocarePaapDto {
        data = typeof data === 'object' ? data : {};
        let result = new RealocarePaapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valoareTotala"] = this.valoareTotala;
        if (Array.isArray(this.transe)) {
            data["transe"] = [];
            for (let item of this.transe)
                data["transe"].push(item.toJSON());
        }
        data["paapId"] = this.paapId;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["comentarii"] = this.comentarii;
        return data;
    }

    clone(): RealocarePaapDto {
        const json = this.toJSON();
        let result = new RealocarePaapDto();
        result.init(json);
        return result;
    }
}

export interface IRealocarePaapDto {
    valoareTotala: number;
    transe: BVC_PAAPTranseDto[] | undefined;
    paapId: number;
    dataEnd: moment.Moment;
    comentarii: string | undefined;
}

export class PaapTranseListDto implements IPaapTranseListDto {
    id: number;
    bvC_PAAPId: number;
    dataTransa: moment.Moment;
    valoareLei: number;
    valoareLeiFaraTVA: number;
    invoiceElementsDetailsName: string | undefined;
    invoiceElementsDetailsCategoryName: string | undefined;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsId: number | undefined;
    statePAAP: string | undefined;

    constructor(data?: IPaapTranseListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bvC_PAAPId = _data["bvC_PAAPId"];
            this.dataTransa = _data["dataTransa"] ? moment(_data["dataTransa"].toString()) : <any>undefined;
            this.valoareLei = _data["valoareLei"];
            this.valoareLeiFaraTVA = _data["valoareLeiFaraTVA"];
            this.invoiceElementsDetailsName = _data["invoiceElementsDetailsName"];
            this.invoiceElementsDetailsCategoryName = _data["invoiceElementsDetailsCategoryName"];
            this.invoiceElementsDetailsCategoryId = _data["invoiceElementsDetailsCategoryId"];
            this.invoiceElementsDetailsId = _data["invoiceElementsDetailsId"];
            this.statePAAP = _data["statePAAP"];
        }
    }

    static fromJS(data: any): PaapTranseListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapTranseListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bvC_PAAPId"] = this.bvC_PAAPId;
        data["dataTransa"] = this.dataTransa ? this.dataTransa.toISOString() : <any>undefined;
        data["valoareLei"] = this.valoareLei;
        data["valoareLeiFaraTVA"] = this.valoareLeiFaraTVA;
        data["invoiceElementsDetailsName"] = this.invoiceElementsDetailsName;
        data["invoiceElementsDetailsCategoryName"] = this.invoiceElementsDetailsCategoryName;
        data["invoiceElementsDetailsCategoryId"] = this.invoiceElementsDetailsCategoryId;
        data["invoiceElementsDetailsId"] = this.invoiceElementsDetailsId;
        data["statePAAP"] = this.statePAAP;
        return data;
    }

    clone(): PaapTranseListDto {
        const json = this.toJSON();
        let result = new PaapTranseListDto();
        result.init(json);
        return result;
    }
}

export interface IPaapTranseListDto {
    id: number;
    bvC_PAAPId: number;
    dataTransa: moment.Moment;
    valoareLei: number;
    valoareLeiFaraTVA: number;
    invoiceElementsDetailsName: string | undefined;
    invoiceElementsDetailsCategoryName: string | undefined;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsId: number | undefined;
    statePAAP: string | undefined;
}

export class BVC_PAAP_Description_Date implements IBVC_PAAP_Description_Date {
    bvC_PAAP_Id: number;
    descriere: string | undefined;
    dataEnd: moment.Moment;
    rest: number;

    constructor(data?: IBVC_PAAP_Description_Date) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bvC_PAAP_Id = _data["bvC_PAAP_Id"];
            this.descriere = _data["descriere"];
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.rest = _data["rest"];
        }
    }

    static fromJS(data: any): BVC_PAAP_Description_Date {
        data = typeof data === 'object' ? data : {};
        let result = new BVC_PAAP_Description_Date();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bvC_PAAP_Id"] = this.bvC_PAAP_Id;
        data["descriere"] = this.descriere;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["rest"] = this.rest;
        return data;
    }

    clone(): BVC_PAAP_Description_Date {
        const json = this.toJSON();
        let result = new BVC_PAAP_Description_Date();
        result.init(json);
        return result;
    }
}

export interface IBVC_PAAP_Description_Date {
    bvC_PAAP_Id: number;
    descriere: string | undefined;
    dataEnd: moment.Moment;
    rest: number;
}

export class InvoiceDetailPAAPWithInvoiceElementsDto implements IInvoiceDetailPAAPWithInvoiceElementsDto {
    id: number;
    thirdPartyAccount: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    detailValue: number;
    detailValueLocalCurr: number | undefined;
    detailDescription: string | undefined;
    selected: boolean;
    invoiceElementsDetailsId: number;
    possiblePaap: BVC_PAAP_Description_Date[] | undefined;

    constructor(data?: IInvoiceDetailPAAPWithInvoiceElementsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.thirdPartyAccount = _data["thirdPartyAccount"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceSeries = _data["invoiceSeries"];
            this.value = _data["value"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.detailValue = _data["detailValue"];
            this.detailValueLocalCurr = _data["detailValueLocalCurr"];
            this.detailDescription = _data["detailDescription"];
            this.selected = _data["selected"];
            this.invoiceElementsDetailsId = _data["invoiceElementsDetailsId"];
            if (Array.isArray(_data["possiblePaap"])) {
                this.possiblePaap = [] as any;
                for (let item of _data["possiblePaap"])
                    this.possiblePaap.push(BVC_PAAP_Description_Date.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceDetailPAAPWithInvoiceElementsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetailPAAPWithInvoiceElementsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["thirdPartyAccount"] = this.thirdPartyAccount;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceSeries"] = this.invoiceSeries;
        data["value"] = this.value;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["detailValue"] = this.detailValue;
        data["detailValueLocalCurr"] = this.detailValueLocalCurr;
        data["detailDescription"] = this.detailDescription;
        data["selected"] = this.selected;
        data["invoiceElementsDetailsId"] = this.invoiceElementsDetailsId;
        if (Array.isArray(this.possiblePaap)) {
            data["possiblePaap"] = [];
            for (let item of this.possiblePaap)
                data["possiblePaap"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvoiceDetailPAAPWithInvoiceElementsDto {
        const json = this.toJSON();
        let result = new InvoiceDetailPAAPWithInvoiceElementsDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetailPAAPWithInvoiceElementsDto {
    id: number;
    thirdPartyAccount: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    value: number;
    currencyId: number;
    currencyName: string | undefined;
    detailValue: number;
    detailValueLocalCurr: number | undefined;
    detailDescription: string | undefined;
    selected: boolean;
    invoiceElementsDetailsId: number;
    possiblePaap: BVC_PAAP_Description_Date[] | undefined;
}

export class PaapPierdeDto implements IPaapPierdeDto {
    paapPierdeId: number;
    denumire: string | undefined;
    categorieId: number;
    valoareDisponibila: number;
    valoareRedistribuita: number;

    constructor(data?: IPaapPierdeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paapPierdeId = _data["paapPierdeId"];
            this.denumire = _data["denumire"];
            this.categorieId = _data["categorieId"];
            this.valoareDisponibila = _data["valoareDisponibila"];
            this.valoareRedistribuita = _data["valoareRedistribuita"];
        }
    }

    static fromJS(data: any): PaapPierdeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapPierdeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paapPierdeId"] = this.paapPierdeId;
        data["denumire"] = this.denumire;
        data["categorieId"] = this.categorieId;
        data["valoareDisponibila"] = this.valoareDisponibila;
        data["valoareRedistribuita"] = this.valoareRedistribuita;
        return data;
    }

    clone(): PaapPierdeDto {
        const json = this.toJSON();
        let result = new PaapPierdeDto();
        result.init(json);
        return result;
    }
}

export interface IPaapPierdeDto {
    paapPierdeId: number;
    denumire: string | undefined;
    categorieId: number;
    valoareDisponibila: number;
    valoareRedistribuita: number;
}

export class PaapPrimesteDto implements IPaapPrimesteDto {
    id: number;
    paapPrimesteId: number;
    denumire: string | undefined;
    categorieId: number;
    sumaPrimita: number;
    valoareInitiala: number;

    constructor(data?: IPaapPrimesteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paapPrimesteId = _data["paapPrimesteId"];
            this.denumire = _data["denumire"];
            this.categorieId = _data["categorieId"];
            this.sumaPrimita = _data["sumaPrimita"];
            this.valoareInitiala = _data["valoareInitiala"];
        }
    }

    static fromJS(data: any): PaapPrimesteDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapPrimesteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paapPrimesteId"] = this.paapPrimesteId;
        data["denumire"] = this.denumire;
        data["categorieId"] = this.categorieId;
        data["sumaPrimita"] = this.sumaPrimita;
        data["valoareInitiala"] = this.valoareInitiala;
        return data;
    }

    clone(): PaapPrimesteDto {
        const json = this.toJSON();
        let result = new PaapPrimesteDto();
        result.init(json);
        return result;
    }
}

export interface IPaapPrimesteDto {
    id: number;
    paapPrimesteId: number;
    denumire: string | undefined;
    categorieId: number;
    sumaPrimita: number;
    valoareInitiala: number;
}

export class PaapRedistribuireDetaliiDto implements IPaapRedistribuireDetaliiDto {
    paapRedistribuireId: number | undefined;
    paapCarePierdeId: number;
    denumire: string | undefined;
    sumaPierduta: number;

    constructor(data?: IPaapRedistribuireDetaliiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paapRedistribuireId = _data["paapRedistribuireId"];
            this.paapCarePierdeId = _data["paapCarePierdeId"];
            this.denumire = _data["denumire"];
            this.sumaPierduta = _data["sumaPierduta"];
        }
    }

    static fromJS(data: any): PaapRedistribuireDetaliiDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapRedistribuireDetaliiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paapRedistribuireId"] = this.paapRedistribuireId;
        data["paapCarePierdeId"] = this.paapCarePierdeId;
        data["denumire"] = this.denumire;
        data["sumaPierduta"] = this.sumaPierduta;
        return data;
    }

    clone(): PaapRedistribuireDetaliiDto {
        const json = this.toJSON();
        let result = new PaapRedistribuireDetaliiDto();
        result.init(json);
        return result;
    }
}

export interface IPaapRedistribuireDetaliiDto {
    paapRedistribuireId: number | undefined;
    paapCarePierdeId: number;
    denumire: string | undefined;
    sumaPierduta: number;
}

export class PaapRedistribuireDto implements IPaapRedistribuireDto {
    id: number;
    paapPrimesteId: number;
    denumire: string | undefined;
    categorieId: number;
    sumaPrimita: number;
    valoareInitiala: number;
    paapRedistribuireDetaliiList: PaapRedistribuireDetaliiDto[] | undefined;

    constructor(data?: IPaapRedistribuireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paapPrimesteId = _data["paapPrimesteId"];
            this.denumire = _data["denumire"];
            this.categorieId = _data["categorieId"];
            this.sumaPrimita = _data["sumaPrimita"];
            this.valoareInitiala = _data["valoareInitiala"];
            if (Array.isArray(_data["paapRedistribuireDetaliiList"])) {
                this.paapRedistribuireDetaliiList = [] as any;
                for (let item of _data["paapRedistribuireDetaliiList"])
                    this.paapRedistribuireDetaliiList.push(PaapRedistribuireDetaliiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaapRedistribuireDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapRedistribuireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paapPrimesteId"] = this.paapPrimesteId;
        data["denumire"] = this.denumire;
        data["categorieId"] = this.categorieId;
        data["sumaPrimita"] = this.sumaPrimita;
        data["valoareInitiala"] = this.valoareInitiala;
        if (Array.isArray(this.paapRedistribuireDetaliiList)) {
            data["paapRedistribuireDetaliiList"] = [];
            for (let item of this.paapRedistribuireDetaliiList)
                data["paapRedistribuireDetaliiList"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaapRedistribuireDto {
        const json = this.toJSON();
        let result = new PaapRedistribuireDto();
        result.init(json);
        return result;
    }
}

export interface IPaapRedistribuireDto {
    id: number;
    paapPrimesteId: number;
    denumire: string | undefined;
    categorieId: number;
    sumaPrimita: number;
    valoareInitiala: number;
    paapRedistribuireDetaliiList: PaapRedistribuireDetaliiDto[] | undefined;
}

export class PaapRedistribuireListDto implements IPaapRedistribuireListDto {
    id: number;
    dataRedistribuire: moment.Moment;
    denumireAchizitie: string | undefined;
    numeCompartiment: string | undefined;
    numeCategorie: string | undefined;
    sumaPrimita: number;

    constructor(data?: IPaapRedistribuireListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataRedistribuire = _data["dataRedistribuire"] ? moment(_data["dataRedistribuire"].toString()) : <any>undefined;
            this.denumireAchizitie = _data["denumireAchizitie"];
            this.numeCompartiment = _data["numeCompartiment"];
            this.numeCategorie = _data["numeCategorie"];
            this.sumaPrimita = _data["sumaPrimita"];
        }
    }

    static fromJS(data: any): PaapRedistribuireListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapRedistribuireListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataRedistribuire"] = this.dataRedistribuire ? this.dataRedistribuire.toISOString() : <any>undefined;
        data["denumireAchizitie"] = this.denumireAchizitie;
        data["numeCompartiment"] = this.numeCompartiment;
        data["numeCategorie"] = this.numeCategorie;
        data["sumaPrimita"] = this.sumaPrimita;
        return data;
    }

    clone(): PaapRedistribuireListDto {
        const json = this.toJSON();
        let result = new PaapRedistribuireListDto();
        result.init(json);
        return result;
    }
}

export interface IPaapRedistribuireListDto {
    id: number;
    dataRedistribuire: moment.Moment;
    denumireAchizitie: string | undefined;
    numeCompartiment: string | undefined;
    numeCategorie: string | undefined;
    sumaPrimita: number;
}

export class PaapReferatEditDto implements IPaapReferatEditDto {
    id: number;
    bvC_PAAP_Id: number;
    tenantId: number;
    name: string | undefined;
    operationDate: moment.Moment;
    suma: number;
    state: State;

    constructor(data?: IPaapReferatEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bvC_PAAP_Id = _data["bvC_PAAP_Id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.suma = _data["suma"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): PaapReferatEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapReferatEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bvC_PAAP_Id"] = this.bvC_PAAP_Id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["suma"] = this.suma;
        data["state"] = this.state;
        return data;
    }

    clone(): PaapReferatEditDto {
        const json = this.toJSON();
        let result = new PaapReferatEditDto();
        result.init(json);
        return result;
    }
}

export interface IPaapReferatEditDto {
    id: number;
    bvC_PAAP_Id: number;
    tenantId: number;
    name: string | undefined;
    operationDate: moment.Moment;
    suma: number;
    state: State;
}

export class PaapReferatDto implements IPaapReferatDto {
    id: number;
    tenantId: number;
    suma: number;
    name: string | undefined;
    operationDate: moment.Moment;
    state: State;

    constructor(data?: IPaapReferatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.suma = _data["suma"];
            this.name = _data["name"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): PaapReferatDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaapReferatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["suma"] = this.suma;
        data["name"] = this.name;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["state"] = this.state;
        return data;
    }

    clone(): PaapReferatDto {
        const json = this.toJSON();
        let result = new PaapReferatDto();
        result.init(json);
        return result;
    }
}

export interface IPaapReferatDto {
    id: number;
    tenantId: number;
    suma: number;
    name: string | undefined;
    operationDate: moment.Moment;
    state: State;
}

export class PayementOrdersList implements IPayementOrdersList {
    id: number;
    orderNr: number;
    orderDate: moment.Moment;
    value: number;
    payerBank: string | undefined;
    payerBankAccount: string | undefined;
    benefId1: string | undefined;
    beneficiary: string | undefined;
    benefBank: string | undefined;
    benefBankAccount: string | undefined;
    currency: string | undefined;
    invoice: string | undefined;
    paymentDetails: string | undefined;
    finalised: boolean;
    finalisedDb: boolean;

    constructor(data?: IPayementOrdersList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNr = _data["orderNr"];
            this.orderDate = _data["orderDate"] ? moment(_data["orderDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.payerBank = _data["payerBank"];
            this.payerBankAccount = _data["payerBankAccount"];
            this.benefId1 = _data["benefId1"];
            this.beneficiary = _data["beneficiary"];
            this.benefBank = _data["benefBank"];
            this.benefBankAccount = _data["benefBankAccount"];
            this.currency = _data["currency"];
            this.invoice = _data["invoice"];
            this.paymentDetails = _data["paymentDetails"];
            this.finalised = _data["finalised"];
            this.finalisedDb = _data["finalisedDb"];
        }
    }

    static fromJS(data: any): PayementOrdersList {
        data = typeof data === 'object' ? data : {};
        let result = new PayementOrdersList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNr"] = this.orderNr;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["payerBank"] = this.payerBank;
        data["payerBankAccount"] = this.payerBankAccount;
        data["benefId1"] = this.benefId1;
        data["beneficiary"] = this.beneficiary;
        data["benefBank"] = this.benefBank;
        data["benefBankAccount"] = this.benefBankAccount;
        data["currency"] = this.currency;
        data["invoice"] = this.invoice;
        data["paymentDetails"] = this.paymentDetails;
        data["finalised"] = this.finalised;
        data["finalisedDb"] = this.finalisedDb;
        return data;
    }

    clone(): PayementOrdersList {
        const json = this.toJSON();
        let result = new PayementOrdersList();
        result.init(json);
        return result;
    }
}

export interface IPayementOrdersList {
    id: number;
    orderNr: number;
    orderDate: moment.Moment;
    value: number;
    payerBank: string | undefined;
    payerBankAccount: string | undefined;
    benefId1: string | undefined;
    beneficiary: string | undefined;
    benefBank: string | undefined;
    benefBankAccount: string | undefined;
    currency: string | undefined;
    invoice: string | undefined;
    paymentDetails: string | undefined;
    finalised: boolean;
    finalisedDb: boolean;
}

export class PayementOrderDetail implements IPayementOrderDetail {
    id: number;
    orderNr: number;
    orderDate: moment.Moment;
    value: number;
    writtenValue: string | undefined;
    payerBankId: number | undefined;
    payerBankAccountId: number | undefined;
    beneficiaryId: number | undefined;
    beneficiaryName: string | undefined;
    benefBankId: number | undefined;
    benefBankAccountId: number | undefined;
    currencyId: number | undefined;
    invoicesList: InvoiceListSelectableDto[] | undefined;
    paymentDetails: string | undefined;
    finalised: OperationStatus;

    constructor(data?: IPayementOrderDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNr = _data["orderNr"];
            this.orderDate = _data["orderDate"] ? moment(_data["orderDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.writtenValue = _data["writtenValue"];
            this.payerBankId = _data["payerBankId"];
            this.payerBankAccountId = _data["payerBankAccountId"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.beneficiaryName = _data["beneficiaryName"];
            this.benefBankId = _data["benefBankId"];
            this.benefBankAccountId = _data["benefBankAccountId"];
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["invoicesList"])) {
                this.invoicesList = [] as any;
                for (let item of _data["invoicesList"])
                    this.invoicesList.push(InvoiceListSelectableDto.fromJS(item));
            }
            this.paymentDetails = _data["paymentDetails"];
            this.finalised = _data["finalised"];
        }
    }

    static fromJS(data: any): PayementOrderDetail {
        data = typeof data === 'object' ? data : {};
        let result = new PayementOrderDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNr"] = this.orderNr;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["writtenValue"] = this.writtenValue;
        data["payerBankId"] = this.payerBankId;
        data["payerBankAccountId"] = this.payerBankAccountId;
        data["beneficiaryId"] = this.beneficiaryId;
        data["beneficiaryName"] = this.beneficiaryName;
        data["benefBankId"] = this.benefBankId;
        data["benefBankAccountId"] = this.benefBankAccountId;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.invoicesList)) {
            data["invoicesList"] = [];
            for (let item of this.invoicesList)
                data["invoicesList"].push(item.toJSON());
        }
        data["paymentDetails"] = this.paymentDetails;
        data["finalised"] = this.finalised;
        return data;
    }

    clone(): PayementOrderDetail {
        const json = this.toJSON();
        let result = new PayementOrderDetail();
        result.init(json);
        return result;
    }
}

export interface IPayementOrderDetail {
    id: number;
    orderNr: number;
    orderDate: moment.Moment;
    value: number;
    writtenValue: string | undefined;
    payerBankId: number | undefined;
    payerBankAccountId: number | undefined;
    beneficiaryId: number | undefined;
    beneficiaryName: string | undefined;
    benefBankId: number | undefined;
    benefBankAccountId: number | undefined;
    currencyId: number | undefined;
    invoicesList: InvoiceListSelectableDto[] | undefined;
    paymentDetails: string | undefined;
    finalised: OperationStatus;
}

export class PayementOrdersForm implements IPayementOrdersForm {
    searchStartDate: moment.Moment;
    searchEndDate: moment.Moment;
    payerId: number;
    payerBankId: number | undefined;
    thirdPartyId: number | undefined;
    opList: PayementOrdersList[] | undefined;
    opDetail: PayementOrderDetail;
    showList: boolean;
    showEditForm: boolean;
    appClientId: number;

    constructor(data?: IPayementOrdersForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchStartDate = _data["searchStartDate"] ? moment(_data["searchStartDate"].toString()) : <any>undefined;
            this.searchEndDate = _data["searchEndDate"] ? moment(_data["searchEndDate"].toString()) : <any>undefined;
            this.payerId = _data["payerId"];
            this.payerBankId = _data["payerBankId"];
            this.thirdPartyId = _data["thirdPartyId"];
            if (Array.isArray(_data["opList"])) {
                this.opList = [] as any;
                for (let item of _data["opList"])
                    this.opList.push(PayementOrdersList.fromJS(item));
            }
            this.opDetail = _data["opDetail"] ? PayementOrderDetail.fromJS(_data["opDetail"]) : <any>undefined;
            this.showList = _data["showList"];
            this.showEditForm = _data["showEditForm"];
            this.appClientId = _data["appClientId"];
        }
    }

    static fromJS(data: any): PayementOrdersForm {
        data = typeof data === 'object' ? data : {};
        let result = new PayementOrdersForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchStartDate"] = this.searchStartDate ? this.searchStartDate.toISOString() : <any>undefined;
        data["searchEndDate"] = this.searchEndDate ? this.searchEndDate.toISOString() : <any>undefined;
        data["payerId"] = this.payerId;
        data["payerBankId"] = this.payerBankId;
        data["thirdPartyId"] = this.thirdPartyId;
        if (Array.isArray(this.opList)) {
            data["opList"] = [];
            for (let item of this.opList)
                data["opList"].push(item.toJSON());
        }
        data["opDetail"] = this.opDetail ? this.opDetail.toJSON() : <any>undefined;
        data["showList"] = this.showList;
        data["showEditForm"] = this.showEditForm;
        data["appClientId"] = this.appClientId;
        return data;
    }

    clone(): PayementOrdersForm {
        const json = this.toJSON();
        let result = new PayementOrdersForm();
        result.init(json);
        return result;
    }
}

export interface IPayementOrdersForm {
    searchStartDate: moment.Moment;
    searchEndDate: moment.Moment;
    payerId: number;
    payerBankId: number | undefined;
    thirdPartyId: number | undefined;
    opList: PayementOrdersList[] | undefined;
    opDetail: PayementOrderDetail;
    showList: boolean;
    showEditForm: boolean;
    appClientId: number;
}

export class PaymentOrderExportList implements IPaymentOrderExportList {
    id: number;
    orderNr: number;
    orderDate: moment.Moment;
    value: number;
    payerBank: string | undefined;
    payerBankAccount: string | undefined;
    benefId1: string | undefined;
    beneficiary: string | undefined;
    benefBank: string | undefined;
    benefBankAccount: string | undefined;
    benefBankBic: string | undefined;
    currency: string | undefined;
    invoice: string | undefined;
    paymentDetails: string | undefined;
    finalised: boolean;
    finalisedDb: boolean;
    selected: boolean;

    constructor(data?: IPaymentOrderExportList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNr = _data["orderNr"];
            this.orderDate = _data["orderDate"] ? moment(_data["orderDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.payerBank = _data["payerBank"];
            this.payerBankAccount = _data["payerBankAccount"];
            this.benefId1 = _data["benefId1"];
            this.beneficiary = _data["beneficiary"];
            this.benefBank = _data["benefBank"];
            this.benefBankAccount = _data["benefBankAccount"];
            this.benefBankBic = _data["benefBankBic"];
            this.currency = _data["currency"];
            this.invoice = _data["invoice"];
            this.paymentDetails = _data["paymentDetails"];
            this.finalised = _data["finalised"];
            this.finalisedDb = _data["finalisedDb"];
            this.selected = _data["selected"];
        }
    }

    static fromJS(data: any): PaymentOrderExportList {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentOrderExportList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNr"] = this.orderNr;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["payerBank"] = this.payerBank;
        data["payerBankAccount"] = this.payerBankAccount;
        data["benefId1"] = this.benefId1;
        data["beneficiary"] = this.beneficiary;
        data["benefBank"] = this.benefBank;
        data["benefBankAccount"] = this.benefBankAccount;
        data["benefBankBic"] = this.benefBankBic;
        data["currency"] = this.currency;
        data["invoice"] = this.invoice;
        data["paymentDetails"] = this.paymentDetails;
        data["finalised"] = this.finalised;
        data["finalisedDb"] = this.finalisedDb;
        data["selected"] = this.selected;
        return data;
    }

    clone(): PaymentOrderExportList {
        const json = this.toJSON();
        let result = new PaymentOrderExportList();
        result.init(json);
        return result;
    }
}

export interface IPaymentOrderExportList {
    id: number;
    orderNr: number;
    orderDate: moment.Moment;
    value: number;
    payerBank: string | undefined;
    payerBankAccount: string | undefined;
    benefId1: string | undefined;
    beneficiary: string | undefined;
    benefBank: string | undefined;
    benefBankAccount: string | undefined;
    benefBankBic: string | undefined;
    currency: string | undefined;
    invoice: string | undefined;
    paymentDetails: string | undefined;
    finalised: boolean;
    finalisedDb: boolean;
    selected: boolean;
}

export class BTExport implements IBTExport {
    orderNumber: number;
    sourceAccountNumber: string | undefined;
    targetAccountNumber: string | undefined;
    beneficiaryName: string | undefined;
    beneficiaryBankBIC: string | undefined;
    beneficiaryFiscalCode: string | undefined;
    amount: number;
    paymentRef1: string | undefined;
    paymentRef2: string | undefined;
    valueDate: moment.Moment;
    urgent: string | undefined;

    constructor(data?: IBTExport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNumber = _data["orderNumber"];
            this.sourceAccountNumber = _data["sourceAccountNumber"];
            this.targetAccountNumber = _data["targetAccountNumber"];
            this.beneficiaryName = _data["beneficiaryName"];
            this.beneficiaryBankBIC = _data["beneficiaryBankBIC"];
            this.beneficiaryFiscalCode = _data["beneficiaryFiscalCode"];
            this.amount = _data["amount"];
            this.paymentRef1 = _data["paymentRef1"];
            this.paymentRef2 = _data["paymentRef2"];
            this.valueDate = _data["valueDate"] ? moment(_data["valueDate"].toString()) : <any>undefined;
            this.urgent = _data["urgent"];
        }
    }

    static fromJS(data: any): BTExport {
        data = typeof data === 'object' ? data : {};
        let result = new BTExport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNumber"] = this.orderNumber;
        data["sourceAccountNumber"] = this.sourceAccountNumber;
        data["targetAccountNumber"] = this.targetAccountNumber;
        data["beneficiaryName"] = this.beneficiaryName;
        data["beneficiaryBankBIC"] = this.beneficiaryBankBIC;
        data["beneficiaryFiscalCode"] = this.beneficiaryFiscalCode;
        data["amount"] = this.amount;
        data["paymentRef1"] = this.paymentRef1;
        data["paymentRef2"] = this.paymentRef2;
        data["valueDate"] = this.valueDate ? this.valueDate.toISOString() : <any>undefined;
        data["urgent"] = this.urgent;
        return data;
    }

    clone(): BTExport {
        const json = this.toJSON();
        let result = new BTExport();
        result.init(json);
        return result;
    }
}

export interface IBTExport {
    orderNumber: number;
    sourceAccountNumber: string | undefined;
    targetAccountNumber: string | undefined;
    beneficiaryName: string | undefined;
    beneficiaryBankBIC: string | undefined;
    beneficiaryFiscalCode: string | undefined;
    amount: number;
    paymentRef1: string | undefined;
    paymentRef2: string | undefined;
    valueDate: moment.Moment;
    urgent: string | undefined;
}

export class GetThirdPartyAccOutput implements IGetThirdPartyAccOutput {
    getThirdPartyAcc: ThirdPartyAccListDto[] | undefined;

    constructor(data?: IGetThirdPartyAccOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getThirdPartyAcc"])) {
                this.getThirdPartyAcc = [] as any;
                for (let item of _data["getThirdPartyAcc"])
                    this.getThirdPartyAcc.push(ThirdPartyAccListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetThirdPartyAccOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetThirdPartyAccOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getThirdPartyAcc)) {
            data["getThirdPartyAcc"] = [];
            for (let item of this.getThirdPartyAcc)
                data["getThirdPartyAcc"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetThirdPartyAccOutput {
        const json = this.toJSON();
        let result = new GetThirdPartyAccOutput();
        result.init(json);
        return result;
    }
}

export interface IGetThirdPartyAccOutput {
    getThirdPartyAcc: ThirdPartyAccListDto[] | undefined;
}

export class ThirdPartyAccEditDto implements IThirdPartyAccEditDto {
    id: number;
    iban: string | undefined;
    bankId: number;
    thirdPartyId: number;
    currencyId: number;

    constructor(data?: IThirdPartyAccEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.iban = _data["iban"];
            this.bankId = _data["bankId"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.currencyId = _data["currencyId"];
        }
    }

    static fromJS(data: any): ThirdPartyAccEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThirdPartyAccEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["iban"] = this.iban;
        data["bankId"] = this.bankId;
        data["thirdPartyId"] = this.thirdPartyId;
        data["currencyId"] = this.currencyId;
        return data;
    }

    clone(): ThirdPartyAccEditDto {
        const json = this.toJSON();
        let result = new ThirdPartyAccEditDto();
        result.init(json);
        return result;
    }
}

export interface IThirdPartyAccEditDto {
    id: number;
    iban: string | undefined;
    bankId: number;
    thirdPartyId: number;
    currencyId: number;
}

export class Found implements IFound {
    cui: number;
    denumire: string | undefined;
    data: string | undefined;
    adresa: string | undefined;
    nrRegCom: string | undefined;
    scpTVA: boolean;
    data_inceput_ScpTVA: string | undefined;
    statusTvaIncasare: boolean;

    constructor(data?: IFound) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cui = _data["cui"];
            this.denumire = _data["denumire"];
            this.data = _data["data"];
            this.adresa = _data["adresa"];
            this.nrRegCom = _data["nrRegCom"];
            this.scpTVA = _data["scpTVA"];
            this.data_inceput_ScpTVA = _data["data_inceput_ScpTVA"];
            this.statusTvaIncasare = _data["statusTvaIncasare"];
        }
    }

    static fromJS(data: any): Found {
        data = typeof data === 'object' ? data : {};
        let result = new Found();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cui"] = this.cui;
        data["denumire"] = this.denumire;
        data["data"] = this.data;
        data["adresa"] = this.adresa;
        data["nrRegCom"] = this.nrRegCom;
        data["scpTVA"] = this.scpTVA;
        data["data_inceput_ScpTVA"] = this.data_inceput_ScpTVA;
        data["statusTvaIncasare"] = this.statusTvaIncasare;
        return data;
    }

    clone(): Found {
        const json = this.toJSON();
        let result = new Found();
        result.init(json);
        return result;
    }
}

export interface IFound {
    cui: number;
    denumire: string | undefined;
    data: string | undefined;
    adresa: string | undefined;
    nrRegCom: string | undefined;
    scpTVA: boolean;
    data_inceput_ScpTVA: string | undefined;
    statusTvaIncasare: boolean;
}

export class DateFirmaAnaf implements IDateFirmaAnaf {
    found: Found[] | undefined;

    constructor(data?: IDateFirmaAnaf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["found"])) {
                this.found = [] as any;
                for (let item of _data["found"])
                    this.found.push(Found.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DateFirmaAnaf {
        data = typeof data === 'object' ? data : {};
        let result = new DateFirmaAnaf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.found)) {
            data["found"] = [];
            for (let item of this.found)
                data["found"].push(item.toJSON());
        }
        return data;
    }

    clone(): DateFirmaAnaf {
        const json = this.toJSON();
        let result = new DateFirmaAnaf();
        result.init(json);
        return result;
    }
}

export interface IDateFirmaAnaf {
    found: Found[] | undefined;
}

export class PersonListDto implements IPersonListDto {
    id: number;
    id1: string | undefined;
    id2: string | undefined;
    fullName: string | undefined;
    isEmployee: boolean;
    idPersonal: number;

    constructor(data?: IPersonListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.id1 = _data["id1"];
            this.id2 = _data["id2"];
            this.fullName = _data["fullName"];
            this.isEmployee = _data["isEmployee"];
            this.idPersonal = _data["idPersonal"];
        }
    }

    static fromJS(data: any): PersonListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["id1"] = this.id1;
        data["id2"] = this.id2;
        data["fullName"] = this.fullName;
        data["isEmployee"] = this.isEmployee;
        data["idPersonal"] = this.idPersonal;
        return data;
    }

    clone(): PersonListDto {
        const json = this.toJSON();
        let result = new PersonListDto();
        result.init(json);
        return result;
    }
}

export interface IPersonListDto {
    id: number;
    id1: string | undefined;
    id2: string | undefined;
    fullName: string | undefined;
    isEmployee: boolean;
    idPersonal: number;
}

export class BankListDto implements IBankListDto {
    id: number;
    ibanAbrv: string | undefined;
    bic: string | undefined;
    bankName: string | undefined;
    issuerId: number;

    constructor(data?: IBankListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ibanAbrv = _data["ibanAbrv"];
            this.bic = _data["bic"];
            this.bankName = _data["bankName"];
            this.issuerId = _data["issuerId"];
        }
    }

    static fromJS(data: any): BankListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ibanAbrv"] = this.ibanAbrv;
        data["bic"] = this.bic;
        data["bankName"] = this.bankName;
        data["issuerId"] = this.issuerId;
        return data;
    }

    clone(): BankListDto {
        const json = this.toJSON();
        let result = new BankListDto();
        result.init(json);
        return result;
    }
}

export interface IBankListDto {
    id: number;
    ibanAbrv: string | undefined;
    bic: string | undefined;
    bankName: string | undefined;
    issuerId: number;
}

export class GetBankOutput implements IGetBankOutput {
    getBank: BankListDto[] | undefined;

    constructor(data?: IGetBankOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getBank"])) {
                this.getBank = [] as any;
                for (let item of _data["getBank"])
                    this.getBank.push(BankListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetBankOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBankOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getBank)) {
            data["getBank"] = [];
            for (let item of this.getBank)
                data["getBank"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetBankOutput {
        const json = this.toJSON();
        let result = new GetBankOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBankOutput {
    getBank: BankListDto[] | undefined;
}

export class GetPersonOutput implements IGetPersonOutput {
    getPerson: PersonListDto[] | undefined;

    constructor(data?: IGetPersonOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getPerson"])) {
                this.getPerson = [] as any;
                for (let item of _data["getPerson"])
                    this.getPerson.push(PersonListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPersonOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPersonOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getPerson)) {
            data["getPerson"] = [];
            for (let item of this.getPerson)
                data["getPerson"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetPersonOutput {
        const json = this.toJSON();
        let result = new GetPersonOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPersonOutput {
    getPerson: PersonListDto[] | undefined;
}

export class CreatePersonDto implements ICreatePersonDto {

    constructor(data?: ICreatePersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CreatePersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): CreatePersonDto {
        const json = this.toJSON();
        let result = new CreatePersonDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePersonDto {
}

export class CurrencyListDto implements ICurrencyListDto {
    id: number;
    currencyCode: string | undefined;
    currencyName: string | undefined;
    status: number;

    constructor(data?: ICurrencyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyCode = _data["currencyCode"];
            this.currencyName = _data["currencyName"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CurrencyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyCode"] = this.currencyCode;
        data["currencyName"] = this.currencyName;
        data["status"] = this.status;
        return data;
    }

    clone(): CurrencyListDto {
        const json = this.toJSON();
        let result = new CurrencyListDto();
        result.init(json);
        return result;
    }
}

export interface ICurrencyListDto {
    id: number;
    currencyCode: string | undefined;
    currencyName: string | undefined;
    status: number;
}

export class GetCurrencyOutput implements IGetCurrencyOutput {
    getCurrency: CurrencyListDto[] | undefined;

    constructor(data?: IGetCurrencyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getCurrency"])) {
                this.getCurrency = [] as any;
                for (let item of _data["getCurrency"])
                    this.getCurrency.push(CurrencyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCurrencyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrencyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getCurrency)) {
            data["getCurrency"] = [];
            for (let item of this.getCurrency)
                data["getCurrency"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetCurrencyOutput {
        const json = this.toJSON();
        let result = new GetCurrencyOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrencyOutput {
    getCurrency: CurrencyListDto[] | undefined;
}

export class CountryListDto implements ICountryListDto {
    id: number;
    countryName: string | undefined;

    constructor(data?: ICountryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): CountryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryName"] = this.countryName;
        return data;
    }

    clone(): CountryListDto {
        const json = this.toJSON();
        let result = new CountryListDto();
        result.init(json);
        return result;
    }
}

export interface ICountryListDto {
    id: number;
    countryName: string | undefined;
}

export class GetCountryOutput implements IGetCountryOutput {
    getCountry: CountryListDto[] | undefined;

    constructor(data?: IGetCountryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getCountry"])) {
                this.getCountry = [] as any;
                for (let item of _data["getCountry"])
                    this.getCountry.push(CountryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCountryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getCountry)) {
            data["getCountry"] = [];
            for (let item of this.getCountry)
                data["getCountry"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetCountryOutput {
        const json = this.toJSON();
        let result = new GetCountryOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCountryOutput {
    getCountry: CountryListDto[] | undefined;
}

export class RegionListDto implements IRegionListDto {
    id: number;
    regionName: string | undefined;
    country: string | undefined;

    constructor(data?: IRegionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.regionName = _data["regionName"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): RegionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["regionName"] = this.regionName;
        data["country"] = this.country;
        return data;
    }

    clone(): RegionListDto {
        const json = this.toJSON();
        let result = new RegionListDto();
        result.init(json);
        return result;
    }
}

export interface IRegionListDto {
    id: number;
    regionName: string | undefined;
    country: string | undefined;
}

export class GetRegionOutput implements IGetRegionOutput {
    getRegion: RegionListDto[] | undefined;

    constructor(data?: IGetRegionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getRegion"])) {
                this.getRegion = [] as any;
                for (let item of _data["getRegion"])
                    this.getRegion.push(RegionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getRegion)) {
            data["getRegion"] = [];
            for (let item of this.getRegion)
                data["getRegion"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetRegionOutput {
        const json = this.toJSON();
        let result = new GetRegionOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRegionOutput {
    getRegion: RegionListDto[] | undefined;
}

export class ThirdPartyListDto implements IThirdPartyListDto {
    personId: number;
    isClient: boolean;
    isProvider: boolean;
    isOther: boolean;
    fullName: string | undefined;

    constructor(data?: IThirdPartyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personId = _data["personId"];
            this.isClient = _data["isClient"];
            this.isProvider = _data["isProvider"];
            this.isOther = _data["isOther"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): ThirdPartyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThirdPartyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["isClient"] = this.isClient;
        data["isProvider"] = this.isProvider;
        data["isOther"] = this.isOther;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): ThirdPartyListDto {
        const json = this.toJSON();
        let result = new ThirdPartyListDto();
        result.init(json);
        return result;
    }
}

export interface IThirdPartyListDto {
    personId: number;
    isClient: boolean;
    isProvider: boolean;
    isOther: boolean;
    fullName: string | undefined;
}

export class GetThirdPartyOutput implements IGetThirdPartyOutput {
    getThirdParty: ThirdPartyListDto[] | undefined;

    constructor(data?: IGetThirdPartyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getThirdParty"])) {
                this.getThirdParty = [] as any;
                for (let item of _data["getThirdParty"])
                    this.getThirdParty.push(ThirdPartyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetThirdPartyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetThirdPartyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getThirdParty)) {
            data["getThirdParty"] = [];
            for (let item of this.getThirdParty)
                data["getThirdParty"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetThirdPartyOutput {
        const json = this.toJSON();
        let result = new GetThirdPartyOutput();
        result.init(json);
        return result;
    }
}

export interface IGetThirdPartyOutput {
    getThirdParty: ThirdPartyListDto[] | undefined;
}

export class ThirdPartyAccListDDDto implements IThirdPartyAccListDDDto {
    id: number;
    account: string | undefined;

    constructor(data?: IThirdPartyAccListDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.account = _data["account"];
        }
    }

    static fromJS(data: any): ThirdPartyAccListDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThirdPartyAccListDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["account"] = this.account;
        return data;
    }

    clone(): ThirdPartyAccListDDDto {
        const json = this.toJSON();
        let result = new ThirdPartyAccListDDDto();
        result.init(json);
        return result;
    }
}

export interface IThirdPartyAccListDDDto {
    id: number;
    account: string | undefined;
}

export class PersonEditDto implements IPersonEditDto {
    id: number;
    id1: string | undefined;
    id2: string | undefined;
    addressStreet: string | undefined;
    addressNo: string | undefined;
    addressBlock: string | undefined;
    addressFloor: string | undefined;
    addressApartment: string | undefined;
    addressZipCode: string | undefined;
    addressLocality: string | undefined;
    definedById: number;
    addressRegionId: number | undefined;
    addressCountryId: number | undefined;
    name: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    personType: string | undefined;
    readonly isNaturalPerson: boolean;
    isVATPayer: boolean;
    startDateVATPayment: moment.Moment | undefined;
    isVATCollector: boolean;
    vatCollectedStartDate: moment.Moment | undefined;

    constructor(data?: IPersonEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.id1 = _data["id1"];
            this.id2 = _data["id2"];
            this.addressStreet = _data["addressStreet"];
            this.addressNo = _data["addressNo"];
            this.addressBlock = _data["addressBlock"];
            this.addressFloor = _data["addressFloor"];
            this.addressApartment = _data["addressApartment"];
            this.addressZipCode = _data["addressZipCode"];
            this.addressLocality = _data["addressLocality"];
            this.definedById = _data["definedById"];
            this.addressRegionId = _data["addressRegionId"];
            this.addressCountryId = _data["addressCountryId"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.personType = _data["personType"];
            (<any>this).isNaturalPerson = _data["isNaturalPerson"];
            this.isVATPayer = _data["isVATPayer"];
            this.startDateVATPayment = _data["startDateVATPayment"] ? moment(_data["startDateVATPayment"].toString()) : <any>undefined;
            this.isVATCollector = _data["isVATCollector"];
            this.vatCollectedStartDate = _data["vatCollectedStartDate"] ? moment(_data["vatCollectedStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PersonEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["id1"] = this.id1;
        data["id2"] = this.id2;
        data["addressStreet"] = this.addressStreet;
        data["addressNo"] = this.addressNo;
        data["addressBlock"] = this.addressBlock;
        data["addressFloor"] = this.addressFloor;
        data["addressApartment"] = this.addressApartment;
        data["addressZipCode"] = this.addressZipCode;
        data["addressLocality"] = this.addressLocality;
        data["definedById"] = this.definedById;
        data["addressRegionId"] = this.addressRegionId;
        data["addressCountryId"] = this.addressCountryId;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["personType"] = this.personType;
        data["isNaturalPerson"] = this.isNaturalPerson;
        data["isVATPayer"] = this.isVATPayer;
        data["startDateVATPayment"] = this.startDateVATPayment ? this.startDateVATPayment.toISOString() : <any>undefined;
        data["isVATCollector"] = this.isVATCollector;
        data["vatCollectedStartDate"] = this.vatCollectedStartDate ? this.vatCollectedStartDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): PersonEditDto {
        const json = this.toJSON();
        let result = new PersonEditDto();
        result.init(json);
        return result;
    }
}

export interface IPersonEditDto {
    id: number;
    id1: string | undefined;
    id2: string | undefined;
    addressStreet: string | undefined;
    addressNo: string | undefined;
    addressBlock: string | undefined;
    addressFloor: string | undefined;
    addressApartment: string | undefined;
    addressZipCode: string | undefined;
    addressLocality: string | undefined;
    definedById: number;
    addressRegionId: number | undefined;
    addressCountryId: number | undefined;
    name: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    personType: string | undefined;
    isNaturalPerson: boolean;
    isVATPayer: boolean;
    startDateVATPayment: moment.Moment | undefined;
    isVATCollector: boolean;
    vatCollectedStartDate: moment.Moment | undefined;
}

export class ExchangeRateDto implements IExchangeRateDto {
    id: number;
    exchangeDate: moment.Moment;
    currencyCode: string | undefined;
    currencyId: number | undefined;
    value: number;

    constructor(data?: IExchangeRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exchangeDate = _data["exchangeDate"] ? moment(_data["exchangeDate"].toString()) : <any>undefined;
            this.currencyCode = _data["currencyCode"];
            this.currencyId = _data["currencyId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExchangeRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exchangeDate"] = this.exchangeDate ? this.exchangeDate.toISOString() : <any>undefined;
        data["currencyCode"] = this.currencyCode;
        data["currencyId"] = this.currencyId;
        data["value"] = this.value;
        return data;
    }

    clone(): ExchangeRateDto {
        const json = this.toJSON();
        let result = new ExchangeRateDto();
        result.init(json);
        return result;
    }
}

export interface IExchangeRateDto {
    id: number;
    exchangeDate: moment.Moment;
    currencyCode: string | undefined;
    currencyId: number | undefined;
    value: number;
}

export class ExchangeRateModelDto implements IExchangeRateModelDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: number | undefined;
    exchangeList: ExchangeRateDto[] | undefined;

    constructor(data?: IExchangeRateModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["exchangeList"])) {
                this.exchangeList = [] as any;
                for (let item of _data["exchangeList"])
                    this.exchangeList.push(ExchangeRateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExchangeRateModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeRateModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.exchangeList)) {
            data["exchangeList"] = [];
            for (let item of this.exchangeList)
                data["exchangeList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExchangeRateModelDto {
        const json = this.toJSON();
        let result = new ExchangeRateModelDto();
        result.init(json);
        return result;
    }
}

export interface IExchangeRateModelDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: number | undefined;
    exchangeList: ExchangeRateDto[] | undefined;
}

export class BankAccountDto implements IBankAccountDto {
    id: number;
    bankId: number;
    iban: string | undefined;
    currency: string | undefined;

    constructor(data?: IBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankId = _data["bankId"];
            this.iban = _data["iban"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): BankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankId"] = this.bankId;
        data["iban"] = this.iban;
        data["currency"] = this.currency;
        return data;
    }

    clone(): BankAccountDto {
        const json = this.toJSON();
        let result = new BankAccountDto();
        result.init(json);
        return result;
    }
}

export interface IBankAccountDto {
    id: number;
    bankId: number;
    iban: string | undefined;
    currency: string | undefined;
}

export class PersonInitForm implements IPersonInitForm {
    id1: string | undefined;
    fullName: string | undefined;
    personList: PersonListDto[] | undefined;

    constructor(data?: IPersonInitForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id1 = _data["id1"];
            this.fullName = _data["fullName"];
            if (Array.isArray(_data["personList"])) {
                this.personList = [] as any;
                for (let item of _data["personList"])
                    this.personList.push(PersonListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonInitForm {
        data = typeof data === 'object' ? data : {};
        let result = new PersonInitForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id1"] = this.id1;
        data["fullName"] = this.fullName;
        if (Array.isArray(this.personList)) {
            data["personList"] = [];
            for (let item of this.personList)
                data["personList"].push(item.toJSON());
        }
        return data;
    }

    clone(): PersonInitForm {
        const json = this.toJSON();
        let result = new PersonInitForm();
        result.init(json);
        return result;
    }
}

export interface IPersonInitForm {
    id1: string | undefined;
    fullName: string | undefined;
    personList: PersonListDto[] | undefined;
}

export enum PrepaymentType {
    _0 = 0,
    _1 = 1,
}

export class PrepaymentsBalanceDetailListDto implements IPrepaymentsBalanceDetailListDto {
    id: number;
    prepayment: string | undefined;
    gestDate: moment.Moment;
    operType: string | undefined;
    tranzQuantity: number;
    quantity: number;
    tranzDuration: number;
    duration: number;
    tranzPaymentValue: number;
    paymentValue: number;
    tranzDeprec: number;
    deprec: number;
    tranzPaymentVAT: number;
    paymentVAT: number;
    tranzDeprecVAT: number;
    deprecVAT: number;

    constructor(data?: IPrepaymentsBalanceDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prepayment = _data["prepayment"];
            this.gestDate = _data["gestDate"] ? moment(_data["gestDate"].toString()) : <any>undefined;
            this.operType = _data["operType"];
            this.tranzQuantity = _data["tranzQuantity"];
            this.quantity = _data["quantity"];
            this.tranzDuration = _data["tranzDuration"];
            this.duration = _data["duration"];
            this.tranzPaymentValue = _data["tranzPaymentValue"];
            this.paymentValue = _data["paymentValue"];
            this.tranzDeprec = _data["tranzDeprec"];
            this.deprec = _data["deprec"];
            this.tranzPaymentVAT = _data["tranzPaymentVAT"];
            this.paymentVAT = _data["paymentVAT"];
            this.tranzDeprecVAT = _data["tranzDeprecVAT"];
            this.deprecVAT = _data["deprecVAT"];
        }
    }

    static fromJS(data: any): PrepaymentsBalanceDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsBalanceDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prepayment"] = this.prepayment;
        data["gestDate"] = this.gestDate ? this.gestDate.toISOString() : <any>undefined;
        data["operType"] = this.operType;
        data["tranzQuantity"] = this.tranzQuantity;
        data["quantity"] = this.quantity;
        data["tranzDuration"] = this.tranzDuration;
        data["duration"] = this.duration;
        data["tranzPaymentValue"] = this.tranzPaymentValue;
        data["paymentValue"] = this.paymentValue;
        data["tranzDeprec"] = this.tranzDeprec;
        data["deprec"] = this.deprec;
        data["tranzPaymentVAT"] = this.tranzPaymentVAT;
        data["paymentVAT"] = this.paymentVAT;
        data["tranzDeprecVAT"] = this.tranzDeprecVAT;
        data["deprecVAT"] = this.deprecVAT;
        return data;
    }

    clone(): PrepaymentsBalanceDetailListDto {
        const json = this.toJSON();
        let result = new PrepaymentsBalanceDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsBalanceDetailListDto {
    id: number;
    prepayment: string | undefined;
    gestDate: moment.Moment;
    operType: string | undefined;
    tranzQuantity: number;
    quantity: number;
    tranzDuration: number;
    duration: number;
    tranzPaymentValue: number;
    paymentValue: number;
    tranzDeprec: number;
    deprec: number;
    tranzPaymentVAT: number;
    paymentVAT: number;
    tranzDeprecVAT: number;
    deprecVAT: number;
}

export class PrepaymentsBalanceListDto implements IPrepaymentsBalanceListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    prepaymentId: number | undefined;
    prepaymentType: PrepaymentType;
    gestDetail: PrepaymentsBalanceDetailListDto[] | undefined;

    constructor(data?: IPrepaymentsBalanceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.prepaymentId = _data["prepaymentId"];
            this.prepaymentType = _data["prepaymentType"];
            if (Array.isArray(_data["gestDetail"])) {
                this.gestDetail = [] as any;
                for (let item of _data["gestDetail"])
                    this.gestDetail.push(PrepaymentsBalanceDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrepaymentsBalanceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsBalanceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["prepaymentId"] = this.prepaymentId;
        data["prepaymentType"] = this.prepaymentType;
        if (Array.isArray(this.gestDetail)) {
            data["gestDetail"] = [];
            for (let item of this.gestDetail)
                data["gestDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): PrepaymentsBalanceListDto {
        const json = this.toJSON();
        let result = new PrepaymentsBalanceListDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsBalanceListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    prepaymentId: number | undefined;
    prepaymentType: PrepaymentType;
    gestDetail: PrepaymentsBalanceDetailListDto[] | undefined;
}

export class PrepaymentsDDDto implements IPrepaymentsDDDto {
    id: number;
    name: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment | undefined;

    constructor(data?: IPrepaymentsDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PrepaymentsDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): PrepaymentsDDDto {
        const json = this.toJSON();
        let result = new PrepaymentsDDDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsDDDto {
    id: number;
    name: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment | undefined;
}

export class PrepaymentsOperationListDto implements IPrepaymentsOperationListDto {
    id: number;
    prepayment: string | undefined;
    operationDate: moment.Moment;
    documentNr: string | undefined;
    documentDate: moment.Moment;
    documentType: string | undefined;
    operationType: string | undefined;
    ordProcess: number;
    operationDateSort: moment.Moment;

    constructor(data?: IPrepaymentsOperationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prepayment = _data["prepayment"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.documentType = _data["documentType"];
            this.operationType = _data["operationType"];
            this.ordProcess = _data["ordProcess"];
            this.operationDateSort = _data["operationDateSort"] ? moment(_data["operationDateSort"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PrepaymentsOperationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsOperationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prepayment"] = this.prepayment;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["documentType"] = this.documentType;
        data["operationType"] = this.operationType;
        data["ordProcess"] = this.ordProcess;
        data["operationDateSort"] = this.operationDateSort ? this.operationDateSort.toISOString() : <any>undefined;
        return data;
    }

    clone(): PrepaymentsOperationListDto {
        const json = this.toJSON();
        let result = new PrepaymentsOperationListDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsOperationListDto {
    id: number;
    prepayment: string | undefined;
    operationDate: moment.Moment;
    documentNr: string | undefined;
    documentDate: moment.Moment;
    documentType: string | undefined;
    operationType: string | undefined;
    ordProcess: number;
    operationDateSort: moment.Moment;
}

export class PrepaymentsBalanceComputeListDto implements IPrepaymentsBalanceComputeListDto {
    unprocessedDate: moment.Moment;
    computeDate: moment.Moment | undefined;
    showCompute: boolean;
    prepaymentType: PrepaymentType;
    operationList: PrepaymentsOperationListDto[] | undefined;

    constructor(data?: IPrepaymentsBalanceComputeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unprocessedDate = _data["unprocessedDate"] ? moment(_data["unprocessedDate"].toString()) : <any>undefined;
            this.computeDate = _data["computeDate"] ? moment(_data["computeDate"].toString()) : <any>undefined;
            this.showCompute = _data["showCompute"];
            this.prepaymentType = _data["prepaymentType"];
            if (Array.isArray(_data["operationList"])) {
                this.operationList = [] as any;
                for (let item of _data["operationList"])
                    this.operationList.push(PrepaymentsOperationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrepaymentsBalanceComputeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsBalanceComputeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unprocessedDate"] = this.unprocessedDate ? this.unprocessedDate.toISOString() : <any>undefined;
        data["computeDate"] = this.computeDate ? this.computeDate.toISOString() : <any>undefined;
        data["showCompute"] = this.showCompute;
        data["prepaymentType"] = this.prepaymentType;
        if (Array.isArray(this.operationList)) {
            data["operationList"] = [];
            for (let item of this.operationList)
                data["operationList"].push(item.toJSON());
        }
        return data;
    }

    clone(): PrepaymentsBalanceComputeListDto {
        const json = this.toJSON();
        let result = new PrepaymentsBalanceComputeListDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsBalanceComputeListDto {
    unprocessedDate: moment.Moment;
    computeDate: moment.Moment | undefined;
    showCompute: boolean;
    prepaymentType: PrepaymentType;
    operationList: PrepaymentsOperationListDto[] | undefined;
}

export class PrepaymentsBalanceDelDetailDto implements IPrepaymentsBalanceDelDetailDto {
    dateGest: moment.Moment;

    constructor(data?: IPrepaymentsBalanceDelDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateGest = _data["dateGest"] ? moment(_data["dateGest"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PrepaymentsBalanceDelDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsBalanceDelDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateGest"] = this.dateGest ? this.dateGest.toISOString() : <any>undefined;
        return data;
    }

    clone(): PrepaymentsBalanceDelDetailDto {
        const json = this.toJSON();
        let result = new PrepaymentsBalanceDelDetailDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsBalanceDelDetailDto {
    dateGest: moment.Moment;
}

export class PrepaymentsBalanceDelListDto implements IPrepaymentsBalanceDelListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    prepaymentType: PrepaymentType;
    gestDelDetail: PrepaymentsBalanceDelDetailDto[] | undefined;

    constructor(data?: IPrepaymentsBalanceDelListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            this.prepaymentType = _data["prepaymentType"];
            if (Array.isArray(_data["gestDelDetail"])) {
                this.gestDelDetail = [] as any;
                for (let item of _data["gestDelDetail"])
                    this.gestDelDetail.push(PrepaymentsBalanceDelDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrepaymentsBalanceDelListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsBalanceDelListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        data["prepaymentType"] = this.prepaymentType;
        if (Array.isArray(this.gestDelDetail)) {
            data["gestDelDetail"] = [];
            for (let item of this.gestDelDetail)
                data["gestDelDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): PrepaymentsBalanceDelListDto {
        const json = this.toJSON();
        let result = new PrepaymentsBalanceDelListDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsBalanceDelListDto {
    dataStart: moment.Moment | undefined;
    dataEnd: moment.Moment | undefined;
    prepaymentType: PrepaymentType;
    gestDelDetail: PrepaymentsBalanceDelDetailDto[] | undefined;
}

export class PrepaymentsListDto implements IPrepaymentsListDto {
    id: number;
    prepaymentType: PrepaymentType;
    prepaymentValue: number;
    prepaymentVAT: number;
    description: string | undefined;
    paymentDate: moment.Moment;
    endDate: moment.Moment | undefined;
    durationInMonths: number;
    montlyCharge: number | undefined;
    observations: string | undefined;
    depreciationStartDate: moment.Moment;
    invoiceDetailsId: number;
    thirdParty: string | undefined;
    invoice: string | undefined;
    state: State;
    processed: boolean;
    processedOut: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;

    constructor(data?: IPrepaymentsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prepaymentType = _data["prepaymentType"];
            this.prepaymentValue = _data["prepaymentValue"];
            this.prepaymentVAT = _data["prepaymentVAT"];
            this.description = _data["description"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.durationInMonths = _data["durationInMonths"];
            this.montlyCharge = _data["montlyCharge"];
            this.observations = _data["observations"];
            this.depreciationStartDate = _data["depreciationStartDate"] ? moment(_data["depreciationStartDate"].toString()) : <any>undefined;
            this.invoiceDetailsId = _data["invoiceDetailsId"];
            this.thirdParty = _data["thirdParty"];
            this.invoice = _data["invoice"];
            this.state = _data["state"];
            this.processed = _data["processed"];
            this.processedOut = _data["processedOut"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PrepaymentsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prepaymentType"] = this.prepaymentType;
        data["prepaymentValue"] = this.prepaymentValue;
        data["prepaymentVAT"] = this.prepaymentVAT;
        data["description"] = this.description;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["durationInMonths"] = this.durationInMonths;
        data["montlyCharge"] = this.montlyCharge;
        data["observations"] = this.observations;
        data["depreciationStartDate"] = this.depreciationStartDate ? this.depreciationStartDate.toISOString() : <any>undefined;
        data["invoiceDetailsId"] = this.invoiceDetailsId;
        data["thirdParty"] = this.thirdParty;
        data["invoice"] = this.invoice;
        data["state"] = this.state;
        data["processed"] = this.processed;
        data["processedOut"] = this.processedOut;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): PrepaymentsListDto {
        const json = this.toJSON();
        let result = new PrepaymentsListDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsListDto {
    id: number;
    prepaymentType: PrepaymentType;
    prepaymentValue: number;
    prepaymentVAT: number;
    description: string | undefined;
    paymentDate: moment.Moment;
    endDate: moment.Moment | undefined;
    durationInMonths: number;
    montlyCharge: number | undefined;
    observations: string | undefined;
    depreciationStartDate: moment.Moment;
    invoiceDetailsId: number;
    thirdParty: string | undefined;
    invoice: string | undefined;
    state: State;
    processed: boolean;
    processedOut: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
}

export class PrepaymentsAddInvoiceDetailDto implements IPrepaymentsAddInvoiceDetailDto {
    invoiceId: number;
    invoiceDetailsId: number | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment;
    prepaymentName: string | undefined;
    quantity: number;
    value: number;
    vat: number;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
    prepaymentAccountId: number | undefined;
    depreciationAccountId: number | undefined;
    prepaymentAccountVATId: number | undefined;
    depreciationAccountVATId: number | undefined;
    durationInMonths: number | undefined;
    depreciationStartDate: moment.Moment;
    endDateChelt: moment.Moment | undefined;

    constructor(data?: IPrepaymentsAddInvoiceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.invoiceDetailsId = _data["invoiceDetailsId"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.prepaymentName = _data["prepaymentName"];
            this.quantity = _data["quantity"];
            this.value = _data["value"];
            this.vat = _data["vat"];
            this.primDocumentTypeId = _data["primDocumentTypeId"];
            this.primDocumentNr = _data["primDocumentNr"];
            this.primDocumentDate = _data["primDocumentDate"] ? moment(_data["primDocumentDate"].toString()) : <any>undefined;
            this.thirdPartyId = _data["thirdPartyId"];
            this.prepaymentAccountId = _data["prepaymentAccountId"];
            this.depreciationAccountId = _data["depreciationAccountId"];
            this.prepaymentAccountVATId = _data["prepaymentAccountVATId"];
            this.depreciationAccountVATId = _data["depreciationAccountVATId"];
            this.durationInMonths = _data["durationInMonths"];
            this.depreciationStartDate = _data["depreciationStartDate"] ? moment(_data["depreciationStartDate"].toString()) : <any>undefined;
            this.endDateChelt = _data["endDateChelt"] ? moment(_data["endDateChelt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PrepaymentsAddInvoiceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsAddInvoiceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["invoiceDetailsId"] = this.invoiceDetailsId;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["prepaymentName"] = this.prepaymentName;
        data["quantity"] = this.quantity;
        data["value"] = this.value;
        data["vat"] = this.vat;
        data["primDocumentTypeId"] = this.primDocumentTypeId;
        data["primDocumentNr"] = this.primDocumentNr;
        data["primDocumentDate"] = this.primDocumentDate ? this.primDocumentDate.toISOString() : <any>undefined;
        data["thirdPartyId"] = this.thirdPartyId;
        data["prepaymentAccountId"] = this.prepaymentAccountId;
        data["depreciationAccountId"] = this.depreciationAccountId;
        data["prepaymentAccountVATId"] = this.prepaymentAccountVATId;
        data["depreciationAccountVATId"] = this.depreciationAccountVATId;
        data["durationInMonths"] = this.durationInMonths;
        data["depreciationStartDate"] = this.depreciationStartDate ? this.depreciationStartDate.toISOString() : <any>undefined;
        data["endDateChelt"] = this.endDateChelt ? this.endDateChelt.toISOString() : <any>undefined;
        return data;
    }

    clone(): PrepaymentsAddInvoiceDetailDto {
        const json = this.toJSON();
        let result = new PrepaymentsAddInvoiceDetailDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsAddInvoiceDetailDto {
    invoiceId: number;
    invoiceDetailsId: number | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment;
    prepaymentName: string | undefined;
    quantity: number;
    value: number;
    vat: number;
    primDocumentTypeId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    thirdPartyId: number | undefined;
    prepaymentAccountId: number | undefined;
    depreciationAccountId: number | undefined;
    prepaymentAccountVATId: number | undefined;
    depreciationAccountVATId: number | undefined;
    durationInMonths: number | undefined;
    depreciationStartDate: moment.Moment;
    endDateChelt: moment.Moment | undefined;
}

export class PrepaymentsAddDto implements IPrepaymentsAddDto {
    operationDate: moment.Moment;
    prepaymentType: PrepaymentType;
    invoiceId: number | undefined;
    inregVAT: boolean;
    documentTypeId: number;
    documentType: string | undefined;
    unreceiveInvoice: boolean;
    invoiceDetail: PrepaymentsAddInvoiceDetailDto[] | undefined;
    showForm1: boolean;
    showForm2: boolean;
    finishAdd: boolean;

    constructor(data?: IPrepaymentsAddDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.prepaymentType = _data["prepaymentType"];
            this.invoiceId = _data["invoiceId"];
            this.inregVAT = _data["inregVAT"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"];
            this.unreceiveInvoice = _data["unreceiveInvoice"];
            if (Array.isArray(_data["invoiceDetail"])) {
                this.invoiceDetail = [] as any;
                for (let item of _data["invoiceDetail"])
                    this.invoiceDetail.push(PrepaymentsAddInvoiceDetailDto.fromJS(item));
            }
            this.showForm1 = _data["showForm1"];
            this.showForm2 = _data["showForm2"];
            this.finishAdd = _data["finishAdd"];
        }
    }

    static fromJS(data: any): PrepaymentsAddDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsAddDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["prepaymentType"] = this.prepaymentType;
        data["invoiceId"] = this.invoiceId;
        data["inregVAT"] = this.inregVAT;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType;
        data["unreceiveInvoice"] = this.unreceiveInvoice;
        if (Array.isArray(this.invoiceDetail)) {
            data["invoiceDetail"] = [];
            for (let item of this.invoiceDetail)
                data["invoiceDetail"].push(item.toJSON());
        }
        data["showForm1"] = this.showForm1;
        data["showForm2"] = this.showForm2;
        data["finishAdd"] = this.finishAdd;
        return data;
    }

    clone(): PrepaymentsAddDto {
        const json = this.toJSON();
        let result = new PrepaymentsAddDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsAddDto {
    operationDate: moment.Moment;
    prepaymentType: PrepaymentType;
    invoiceId: number | undefined;
    inregVAT: boolean;
    documentTypeId: number;
    documentType: string | undefined;
    unreceiveInvoice: boolean;
    invoiceDetail: PrepaymentsAddInvoiceDetailDto[] | undefined;
    showForm1: boolean;
    showForm2: boolean;
    finishAdd: boolean;
}

export class PrepaymentsAddDirectDto implements IPrepaymentsAddDirectDto {
    id: number;
    paymentDate: moment.Moment;
    endDate: moment.Moment | undefined;
    endDateChelt: moment.Moment | undefined;
    primDocumentTypeId: number | undefined;
    primDocumentType: string | undefined;
    invoiceId: number | undefined;
    finishAdd: boolean;
    name: string | undefined;
    depreciationStartDate: moment.Moment;
    durationInMonths: number;
    depreciation: number | undefined;
    depreciationVAT: number | undefined;
    invoiceDetailsId: number | undefined;
    prepaymentAccountId: number | undefined;
    depreciationAccountId: number | undefined;
    prepaymentAccountVATId: number | undefined;
    depreciationAccountVATId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    processed: boolean;
    processedOut: boolean;
    thirdPartyId: number | undefined;
    thirdPartyName: string | undefined;
    prepaymentType: PrepaymentType;
    prepaymentValue: number;
    prepaymentVAT: number;
    remainingDuration: number | undefined;
    montlyDepreciation: number | undefined;
    montlyDepreciationVAT: number | undefined;
    unreceiveInvoice: boolean;

    constructor(data?: IPrepaymentsAddDirectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.endDateChelt = _data["endDateChelt"] ? moment(_data["endDateChelt"].toString()) : <any>undefined;
            this.primDocumentTypeId = _data["primDocumentTypeId"];
            this.primDocumentType = _data["primDocumentType"];
            this.invoiceId = _data["invoiceId"];
            this.finishAdd = _data["finishAdd"];
            this.name = _data["name"];
            this.depreciationStartDate = _data["depreciationStartDate"] ? moment(_data["depreciationStartDate"].toString()) : <any>undefined;
            this.durationInMonths = _data["durationInMonths"];
            this.depreciation = _data["depreciation"];
            this.depreciationVAT = _data["depreciationVAT"];
            this.invoiceDetailsId = _data["invoiceDetailsId"];
            this.prepaymentAccountId = _data["prepaymentAccountId"];
            this.depreciationAccountId = _data["depreciationAccountId"];
            this.prepaymentAccountVATId = _data["prepaymentAccountVATId"];
            this.depreciationAccountVATId = _data["depreciationAccountVATId"];
            this.primDocumentNr = _data["primDocumentNr"];
            this.primDocumentDate = _data["primDocumentDate"] ? moment(_data["primDocumentDate"].toString()) : <any>undefined;
            this.processed = _data["processed"];
            this.processedOut = _data["processedOut"];
            this.thirdPartyId = _data["thirdPartyId"];
            this.thirdPartyName = _data["thirdPartyName"];
            this.prepaymentType = _data["prepaymentType"];
            this.prepaymentValue = _data["prepaymentValue"];
            this.prepaymentVAT = _data["prepaymentVAT"];
            this.remainingDuration = _data["remainingDuration"];
            this.montlyDepreciation = _data["montlyDepreciation"];
            this.montlyDepreciationVAT = _data["montlyDepreciationVAT"];
            this.unreceiveInvoice = _data["unreceiveInvoice"];
        }
    }

    static fromJS(data: any): PrepaymentsAddDirectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsAddDirectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["endDateChelt"] = this.endDateChelt ? this.endDateChelt.toISOString() : <any>undefined;
        data["primDocumentTypeId"] = this.primDocumentTypeId;
        data["primDocumentType"] = this.primDocumentType;
        data["invoiceId"] = this.invoiceId;
        data["finishAdd"] = this.finishAdd;
        data["name"] = this.name;
        data["depreciationStartDate"] = this.depreciationStartDate ? this.depreciationStartDate.toISOString() : <any>undefined;
        data["durationInMonths"] = this.durationInMonths;
        data["depreciation"] = this.depreciation;
        data["depreciationVAT"] = this.depreciationVAT;
        data["invoiceDetailsId"] = this.invoiceDetailsId;
        data["prepaymentAccountId"] = this.prepaymentAccountId;
        data["depreciationAccountId"] = this.depreciationAccountId;
        data["prepaymentAccountVATId"] = this.prepaymentAccountVATId;
        data["depreciationAccountVATId"] = this.depreciationAccountVATId;
        data["primDocumentNr"] = this.primDocumentNr;
        data["primDocumentDate"] = this.primDocumentDate ? this.primDocumentDate.toISOString() : <any>undefined;
        data["processed"] = this.processed;
        data["processedOut"] = this.processedOut;
        data["thirdPartyId"] = this.thirdPartyId;
        data["thirdPartyName"] = this.thirdPartyName;
        data["prepaymentType"] = this.prepaymentType;
        data["prepaymentValue"] = this.prepaymentValue;
        data["prepaymentVAT"] = this.prepaymentVAT;
        data["remainingDuration"] = this.remainingDuration;
        data["montlyDepreciation"] = this.montlyDepreciation;
        data["montlyDepreciationVAT"] = this.montlyDepreciationVAT;
        data["unreceiveInvoice"] = this.unreceiveInvoice;
        return data;
    }

    clone(): PrepaymentsAddDirectDto {
        const json = this.toJSON();
        let result = new PrepaymentsAddDirectDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsAddDirectDto {
    id: number;
    paymentDate: moment.Moment;
    endDate: moment.Moment | undefined;
    endDateChelt: moment.Moment | undefined;
    primDocumentTypeId: number | undefined;
    primDocumentType: string | undefined;
    invoiceId: number | undefined;
    finishAdd: boolean;
    name: string | undefined;
    depreciationStartDate: moment.Moment;
    durationInMonths: number;
    depreciation: number | undefined;
    depreciationVAT: number | undefined;
    invoiceDetailsId: number | undefined;
    prepaymentAccountId: number | undefined;
    depreciationAccountId: number | undefined;
    prepaymentAccountVATId: number | undefined;
    depreciationAccountVATId: number | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    processed: boolean;
    processedOut: boolean;
    thirdPartyId: number | undefined;
    thirdPartyName: string | undefined;
    prepaymentType: PrepaymentType;
    prepaymentValue: number;
    prepaymentVAT: number;
    remainingDuration: number | undefined;
    montlyDepreciation: number | undefined;
    montlyDepreciationVAT: number | undefined;
    unreceiveInvoice: boolean;
}

export class PrepaymentsExitDto implements IPrepaymentsExitDto {
    id: number;
    paymentDate: moment.Moment;
    endDate: moment.Moment | undefined;
    primDocumentType: string | undefined;
    finishAdd: boolean;
    name: string | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    processedOut: boolean;
    thirdPartyName: string | undefined;
    prepaymentType: PrepaymentType;
    prepaymentValue: number;

    constructor(data?: IPrepaymentsExitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentDate = _data["paymentDate"] ? moment(_data["paymentDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.primDocumentType = _data["primDocumentType"];
            this.finishAdd = _data["finishAdd"];
            this.name = _data["name"];
            this.primDocumentNr = _data["primDocumentNr"];
            this.primDocumentDate = _data["primDocumentDate"] ? moment(_data["primDocumentDate"].toString()) : <any>undefined;
            this.processedOut = _data["processedOut"];
            this.thirdPartyName = _data["thirdPartyName"];
            this.prepaymentType = _data["prepaymentType"];
            this.prepaymentValue = _data["prepaymentValue"];
        }
    }

    static fromJS(data: any): PrepaymentsExitDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsExitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["primDocumentType"] = this.primDocumentType;
        data["finishAdd"] = this.finishAdd;
        data["name"] = this.name;
        data["primDocumentNr"] = this.primDocumentNr;
        data["primDocumentDate"] = this.primDocumentDate ? this.primDocumentDate.toISOString() : <any>undefined;
        data["processedOut"] = this.processedOut;
        data["thirdPartyName"] = this.thirdPartyName;
        data["prepaymentType"] = this.prepaymentType;
        data["prepaymentValue"] = this.prepaymentValue;
        return data;
    }

    clone(): PrepaymentsExitDto {
        const json = this.toJSON();
        let result = new PrepaymentsExitDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsExitDto {
    id: number;
    paymentDate: moment.Moment;
    endDate: moment.Moment | undefined;
    primDocumentType: string | undefined;
    finishAdd: boolean;
    name: string | undefined;
    primDocumentNr: string | undefined;
    primDocumentDate: moment.Moment | undefined;
    processedOut: boolean;
    thirdPartyName: string | undefined;
    prepaymentType: PrepaymentType;
    prepaymentValue: number;
}

export class PrepaymentsDurationSetupDto implements IPrepaymentsDurationSetupDto {
    id: number;
    prepaymentTypeId: number;
    prepaymentDurationCalcId: number;

    constructor(data?: IPrepaymentsDurationSetupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prepaymentTypeId = _data["prepaymentTypeId"];
            this.prepaymentDurationCalcId = _data["prepaymentDurationCalcId"];
        }
    }

    static fromJS(data: any): PrepaymentsDurationSetupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsDurationSetupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prepaymentTypeId"] = this.prepaymentTypeId;
        data["prepaymentDurationCalcId"] = this.prepaymentDurationCalcId;
        return data;
    }

    clone(): PrepaymentsDurationSetupDto {
        const json = this.toJSON();
        let result = new PrepaymentsDurationSetupDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsDurationSetupDto {
    id: number;
    prepaymentTypeId: number;
    prepaymentDurationCalcId: number;
}

export class PrepaymentsDecDeprecSetupDto implements IPrepaymentsDecDeprecSetupDto {
    id: number;
    prepaymentTypeId: number;
    decimalAmort: number;

    constructor(data?: IPrepaymentsDecDeprecSetupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prepaymentTypeId = _data["prepaymentTypeId"];
            this.decimalAmort = _data["decimalAmort"];
        }
    }

    static fromJS(data: any): PrepaymentsDecDeprecSetupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsDecDeprecSetupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prepaymentTypeId"] = this.prepaymentTypeId;
        data["decimalAmort"] = this.decimalAmort;
        return data;
    }

    clone(): PrepaymentsDecDeprecSetupDto {
        const json = this.toJSON();
        let result = new PrepaymentsDecDeprecSetupDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsDecDeprecSetupDto {
    id: number;
    prepaymentTypeId: number;
    decimalAmort: number;
}

export class PrepaymentsOperDocTypeListDto implements IPrepaymentsOperDocTypeListDto {
    id: number;
    operType: string | undefined;
    documentType: string | undefined;
    appOperation: boolean;

    constructor(data?: IPrepaymentsOperDocTypeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operType = _data["operType"];
            this.documentType = _data["documentType"];
            this.appOperation = _data["appOperation"];
        }
    }

    static fromJS(data: any): PrepaymentsOperDocTypeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsOperDocTypeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operType"] = this.operType;
        data["documentType"] = this.documentType;
        data["appOperation"] = this.appOperation;
        return data;
    }

    clone(): PrepaymentsOperDocTypeListDto {
        const json = this.toJSON();
        let result = new PrepaymentsOperDocTypeListDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsOperDocTypeListDto {
    id: number;
    operType: string | undefined;
    documentType: string | undefined;
    appOperation: boolean;
}

export class GetPrepaymentsOperDocTypeOutput implements IGetPrepaymentsOperDocTypeOutput {
    getPrepaymentsOperDocType: PrepaymentsOperDocTypeListDto[] | undefined;

    constructor(data?: IGetPrepaymentsOperDocTypeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getPrepaymentsOperDocType"])) {
                this.getPrepaymentsOperDocType = [] as any;
                for (let item of _data["getPrepaymentsOperDocType"])
                    this.getPrepaymentsOperDocType.push(PrepaymentsOperDocTypeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPrepaymentsOperDocTypeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPrepaymentsOperDocTypeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getPrepaymentsOperDocType)) {
            data["getPrepaymentsOperDocType"] = [];
            for (let item of this.getPrepaymentsOperDocType)
                data["getPrepaymentsOperDocType"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetPrepaymentsOperDocTypeOutput {
        const json = this.toJSON();
        let result = new GetPrepaymentsOperDocTypeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPrepaymentsOperDocTypeOutput {
    getPrepaymentsOperDocType: PrepaymentsOperDocTypeListDto[] | undefined;
}

export class PrepaymentsOperDocTypeEditDto implements IPrepaymentsOperDocTypeEditDto {
    id: number;
    operTypeId: number;
    documentTypeId: number;
    appOperation: boolean;

    constructor(data?: IPrepaymentsOperDocTypeEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operTypeId = _data["operTypeId"];
            this.documentTypeId = _data["documentTypeId"];
            this.appOperation = _data["appOperation"];
        }
    }

    static fromJS(data: any): PrepaymentsOperDocTypeEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsOperDocTypeEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operTypeId"] = this.operTypeId;
        data["documentTypeId"] = this.documentTypeId;
        data["appOperation"] = this.appOperation;
        return data;
    }

    clone(): PrepaymentsOperDocTypeEditDto {
        const json = this.toJSON();
        let result = new PrepaymentsOperDocTypeEditDto();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsOperDocTypeEditDto {
    id: number;
    operTypeId: number;
    documentTypeId: number;
    appOperation: boolean;
}

export class PrepaymentsRegistruDetails implements IPrepaymentsRegistruDetails {
    prepaymentName: string | undefined;
    prepaymentValue: number;
    monthlyDepreciation: number;
    depreciation: number;
    remainingPrepaymentValue: number;
    duration: number;
    remainingDuration: number;
    syntheticAccount: string | undefined;
    analyticAccount: string | undefined;
    accountName: string | undefined;
    accountForGroup: string | undefined;
    documentType: string | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment | undefined;
    depreciationStartDate: moment.Moment;
    thirdParty: string | undefined;

    constructor(data?: IPrepaymentsRegistruDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prepaymentName = _data["prepaymentName"];
            this.prepaymentValue = _data["prepaymentValue"];
            this.monthlyDepreciation = _data["monthlyDepreciation"];
            this.depreciation = _data["depreciation"];
            this.remainingPrepaymentValue = _data["remainingPrepaymentValue"];
            this.duration = _data["duration"];
            this.remainingDuration = _data["remainingDuration"];
            this.syntheticAccount = _data["syntheticAccount"];
            this.analyticAccount = _data["analyticAccount"];
            this.accountName = _data["accountName"];
            this.accountForGroup = _data["accountForGroup"];
            this.documentType = _data["documentType"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.depreciationStartDate = _data["depreciationStartDate"] ? moment(_data["depreciationStartDate"].toString()) : <any>undefined;
            this.thirdParty = _data["thirdParty"];
        }
    }

    static fromJS(data: any): PrepaymentsRegistruDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsRegistruDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prepaymentName"] = this.prepaymentName;
        data["prepaymentValue"] = this.prepaymentValue;
        data["monthlyDepreciation"] = this.monthlyDepreciation;
        data["depreciation"] = this.depreciation;
        data["remainingPrepaymentValue"] = this.remainingPrepaymentValue;
        data["duration"] = this.duration;
        data["remainingDuration"] = this.remainingDuration;
        data["syntheticAccount"] = this.syntheticAccount;
        data["analyticAccount"] = this.analyticAccount;
        data["accountName"] = this.accountName;
        data["accountForGroup"] = this.accountForGroup;
        data["documentType"] = this.documentType;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["depreciationStartDate"] = this.depreciationStartDate ? this.depreciationStartDate.toISOString() : <any>undefined;
        data["thirdParty"] = this.thirdParty;
        return data;
    }

    clone(): PrepaymentsRegistruDetails {
        const json = this.toJSON();
        let result = new PrepaymentsRegistruDetails();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsRegistruDetails {
    prepaymentName: string | undefined;
    prepaymentValue: number;
    monthlyDepreciation: number;
    depreciation: number;
    remainingPrepaymentValue: number;
    duration: number;
    remainingDuration: number;
    syntheticAccount: string | undefined;
    analyticAccount: string | undefined;
    accountName: string | undefined;
    accountForGroup: string | undefined;
    documentType: string | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment | undefined;
    depreciationStartDate: moment.Moment;
    thirdParty: string | undefined;
}

export class PrepaymentsRegistruReport implements IPrepaymentsRegistruReport {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    regDate: moment.Moment;
    prepaymentType: PrepaymentType;
    reportName: string | undefined;
    modCalc: number;
    regDetails: PrepaymentsRegistruDetails[] | undefined;

    constructor(data?: IPrepaymentsRegistruReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.regDate = _data["regDate"] ? moment(_data["regDate"].toString()) : <any>undefined;
            this.prepaymentType = _data["prepaymentType"];
            this.reportName = _data["reportName"];
            this.modCalc = _data["modCalc"];
            if (Array.isArray(_data["regDetails"])) {
                this.regDetails = [] as any;
                for (let item of _data["regDetails"])
                    this.regDetails.push(PrepaymentsRegistruDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrepaymentsRegistruReport {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaymentsRegistruReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["regDate"] = this.regDate ? this.regDate.toISOString() : <any>undefined;
        data["prepaymentType"] = this.prepaymentType;
        data["reportName"] = this.reportName;
        data["modCalc"] = this.modCalc;
        if (Array.isArray(this.regDetails)) {
            data["regDetails"] = [];
            for (let item of this.regDetails)
                data["regDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): PrepaymentsRegistruReport {
        const json = this.toJSON();
        let result = new PrepaymentsRegistruReport();
        result.init(json);
        return result;
    }
}

export interface IPrepaymentsRegistruReport {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    regDate: moment.Moment;
    prepaymentType: PrepaymentType;
    reportName: string | undefined;
    modCalc: number;
    regDetails: PrepaymentsRegistruDetails[] | undefined;
}

export class RataDto implements IRataDto {
    id: number;
    index: number;
    tipRata: TipRata;
    numarOrdinDePlata: number;
    dataPlataRata: moment.Moment;
    sumaPrincipal: number;
    sumaDobanda: number;
    sumaPlatita: number;
    procentDobanda: number;
    currency: string | undefined;
    isValid: boolean;
    sold: number;
    imprumutId: number;
    currencyId: number;
    contaOperationDetailId: number | undefined;

    constructor(data?: IRataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.index = _data["index"];
            this.tipRata = _data["tipRata"];
            this.numarOrdinDePlata = _data["numarOrdinDePlata"];
            this.dataPlataRata = _data["dataPlataRata"] ? moment(_data["dataPlataRata"].toString()) : <any>undefined;
            this.sumaPrincipal = _data["sumaPrincipal"];
            this.sumaDobanda = _data["sumaDobanda"];
            this.sumaPlatita = _data["sumaPlatita"];
            this.procentDobanda = _data["procentDobanda"];
            this.currency = _data["currency"];
            this.isValid = _data["isValid"];
            this.sold = _data["sold"];
            this.imprumutId = _data["imprumutId"];
            this.currencyId = _data["currencyId"];
            this.contaOperationDetailId = _data["contaOperationDetailId"];
        }
    }

    static fromJS(data: any): RataDto {
        data = typeof data === 'object' ? data : {};
        let result = new RataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["index"] = this.index;
        data["tipRata"] = this.tipRata;
        data["numarOrdinDePlata"] = this.numarOrdinDePlata;
        data["dataPlataRata"] = this.dataPlataRata ? this.dataPlataRata.toISOString() : <any>undefined;
        data["sumaPrincipal"] = this.sumaPrincipal;
        data["sumaDobanda"] = this.sumaDobanda;
        data["sumaPlatita"] = this.sumaPlatita;
        data["procentDobanda"] = this.procentDobanda;
        data["currency"] = this.currency;
        data["isValid"] = this.isValid;
        data["sold"] = this.sold;
        data["imprumutId"] = this.imprumutId;
        data["currencyId"] = this.currencyId;
        data["contaOperationDetailId"] = this.contaOperationDetailId;
        return data;
    }

    clone(): RataDto {
        const json = this.toJSON();
        let result = new RataDto();
        result.init(json);
        return result;
    }
}

export interface IRataDto {
    id: number;
    index: number;
    tipRata: TipRata;
    numarOrdinDePlata: number;
    dataPlataRata: moment.Moment;
    sumaPrincipal: number;
    sumaDobanda: number;
    sumaPlatita: number;
    procentDobanda: number;
    currency: string | undefined;
    isValid: boolean;
    sold: number;
    imprumutId: number;
    currencyId: number;
    contaOperationDetailId: number | undefined;
}

export class RataEditDto implements IRataEditDto {
    id: number;
    index: number;
    tipRata: TipRata;
    tipDobanda: TipDobanda;
    numarOrdinDePlata: number;
    dataPlataRata: moment.Moment;
    sumaPrincipal: number;
    sumaDobanda: number;
    sumaPlatita: number;
    procentDobanda: number;
    sold: number;
    isValid: boolean;
    imprumutId: number;
    currencyId: number;
    contaOperationDetailId: number | undefined;
    okDelete: boolean;

    constructor(data?: IRataEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.index = _data["index"];
            this.tipRata = _data["tipRata"];
            this.tipDobanda = _data["tipDobanda"];
            this.numarOrdinDePlata = _data["numarOrdinDePlata"];
            this.dataPlataRata = _data["dataPlataRata"] ? moment(_data["dataPlataRata"].toString()) : <any>undefined;
            this.sumaPrincipal = _data["sumaPrincipal"];
            this.sumaDobanda = _data["sumaDobanda"];
            this.sumaPlatita = _data["sumaPlatita"];
            this.procentDobanda = _data["procentDobanda"];
            this.sold = _data["sold"];
            this.isValid = _data["isValid"];
            this.imprumutId = _data["imprumutId"];
            this.currencyId = _data["currencyId"];
            this.contaOperationDetailId = _data["contaOperationDetailId"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): RataEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RataEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["index"] = this.index;
        data["tipRata"] = this.tipRata;
        data["tipDobanda"] = this.tipDobanda;
        data["numarOrdinDePlata"] = this.numarOrdinDePlata;
        data["dataPlataRata"] = this.dataPlataRata ? this.dataPlataRata.toISOString() : <any>undefined;
        data["sumaPrincipal"] = this.sumaPrincipal;
        data["sumaDobanda"] = this.sumaDobanda;
        data["sumaPlatita"] = this.sumaPlatita;
        data["procentDobanda"] = this.procentDobanda;
        data["sold"] = this.sold;
        data["isValid"] = this.isValid;
        data["imprumutId"] = this.imprumutId;
        data["currencyId"] = this.currencyId;
        data["contaOperationDetailId"] = this.contaOperationDetailId;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): RataEditDto {
        const json = this.toJSON();
        let result = new RataEditDto();
        result.init(json);
        return result;
    }
}

export interface IRataEditDto {
    id: number;
    index: number;
    tipRata: TipRata;
    tipDobanda: TipDobanda;
    numarOrdinDePlata: number;
    dataPlataRata: moment.Moment;
    sumaPrincipal: number;
    sumaDobanda: number;
    sumaPlatita: number;
    procentDobanda: number;
    sold: number;
    isValid: boolean;
    imprumutId: number;
    currencyId: number;
    contaOperationDetailId: number | undefined;
    okDelete: boolean;
}

export class RegInventarExceptiiListDto implements IRegInventarExceptiiListDto {
    id: number;
    accountId: number;
    accountName: string | undefined;
    state: State;
    tenantId: number;
    formula: string | undefined;

    constructor(data?: IRegInventarExceptiiListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountId = _data["accountId"];
            this.accountName = _data["accountName"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.formula = _data["formula"];
        }
    }

    static fromJS(data: any): RegInventarExceptiiListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegInventarExceptiiListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["formula"] = this.formula;
        return data;
    }

    clone(): RegInventarExceptiiListDto {
        const json = this.toJSON();
        let result = new RegInventarExceptiiListDto();
        result.init(json);
        return result;
    }
}

export interface IRegInventarExceptiiListDto {
    id: number;
    accountId: number;
    accountName: string | undefined;
    state: State;
    tenantId: number;
    formula: string | undefined;
}

export class GetRegInventarOutput implements IGetRegInventarOutput {
    getRegInventar: RegInventarExceptiiListDto[] | undefined;

    constructor(data?: IGetRegInventarOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getRegInventar"])) {
                this.getRegInventar = [] as any;
                for (let item of _data["getRegInventar"])
                    this.getRegInventar.push(RegInventarExceptiiListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegInventarOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegInventarOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getRegInventar)) {
            data["getRegInventar"] = [];
            for (let item of this.getRegInventar)
                data["getRegInventar"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetRegInventarOutput {
        const json = this.toJSON();
        let result = new GetRegInventarOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRegInventarOutput {
    getRegInventar: RegInventarExceptiiListDto[] | undefined;
}

export class ExceptEliminareRegInventarListDto implements IExceptEliminareRegInventarListDto {
    id: number;
    accountId: number;
    accountName: string | undefined;
    state: State;
    tenantId: number;

    constructor(data?: IExceptEliminareRegInventarListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountId = _data["accountId"];
            this.accountName = _data["accountName"];
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): ExceptEliminareRegInventarListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExceptEliminareRegInventarListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): ExceptEliminareRegInventarListDto {
        const json = this.toJSON();
        let result = new ExceptEliminareRegInventarListDto();
        result.init(json);
        return result;
    }
}

export interface IExceptEliminareRegInventarListDto {
    id: number;
    accountId: number;
    accountName: string | undefined;
    state: State;
    tenantId: number;
}

export class GetExceptElimRegInventarOutput implements IGetExceptElimRegInventarOutput {
    getRegInventar: ExceptEliminareRegInventarListDto[] | undefined;

    constructor(data?: IGetExceptElimRegInventarOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["getRegInventar"])) {
                this.getRegInventar = [] as any;
                for (let item of _data["getRegInventar"])
                    this.getRegInventar.push(ExceptEliminareRegInventarListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetExceptElimRegInventarOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExceptElimRegInventarOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getRegInventar)) {
            data["getRegInventar"] = [];
            for (let item of this.getRegInventar)
                data["getRegInventar"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetExceptElimRegInventarOutput {
        const json = this.toJSON();
        let result = new GetExceptElimRegInventarOutput();
        result.init(json);
        return result;
    }
}

export interface IGetExceptElimRegInventarOutput {
    getRegInventar: ExceptEliminareRegInventarListDto[] | undefined;
}

export class RepConfigEditDto implements IRepConfigEditDto {
    id: number;
    rapDate: moment.Moment;
    tenantId: number;

    constructor(data?: IRepConfigEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rapDate = _data["rapDate"] ? moment(_data["rapDate"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): RepConfigEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepConfigEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rapDate"] = this.rapDate ? this.rapDate.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): RepConfigEditDto {
        const json = this.toJSON();
        let result = new RepConfigEditDto();
        result.init(json);
        return result;
    }
}

export interface IRepConfigEditDto {
    id: number;
    rapDate: moment.Moment;
    tenantId: number;
}

export class RepConfigDto implements IRepConfigDto {
    id: number;
    reportName: string | undefined;
    reportSymbol: string | undefined;
    repConfigId: number;

    constructor(data?: IRepConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reportName = _data["reportName"];
            this.reportSymbol = _data["reportSymbol"];
            this.repConfigId = _data["repConfigId"];
        }
    }

    static fromJS(data: any): RepConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reportName"] = this.reportName;
        data["reportSymbol"] = this.reportSymbol;
        data["repConfigId"] = this.repConfigId;
        return data;
    }

    clone(): RepConfigDto {
        const json = this.toJSON();
        let result = new RepConfigDto();
        result.init(json);
        return result;
    }
}

export interface IRepConfigDto {
    id: number;
    reportName: string | undefined;
    reportSymbol: string | undefined;
    repConfigId: number;
}

export class ReportConfigForm implements IReportConfigForm {
    repConfigId: number;
    repDate: moment.Moment;
    reportList: RepConfigDto[] | undefined;

    constructor(data?: IReportConfigForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repConfigId = _data["repConfigId"];
            this.repDate = _data["repDate"] ? moment(_data["repDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["reportList"])) {
                this.reportList = [] as any;
                for (let item of _data["reportList"])
                    this.reportList.push(RepConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportConfigForm {
        data = typeof data === 'object' ? data : {};
        let result = new ReportConfigForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repConfigId"] = this.repConfigId;
        data["repDate"] = this.repDate ? this.repDate.toISOString() : <any>undefined;
        if (Array.isArray(this.reportList)) {
            data["reportList"] = [];
            for (let item of this.reportList)
                data["reportList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReportConfigForm {
        const json = this.toJSON();
        let result = new ReportConfigForm();
        result.init(json);
        return result;
    }
}

export interface IReportConfigForm {
    repConfigId: number;
    repDate: moment.Moment;
    reportList: RepConfigDto[] | undefined;
}

export class RepConfigInitDto implements IRepConfigInitDto {
    id: number;
    rapDate: string | undefined;

    constructor(data?: IRepConfigInitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rapDate = _data["rapDate"];
        }
    }

    static fromJS(data: any): RepConfigInitDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepConfigInitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rapDate"] = this.rapDate;
        return data;
    }

    clone(): RepConfigInitDto {
        const json = this.toJSON();
        let result = new RepConfigInitDto();
        result.init(json);
        return result;
    }
}

export interface IRepConfigInitDto {
    id: number;
    rapDate: string | undefined;
}

export class ConfigFormulaDto implements IConfigFormulaDto {
    rowName: string | undefined;
    rowCode: number;
    rowNr: string | undefined;
    orderView: number;
    formulaSold: string | undefined;
    formulaRulaj: string | undefined;
    bold: boolean;
    totalRow: boolean;

    constructor(data?: IConfigFormulaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowName = _data["rowName"];
            this.rowCode = _data["rowCode"];
            this.rowNr = _data["rowNr"];
            this.orderView = _data["orderView"];
            this.formulaSold = _data["formulaSold"];
            this.formulaRulaj = _data["formulaRulaj"];
            this.bold = _data["bold"];
            this.totalRow = _data["totalRow"];
        }
    }

    static fromJS(data: any): ConfigFormulaDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigFormulaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowName"] = this.rowName;
        data["rowCode"] = this.rowCode;
        data["rowNr"] = this.rowNr;
        data["orderView"] = this.orderView;
        data["formulaSold"] = this.formulaSold;
        data["formulaRulaj"] = this.formulaRulaj;
        data["bold"] = this.bold;
        data["totalRow"] = this.totalRow;
        return data;
    }

    clone(): ConfigFormulaDto {
        const json = this.toJSON();
        let result = new ConfigFormulaDto();
        result.init(json);
        return result;
    }
}

export interface IConfigFormulaDto {
    rowName: string | undefined;
    rowCode: number;
    rowNr: string | undefined;
    orderView: number;
    formulaSold: string | undefined;
    formulaRulaj: string | undefined;
    bold: boolean;
    totalRow: boolean;
}

export class ReportConfigFormulaForm implements IReportConfigFormulaForm {
    repConfigId: number;
    reportId: number;
    reportName: string | undefined;
    reportSymbol: string | undefined;
    configFormulaList: ConfigFormulaDto[] | undefined;

    constructor(data?: IReportConfigFormulaForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repConfigId = _data["repConfigId"];
            this.reportId = _data["reportId"];
            this.reportName = _data["reportName"];
            this.reportSymbol = _data["reportSymbol"];
            if (Array.isArray(_data["configFormulaList"])) {
                this.configFormulaList = [] as any;
                for (let item of _data["configFormulaList"])
                    this.configFormulaList.push(ConfigFormulaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportConfigFormulaForm {
        data = typeof data === 'object' ? data : {};
        let result = new ReportConfigFormulaForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repConfigId"] = this.repConfigId;
        data["reportId"] = this.reportId;
        data["reportName"] = this.reportName;
        data["reportSymbol"] = this.reportSymbol;
        if (Array.isArray(this.configFormulaList)) {
            data["configFormulaList"] = [];
            for (let item of this.configFormulaList)
                data["configFormulaList"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReportConfigFormulaForm {
        const json = this.toJSON();
        let result = new ReportConfigFormulaForm();
        result.init(json);
        return result;
    }
}

export interface IReportConfigFormulaForm {
    repConfigId: number;
    reportId: number;
    reportName: string | undefined;
    reportSymbol: string | undefined;
    configFormulaList: ConfigFormulaDto[] | undefined;
}

export class CalcRapListDto implements ICalcRapListDto {
    reportId: number;
    reportName: string | undefined;
    orderView: number;

    constructor(data?: ICalcRapListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportId = _data["reportId"];
            this.reportName = _data["reportName"];
            this.orderView = _data["orderView"];
        }
    }

    static fromJS(data: any): CalcRapListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalcRapListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportId"] = this.reportId;
        data["reportName"] = this.reportName;
        data["orderView"] = this.orderView;
        return data;
    }

    clone(): CalcRapListDto {
        const json = this.toJSON();
        let result = new CalcRapListDto();
        result.init(json);
        return result;
    }
}

export interface ICalcRapListDto {
    reportId: number;
    reportName: string | undefined;
    orderView: number;
}

export class BalanceDetailsView implements IBalanceDetailsView {
    crValueI: number;
    dbValueI: number;
    crValueM: number;
    dbValueM: number;
    crValueY: number;
    dbValueY: number;
    crValueF: number;
    dbValueF: number;
    dbValueP: number;
    crValueP: number;
    dbValueT: number;
    crValueT: number;
    dbValueSum: number;
    crValueSum: number;
    id: number;
    symbol: string | undefined;
    name: string | undefined;
    nivelRand: number | undefined;
    currencyId: number;
    totalSum: boolean;
    synthetic: string | undefined;
    analythic: string | undefined;
    accountType: AccountTypes;
    isSynthetic: boolean;
    accountId: number;

    constructor(data?: IBalanceDetailsView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.crValueI = _data["crValueI"];
            this.dbValueI = _data["dbValueI"];
            this.crValueM = _data["crValueM"];
            this.dbValueM = _data["dbValueM"];
            this.crValueY = _data["crValueY"];
            this.dbValueY = _data["dbValueY"];
            this.crValueF = _data["crValueF"];
            this.dbValueF = _data["dbValueF"];
            this.dbValueP = _data["dbValueP"];
            this.crValueP = _data["crValueP"];
            this.dbValueT = _data["dbValueT"];
            this.crValueT = _data["crValueT"];
            this.dbValueSum = _data["dbValueSum"];
            this.crValueSum = _data["crValueSum"];
            this.id = _data["id"];
            this.symbol = _data["symbol"];
            this.name = _data["name"];
            this.nivelRand = _data["nivelRand"];
            this.currencyId = _data["currencyId"];
            this.totalSum = _data["totalSum"];
            this.synthetic = _data["synthetic"];
            this.analythic = _data["analythic"];
            this.accountType = _data["accountType"];
            this.isSynthetic = _data["isSynthetic"];
            this.accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): BalanceDetailsView {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceDetailsView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["crValueI"] = this.crValueI;
        data["dbValueI"] = this.dbValueI;
        data["crValueM"] = this.crValueM;
        data["dbValueM"] = this.dbValueM;
        data["crValueY"] = this.crValueY;
        data["dbValueY"] = this.dbValueY;
        data["crValueF"] = this.crValueF;
        data["dbValueF"] = this.dbValueF;
        data["dbValueP"] = this.dbValueP;
        data["crValueP"] = this.crValueP;
        data["dbValueT"] = this.dbValueT;
        data["crValueT"] = this.crValueT;
        data["dbValueSum"] = this.dbValueSum;
        data["crValueSum"] = this.crValueSum;
        data["id"] = this.id;
        data["symbol"] = this.symbol;
        data["name"] = this.name;
        data["nivelRand"] = this.nivelRand;
        data["currencyId"] = this.currencyId;
        data["totalSum"] = this.totalSum;
        data["synthetic"] = this.synthetic;
        data["analythic"] = this.analythic;
        data["accountType"] = this.accountType;
        data["isSynthetic"] = this.isSynthetic;
        data["accountId"] = this.accountId;
        return data;
    }

    clone(): BalanceDetailsView {
        const json = this.toJSON();
        let result = new BalanceDetailsView();
        result.init(json);
        return result;
    }
}

export interface IBalanceDetailsView {
    crValueI: number;
    dbValueI: number;
    crValueM: number;
    dbValueM: number;
    crValueY: number;
    dbValueY: number;
    crValueF: number;
    dbValueF: number;
    dbValueP: number;
    crValueP: number;
    dbValueT: number;
    crValueT: number;
    dbValueSum: number;
    crValueSum: number;
    id: number;
    symbol: string | undefined;
    name: string | undefined;
    nivelRand: number | undefined;
    currencyId: number;
    totalSum: boolean;
    synthetic: string | undefined;
    analythic: string | undefined;
    accountType: AccountTypes;
    isSynthetic: boolean;
    accountId: number;
}

export class BalanceView implements IBalanceView {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    id: number;
    balanceDate: moment.Moment;
    balanceName: string | undefined;
    startDate: moment.Moment;
    type: BalanceType;
    totalCrI: number;
    totalDbI: number;
    totalCrM: number;
    totalDbM: number;
    totalCrY: number;
    totalDbY: number;
    totalCrF: number;
    totalDbF: number;
    totalDbP: number;
    totalCrP: number;
    totalDbSum: number;
    totalCrSum: number;
    totalCrC: number;
    totalDbC: number;
    currencyId: number;
    currencyName: string | undefined;
    details: BalanceDetailsView[] | undefined;

    constructor(data?: IBalanceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.id = _data["id"];
            this.balanceDate = _data["balanceDate"] ? moment(_data["balanceDate"].toString()) : <any>undefined;
            this.balanceName = _data["balanceName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.totalCrI = _data["totalCrI"];
            this.totalDbI = _data["totalDbI"];
            this.totalCrM = _data["totalCrM"];
            this.totalDbM = _data["totalDbM"];
            this.totalCrY = _data["totalCrY"];
            this.totalDbY = _data["totalDbY"];
            this.totalCrF = _data["totalCrF"];
            this.totalDbF = _data["totalDbF"];
            this.totalDbP = _data["totalDbP"];
            this.totalCrP = _data["totalCrP"];
            this.totalDbSum = _data["totalDbSum"];
            this.totalCrSum = _data["totalCrSum"];
            this.totalCrC = _data["totalCrC"];
            this.totalDbC = _data["totalDbC"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(BalanceDetailsView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BalanceView {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["id"] = this.id;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        data["balanceName"] = this.balanceName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["totalCrI"] = this.totalCrI;
        data["totalDbI"] = this.totalDbI;
        data["totalCrM"] = this.totalCrM;
        data["totalDbM"] = this.totalDbM;
        data["totalCrY"] = this.totalCrY;
        data["totalDbY"] = this.totalDbY;
        data["totalCrF"] = this.totalCrF;
        data["totalDbF"] = this.totalDbF;
        data["totalDbP"] = this.totalDbP;
        data["totalCrP"] = this.totalCrP;
        data["totalDbSum"] = this.totalDbSum;
        data["totalCrSum"] = this.totalCrSum;
        data["totalCrC"] = this.totalCrC;
        data["totalDbC"] = this.totalDbC;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): BalanceView {
        const json = this.toJSON();
        let result = new BalanceView();
        result.init(json);
        return result;
    }
}

export interface IBalanceView {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    id: number;
    balanceDate: moment.Moment;
    balanceName: string | undefined;
    startDate: moment.Moment;
    type: BalanceType;
    totalCrI: number;
    totalDbI: number;
    totalCrM: number;
    totalDbM: number;
    totalCrY: number;
    totalDbY: number;
    totalCrF: number;
    totalDbF: number;
    totalDbP: number;
    totalCrP: number;
    totalDbSum: number;
    totalCrSum: number;
    totalCrC: number;
    totalDbC: number;
    currencyId: number;
    currencyName: string | undefined;
    details: BalanceDetailsView[] | undefined;
}

export class SavedBalanceViewDto implements ISavedBalanceViewDto {
    id: number;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    balanceDate: moment.Moment;
    balanceName: string | undefined;
    currencyName: string | undefined;
    totalCrI: number;
    totalDbI: number;
    totalCrM: number;
    totalDbM: number;
    totalCrY: number;
    totalDbY: number;
    totalCrF: number;
    totalDbF: number;
    totalDbP: number;
    totalCrP: number;
    totalDbSum: number;
    totalCrSum: number;
    totalCrC: number;
    totalDbC: number;
    details: BalanceDetailsView[] | undefined;

    constructor(data?: ISavedBalanceViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.balanceDate = _data["balanceDate"] ? moment(_data["balanceDate"].toString()) : <any>undefined;
            this.balanceName = _data["balanceName"];
            this.currencyName = _data["currencyName"];
            this.totalCrI = _data["totalCrI"];
            this.totalDbI = _data["totalDbI"];
            this.totalCrM = _data["totalCrM"];
            this.totalDbM = _data["totalDbM"];
            this.totalCrY = _data["totalCrY"];
            this.totalDbY = _data["totalDbY"];
            this.totalCrF = _data["totalCrF"];
            this.totalDbF = _data["totalDbF"];
            this.totalDbP = _data["totalDbP"];
            this.totalCrP = _data["totalCrP"];
            this.totalDbSum = _data["totalDbSum"];
            this.totalCrSum = _data["totalCrSum"];
            this.totalCrC = _data["totalCrC"];
            this.totalDbC = _data["totalDbC"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(BalanceDetailsView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SavedBalanceViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new SavedBalanceViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        data["balanceName"] = this.balanceName;
        data["currencyName"] = this.currencyName;
        data["totalCrI"] = this.totalCrI;
        data["totalDbI"] = this.totalDbI;
        data["totalCrM"] = this.totalCrM;
        data["totalDbM"] = this.totalDbM;
        data["totalCrY"] = this.totalCrY;
        data["totalDbY"] = this.totalDbY;
        data["totalCrF"] = this.totalCrF;
        data["totalDbF"] = this.totalDbF;
        data["totalDbP"] = this.totalDbP;
        data["totalCrP"] = this.totalCrP;
        data["totalDbSum"] = this.totalDbSum;
        data["totalCrSum"] = this.totalCrSum;
        data["totalCrC"] = this.totalCrC;
        data["totalDbC"] = this.totalDbC;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): SavedBalanceViewDto {
        const json = this.toJSON();
        let result = new SavedBalanceViewDto();
        result.init(json);
        return result;
    }
}

export interface ISavedBalanceViewDto {
    id: number;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    balanceDate: moment.Moment;
    balanceName: string | undefined;
    currencyName: string | undefined;
    totalCrI: number;
    totalDbI: number;
    totalCrM: number;
    totalDbM: number;
    totalCrY: number;
    totalDbY: number;
    totalCrF: number;
    totalDbF: number;
    totalDbP: number;
    totalCrP: number;
    totalDbSum: number;
    totalCrSum: number;
    totalCrC: number;
    totalDbC: number;
    details: BalanceDetailsView[] | undefined;
}

export class RegistruJurnalDetails implements IRegistruJurnalDetails {
    contaOperationId: number;
    operationDate: moment.Moment;
    documentTypeShortName: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    debitAccount: string | undefined;
    creditAccount: string | undefined;
    value: number;
    currencyCode: string | undefined;
    operationDetailsObservations: string | undefined;

    constructor(data?: IRegistruJurnalDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contaOperationId = _data["contaOperationId"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentTypeShortName = _data["documentTypeShortName"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.debitAccount = _data["debitAccount"];
            this.creditAccount = _data["creditAccount"];
            this.value = _data["value"];
            this.currencyCode = _data["currencyCode"];
            this.operationDetailsObservations = _data["operationDetailsObservations"];
        }
    }

    static fromJS(data: any): RegistruJurnalDetails {
        data = typeof data === 'object' ? data : {};
        let result = new RegistruJurnalDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contaOperationId"] = this.contaOperationId;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentTypeShortName"] = this.documentTypeShortName;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["debitAccount"] = this.debitAccount;
        data["creditAccount"] = this.creditAccount;
        data["value"] = this.value;
        data["currencyCode"] = this.currencyCode;
        data["operationDetailsObservations"] = this.operationDetailsObservations;
        return data;
    }

    clone(): RegistruJurnalDetails {
        const json = this.toJSON();
        let result = new RegistruJurnalDetails();
        result.init(json);
        return result;
    }
}

export interface IRegistruJurnalDetails {
    contaOperationId: number;
    operationDate: moment.Moment;
    documentTypeShortName: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    debitAccount: string | undefined;
    creditAccount: string | undefined;
    value: number;
    currencyCode: string | undefined;
    operationDetailsObservations: string | undefined;
}

export class RegistruJurnal implements IRegistruJurnal {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    documentTypeId: number | undefined;
    currencyId: number | undefined;
    currency: string | undefined;
    parameters: string | undefined;
    details: RegistruJurnalDetails[] | undefined;

    constructor(data?: IRegistruJurnal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.documentTypeId = _data["documentTypeId"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"];
            this.parameters = _data["parameters"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(RegistruJurnalDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegistruJurnal {
        data = typeof data === 'object' ? data : {};
        let result = new RegistruJurnal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["documentTypeId"] = this.documentTypeId;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency;
        data["parameters"] = this.parameters;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): RegistruJurnal {
        const json = this.toJSON();
        let result = new RegistruJurnal();
        result.init(json);
        return result;
    }
}

export interface IRegistruJurnal {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    documentTypeId: number | undefined;
    currencyId: number | undefined;
    currency: string | undefined;
    parameters: string | undefined;
    details: RegistruJurnalDetails[] | undefined;
}

export class FisaContModelDetails implements IFisaContModelDetails {
    operationDate: moment.Moment;
    documentTypeShortName: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    corespAccountId: number;
    corespAccountSymbol: string | undefined;
    corespAccountName: string | undefined;
    debitValue: number;
    creditValue: number;
    sold: number | undefined;
    valueType: string | undefined;
    currencyId: number;
    currencyCode: string | undefined;
    operationDetailsObservations: string | undefined;

    constructor(data?: IFisaContModelDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentTypeShortName = _data["documentTypeShortName"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.corespAccountId = _data["corespAccountId"];
            this.corespAccountSymbol = _data["corespAccountSymbol"];
            this.corespAccountName = _data["corespAccountName"];
            this.debitValue = _data["debitValue"];
            this.creditValue = _data["creditValue"];
            this.sold = _data["sold"];
            this.valueType = _data["valueType"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.operationDetailsObservations = _data["operationDetailsObservations"];
        }
    }

    static fromJS(data: any): FisaContModelDetails {
        data = typeof data === 'object' ? data : {};
        let result = new FisaContModelDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentTypeShortName"] = this.documentTypeShortName;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["corespAccountId"] = this.corespAccountId;
        data["corespAccountSymbol"] = this.corespAccountSymbol;
        data["corespAccountName"] = this.corespAccountName;
        data["debitValue"] = this.debitValue;
        data["creditValue"] = this.creditValue;
        data["sold"] = this.sold;
        data["valueType"] = this.valueType;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["operationDetailsObservations"] = this.operationDetailsObservations;
        return data;
    }

    clone(): FisaContModelDetails {
        const json = this.toJSON();
        let result = new FisaContModelDetails();
        result.init(json);
        return result;
    }
}

export interface IFisaContModelDetails {
    operationDate: moment.Moment;
    documentTypeShortName: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment;
    corespAccountId: number;
    corespAccountSymbol: string | undefined;
    corespAccountName: string | undefined;
    debitValue: number;
    creditValue: number;
    sold: number | undefined;
    valueType: string | undefined;
    currencyId: number;
    currencyCode: string | undefined;
    operationDetailsObservations: string | undefined;
}

export class CorespAccount implements ICorespAccount {
    id: number;
    name: string | undefined;

    constructor(data?: ICorespAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CorespAccount {
        data = typeof data === 'object' ? data : {};
        let result = new CorespAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): CorespAccount {
        const json = this.toJSON();
        let result = new CorespAccount();
        result.init(json);
        return result;
    }
}

export interface ICorespAccount {
    id: number;
    name: string | undefined;
}

export class FisaContModel implements IFisaContModel {
    tenantId: number;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    accountId: number | undefined;
    accountSymbol: string | undefined;
    accountName: string | undefined;
    accountType: AccountTypes;
    documentTypeId: number | undefined;
    localCurrencyId: number;
    localCurrency: string | undefined;
    currencyId: number | undefined;
    currency: string | undefined;
    parameters: string | undefined;
    corespAccountId: number | undefined;
    corespAccountName: string | undefined;
    soldInitial: number;
    soldInitialType: string | undefined;
    soldPrecedent: number;
    soldPrecedentType: string | undefined;
    totalPrecDebit: number;
    totalPrecCredit: number;
    totalDebit: number;
    totalCredit: number;
    soldFinal: number | undefined;
    soldFinalType: string | undefined;
    showDetails: boolean;
    operationsDetail: FisaContModelDetails[] | undefined;
    operationsDetailSelection: FisaContModelDetails[] | undefined;
    corespAccountList: CorespAccount[] | undefined;

    constructor(data?: IFisaContModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.accountId = _data["accountId"];
            this.accountSymbol = _data["accountSymbol"];
            this.accountName = _data["accountName"];
            this.accountType = _data["accountType"];
            this.documentTypeId = _data["documentTypeId"];
            this.localCurrencyId = _data["localCurrencyId"];
            this.localCurrency = _data["localCurrency"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"];
            this.parameters = _data["parameters"];
            this.corespAccountId = _data["corespAccountId"];
            this.corespAccountName = _data["corespAccountName"];
            this.soldInitial = _data["soldInitial"];
            this.soldInitialType = _data["soldInitialType"];
            this.soldPrecedent = _data["soldPrecedent"];
            this.soldPrecedentType = _data["soldPrecedentType"];
            this.totalPrecDebit = _data["totalPrecDebit"];
            this.totalPrecCredit = _data["totalPrecCredit"];
            this.totalDebit = _data["totalDebit"];
            this.totalCredit = _data["totalCredit"];
            this.soldFinal = _data["soldFinal"];
            this.soldFinalType = _data["soldFinalType"];
            this.showDetails = _data["showDetails"];
            if (Array.isArray(_data["operationsDetail"])) {
                this.operationsDetail = [] as any;
                for (let item of _data["operationsDetail"])
                    this.operationsDetail.push(FisaContModelDetails.fromJS(item));
            }
            if (Array.isArray(_data["operationsDetailSelection"])) {
                this.operationsDetailSelection = [] as any;
                for (let item of _data["operationsDetailSelection"])
                    this.operationsDetailSelection.push(FisaContModelDetails.fromJS(item));
            }
            if (Array.isArray(_data["corespAccountList"])) {
                this.corespAccountList = [] as any;
                for (let item of _data["corespAccountList"])
                    this.corespAccountList.push(CorespAccount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FisaContModel {
        data = typeof data === 'object' ? data : {};
        let result = new FisaContModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["accountId"] = this.accountId;
        data["accountSymbol"] = this.accountSymbol;
        data["accountName"] = this.accountName;
        data["accountType"] = this.accountType;
        data["documentTypeId"] = this.documentTypeId;
        data["localCurrencyId"] = this.localCurrencyId;
        data["localCurrency"] = this.localCurrency;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency;
        data["parameters"] = this.parameters;
        data["corespAccountId"] = this.corespAccountId;
        data["corespAccountName"] = this.corespAccountName;
        data["soldInitial"] = this.soldInitial;
        data["soldInitialType"] = this.soldInitialType;
        data["soldPrecedent"] = this.soldPrecedent;
        data["soldPrecedentType"] = this.soldPrecedentType;
        data["totalPrecDebit"] = this.totalPrecDebit;
        data["totalPrecCredit"] = this.totalPrecCredit;
        data["totalDebit"] = this.totalDebit;
        data["totalCredit"] = this.totalCredit;
        data["soldFinal"] = this.soldFinal;
        data["soldFinalType"] = this.soldFinalType;
        data["showDetails"] = this.showDetails;
        if (Array.isArray(this.operationsDetail)) {
            data["operationsDetail"] = [];
            for (let item of this.operationsDetail)
                data["operationsDetail"].push(item.toJSON());
        }
        if (Array.isArray(this.operationsDetailSelection)) {
            data["operationsDetailSelection"] = [];
            for (let item of this.operationsDetailSelection)
                data["operationsDetailSelection"].push(item.toJSON());
        }
        if (Array.isArray(this.corespAccountList)) {
            data["corespAccountList"] = [];
            for (let item of this.corespAccountList)
                data["corespAccountList"].push(item.toJSON());
        }
        return data;
    }

    clone(): FisaContModel {
        const json = this.toJSON();
        let result = new FisaContModel();
        result.init(json);
        return result;
    }
}

export interface IFisaContModel {
    tenantId: number;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    accountId: number | undefined;
    accountSymbol: string | undefined;
    accountName: string | undefined;
    accountType: AccountTypes;
    documentTypeId: number | undefined;
    localCurrencyId: number;
    localCurrency: string | undefined;
    currencyId: number | undefined;
    currency: string | undefined;
    parameters: string | undefined;
    corespAccountId: number | undefined;
    corespAccountName: string | undefined;
    soldInitial: number;
    soldInitialType: string | undefined;
    soldPrecedent: number;
    soldPrecedentType: string | undefined;
    totalPrecDebit: number;
    totalPrecCredit: number;
    totalDebit: number;
    totalCredit: number;
    soldFinal: number | undefined;
    soldFinalType: string | undefined;
    showDetails: boolean;
    operationsDetail: FisaContModelDetails[] | undefined;
    operationsDetailSelection: FisaContModelDetails[] | undefined;
    corespAccountList: CorespAccount[] | undefined;
}

export class RegistruCasaModel implements IRegistruCasaModel {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    startDate: moment.Moment;
    soldPrec: number;
    soldCurr: number;
    currencyName: string | undefined;
    tenantId: number;
    dispositions: DispositionListDto[] | undefined;

    constructor(data?: IRegistruCasaModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.soldPrec = _data["soldPrec"];
            this.soldCurr = _data["soldCurr"];
            this.currencyName = _data["currencyName"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["dispositions"])) {
                this.dispositions = [] as any;
                for (let item of _data["dispositions"])
                    this.dispositions.push(DispositionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegistruCasaModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegistruCasaModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["soldPrec"] = this.soldPrec;
        data["soldCurr"] = this.soldCurr;
        data["currencyName"] = this.currencyName;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.dispositions)) {
            data["dispositions"] = [];
            for (let item of this.dispositions)
                data["dispositions"].push(item.toJSON());
        }
        return data;
    }

    clone(): RegistruCasaModel {
        const json = this.toJSON();
        let result = new RegistruCasaModel();
        result.init(json);
        return result;
    }
}

export interface IRegistruCasaModel {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    startDate: moment.Moment;
    soldPrec: number;
    soldCurr: number;
    currencyName: string | undefined;
    tenantId: number;
    dispositions: DispositionListDto[] | undefined;
}

export class ImoAssetRegistruDetails implements IImoAssetRegistruDetails {
    imoAssetName: string | undefined;
    inventoryValue: number;
    monthlyDepreciation: number;
    depreciation: number;
    remainingInventoryValue: number;
    inventoryNr: number;
    duration: number;
    remainingDuration: number;
    syntheticAccount: string | undefined;
    analyticAccount: string | undefined;
    accountName: string | undefined;
    accountForGroup: string | undefined;
    documentType: string | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment | undefined;
    depreciationStartDate: moment.Moment | undefined;
    thirdParty: string | undefined;
    storageId: number | undefined;
    storage: string | undefined;

    constructor(data?: IImoAssetRegistruDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imoAssetName = _data["imoAssetName"];
            this.inventoryValue = _data["inventoryValue"];
            this.monthlyDepreciation = _data["monthlyDepreciation"];
            this.depreciation = _data["depreciation"];
            this.remainingInventoryValue = _data["remainingInventoryValue"];
            this.inventoryNr = _data["inventoryNr"];
            this.duration = _data["duration"];
            this.remainingDuration = _data["remainingDuration"];
            this.syntheticAccount = _data["syntheticAccount"];
            this.analyticAccount = _data["analyticAccount"];
            this.accountName = _data["accountName"];
            this.accountForGroup = _data["accountForGroup"];
            this.documentType = _data["documentType"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.depreciationStartDate = _data["depreciationStartDate"] ? moment(_data["depreciationStartDate"].toString()) : <any>undefined;
            this.thirdParty = _data["thirdParty"];
            this.storageId = _data["storageId"];
            this.storage = _data["storage"];
        }
    }

    static fromJS(data: any): ImoAssetRegistruDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetRegistruDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imoAssetName"] = this.imoAssetName;
        data["inventoryValue"] = this.inventoryValue;
        data["monthlyDepreciation"] = this.monthlyDepreciation;
        data["depreciation"] = this.depreciation;
        data["remainingInventoryValue"] = this.remainingInventoryValue;
        data["inventoryNr"] = this.inventoryNr;
        data["duration"] = this.duration;
        data["remainingDuration"] = this.remainingDuration;
        data["syntheticAccount"] = this.syntheticAccount;
        data["analyticAccount"] = this.analyticAccount;
        data["accountName"] = this.accountName;
        data["accountForGroup"] = this.accountForGroup;
        data["documentType"] = this.documentType;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["depreciationStartDate"] = this.depreciationStartDate ? this.depreciationStartDate.toISOString() : <any>undefined;
        data["thirdParty"] = this.thirdParty;
        data["storageId"] = this.storageId;
        data["storage"] = this.storage;
        return data;
    }

    clone(): ImoAssetRegistruDetails {
        const json = this.toJSON();
        let result = new ImoAssetRegistruDetails();
        result.init(json);
        return result;
    }
}

export interface IImoAssetRegistruDetails {
    imoAssetName: string | undefined;
    inventoryValue: number;
    monthlyDepreciation: number;
    depreciation: number;
    remainingInventoryValue: number;
    inventoryNr: number;
    duration: number;
    remainingDuration: number;
    syntheticAccount: string | undefined;
    analyticAccount: string | undefined;
    accountName: string | undefined;
    accountForGroup: string | undefined;
    documentType: string | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment | undefined;
    depreciationStartDate: moment.Moment | undefined;
    thirdParty: string | undefined;
    storageId: number | undefined;
    storage: string | undefined;
}

export class ImoAssetRegistruReport implements IImoAssetRegistruReport {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    regDate: moment.Moment;
    regDetails: ImoAssetRegistruDetails[] | undefined;

    constructor(data?: IImoAssetRegistruReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.regDate = _data["regDate"] ? moment(_data["regDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["regDetails"])) {
                this.regDetails = [] as any;
                for (let item of _data["regDetails"])
                    this.regDetails.push(ImoAssetRegistruDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImoAssetRegistruReport {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetRegistruReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["regDate"] = this.regDate ? this.regDate.toISOString() : <any>undefined;
        if (Array.isArray(this.regDetails)) {
            data["regDetails"] = [];
            for (let item of this.regDetails)
                data["regDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImoAssetRegistruReport {
        const json = this.toJSON();
        let result = new ImoAssetRegistruReport();
        result.init(json);
        return result;
    }
}

export interface IImoAssetRegistruReport {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    regDate: moment.Moment;
    regDetails: ImoAssetRegistruDetails[] | undefined;
}

export class ImoAssetFisaDetail implements IImoAssetFisaDetail {
    operationDate: moment.Moment;
    documentType: string | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment | undefined;
    thirdParty: string | undefined;
    operType: string | undefined;
    storage: string | undefined;
    debit: number;
    credit: number;
    sold: number;

    constructor(data?: IImoAssetFisaDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.documentType = _data["documentType"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.thirdParty = _data["thirdParty"];
            this.operType = _data["operType"];
            this.storage = _data["storage"];
            this.debit = _data["debit"];
            this.credit = _data["credit"];
            this.sold = _data["sold"];
        }
    }

    static fromJS(data: any): ImoAssetFisaDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetFisaDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["documentType"] = this.documentType;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["thirdParty"] = this.thirdParty;
        data["operType"] = this.operType;
        data["storage"] = this.storage;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["sold"] = this.sold;
        return data;
    }

    clone(): ImoAssetFisaDetail {
        const json = this.toJSON();
        let result = new ImoAssetFisaDetail();
        result.init(json);
        return result;
    }
}

export interface IImoAssetFisaDetail {
    operationDate: moment.Moment;
    documentType: string | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment | undefined;
    thirdParty: string | undefined;
    operType: string | undefined;
    storage: string | undefined;
    debit: number;
    credit: number;
    sold: number;
}

export class ImoAssetFisaReport implements IImoAssetFisaReport {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    inventoryNr: number;
    imoAssetName: string | undefined;
    documentType: string | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment | undefined;
    inventoryValue: number;
    monthlyDepreciation: number;
    classCode: string | undefined;
    useStartDate: moment.Moment;
    depreciationEnd: moment.Moment;
    classCodeNormDuration: number | undefined;
    procDeprec: number;
    fisaDetail: ImoAssetFisaDetail[] | undefined;

    constructor(data?: IImoAssetFisaReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.inventoryNr = _data["inventoryNr"];
            this.imoAssetName = _data["imoAssetName"];
            this.documentType = _data["documentType"];
            this.documentNr = _data["documentNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.inventoryValue = _data["inventoryValue"];
            this.monthlyDepreciation = _data["monthlyDepreciation"];
            this.classCode = _data["classCode"];
            this.useStartDate = _data["useStartDate"] ? moment(_data["useStartDate"].toString()) : <any>undefined;
            this.depreciationEnd = _data["depreciationEnd"] ? moment(_data["depreciationEnd"].toString()) : <any>undefined;
            this.classCodeNormDuration = _data["classCodeNormDuration"];
            this.procDeprec = _data["procDeprec"];
            if (Array.isArray(_data["fisaDetail"])) {
                this.fisaDetail = [] as any;
                for (let item of _data["fisaDetail"])
                    this.fisaDetail.push(ImoAssetFisaDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImoAssetFisaReport {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetFisaReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["inventoryNr"] = this.inventoryNr;
        data["imoAssetName"] = this.imoAssetName;
        data["documentType"] = this.documentType;
        data["documentNr"] = this.documentNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["inventoryValue"] = this.inventoryValue;
        data["monthlyDepreciation"] = this.monthlyDepreciation;
        data["classCode"] = this.classCode;
        data["useStartDate"] = this.useStartDate ? this.useStartDate.toISOString() : <any>undefined;
        data["depreciationEnd"] = this.depreciationEnd ? this.depreciationEnd.toISOString() : <any>undefined;
        data["classCodeNormDuration"] = this.classCodeNormDuration;
        data["procDeprec"] = this.procDeprec;
        if (Array.isArray(this.fisaDetail)) {
            data["fisaDetail"] = [];
            for (let item of this.fisaDetail)
                data["fisaDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImoAssetFisaReport {
        const json = this.toJSON();
        let result = new ImoAssetFisaReport();
        result.init(json);
        return result;
    }
}

export interface IImoAssetFisaReport {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    inventoryNr: number;
    imoAssetName: string | undefined;
    documentType: string | undefined;
    documentNr: string | undefined;
    documentDate: moment.Moment | undefined;
    inventoryValue: number;
    monthlyDepreciation: number;
    classCode: string | undefined;
    useStartDate: moment.Moment;
    depreciationEnd: moment.Moment;
    classCodeNormDuration: number | undefined;
    procDeprec: number;
    fisaDetail: ImoAssetFisaDetail[] | undefined;
}

export class ImoAssetModerniz implements IImoAssetModerniz {
    operationDate: moment.Moment;
    datePIF: moment.Moment;
    dateStartDeprec: moment.Moment;
    durataUtila: number;
    durataScursaUtila: number;
    initialValue: number;
    currentValue: number;
    monthlyDeprec: number;
    cumulativDeprec: number;
    yearDeprec: number;
    storageName: string | undefined;

    constructor(data?: IImoAssetModerniz) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.datePIF = _data["datePIF"] ? moment(_data["datePIF"].toString()) : <any>undefined;
            this.dateStartDeprec = _data["dateStartDeprec"] ? moment(_data["dateStartDeprec"].toString()) : <any>undefined;
            this.durataUtila = _data["durataUtila"];
            this.durataScursaUtila = _data["durataScursaUtila"];
            this.initialValue = _data["initialValue"];
            this.currentValue = _data["currentValue"];
            this.monthlyDeprec = _data["monthlyDeprec"];
            this.cumulativDeprec = _data["cumulativDeprec"];
            this.yearDeprec = _data["yearDeprec"];
            this.storageName = _data["storageName"];
        }
    }

    static fromJS(data: any): ImoAssetModerniz {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetModerniz();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["datePIF"] = this.datePIF ? this.datePIF.toISOString() : <any>undefined;
        data["dateStartDeprec"] = this.dateStartDeprec ? this.dateStartDeprec.toISOString() : <any>undefined;
        data["durataUtila"] = this.durataUtila;
        data["durataScursaUtila"] = this.durataScursaUtila;
        data["initialValue"] = this.initialValue;
        data["currentValue"] = this.currentValue;
        data["monthlyDeprec"] = this.monthlyDeprec;
        data["cumulativDeprec"] = this.cumulativDeprec;
        data["yearDeprec"] = this.yearDeprec;
        data["storageName"] = this.storageName;
        return data;
    }

    clone(): ImoAssetModerniz {
        const json = this.toJSON();
        let result = new ImoAssetModerniz();
        result.init(json);
        return result;
    }
}

export interface IImoAssetModerniz {
    operationDate: moment.Moment;
    datePIF: moment.Moment;
    dateStartDeprec: moment.Moment;
    durataUtila: number;
    durataScursaUtila: number;
    initialValue: number;
    currentValue: number;
    monthlyDeprec: number;
    cumulativDeprec: number;
    yearDeprec: number;
    storageName: string | undefined;
}

export class ImoAssetV2Details implements IImoAssetV2Details {
    imoAssetName: string | undefined;
    inventoryNumber: number;
    categoryName: string | undefined;
    assetClassCodes: string | undefined;
    datePIF: moment.Moment | undefined;
    dateStartDeprec: moment.Moment | undefined;
    durataUtila: number;
    durataScursaUtila: number;
    initialValue: number;
    currentValue: number;
    monthlyDeprec: number;
    cumulativDeprec: number;
    yearDeprec: number;
    storageName: string | undefined;
    outOfUse: string | undefined;
    isSold: string | undefined;
    isInUse: string | undefined;
    imoAssetAccount: string | undefined;
    deprecAccount: string | undefined;
    expenseAccount: string | undefined;
    hasModerniz: string | undefined;
    imoAssetModernizDetails: ImoAssetModerniz[] | undefined;
    showModerniz: boolean;

    constructor(data?: IImoAssetV2Details) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imoAssetName = _data["imoAssetName"];
            this.inventoryNumber = _data["inventoryNumber"];
            this.categoryName = _data["categoryName"];
            this.assetClassCodes = _data["assetClassCodes"];
            this.datePIF = _data["datePIF"] ? moment(_data["datePIF"].toString()) : <any>undefined;
            this.dateStartDeprec = _data["dateStartDeprec"] ? moment(_data["dateStartDeprec"].toString()) : <any>undefined;
            this.durataUtila = _data["durataUtila"];
            this.durataScursaUtila = _data["durataScursaUtila"];
            this.initialValue = _data["initialValue"];
            this.currentValue = _data["currentValue"];
            this.monthlyDeprec = _data["monthlyDeprec"];
            this.cumulativDeprec = _data["cumulativDeprec"];
            this.yearDeprec = _data["yearDeprec"];
            this.storageName = _data["storageName"];
            this.outOfUse = _data["outOfUse"];
            this.isSold = _data["isSold"];
            this.isInUse = _data["isInUse"];
            this.imoAssetAccount = _data["imoAssetAccount"];
            this.deprecAccount = _data["deprecAccount"];
            this.expenseAccount = _data["expenseAccount"];
            this.hasModerniz = _data["hasModerniz"];
            if (Array.isArray(_data["imoAssetModernizDetails"])) {
                this.imoAssetModernizDetails = [] as any;
                for (let item of _data["imoAssetModernizDetails"])
                    this.imoAssetModernizDetails.push(ImoAssetModerniz.fromJS(item));
            }
            this.showModerniz = _data["showModerniz"];
        }
    }

    static fromJS(data: any): ImoAssetV2Details {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetV2Details();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imoAssetName"] = this.imoAssetName;
        data["inventoryNumber"] = this.inventoryNumber;
        data["categoryName"] = this.categoryName;
        data["assetClassCodes"] = this.assetClassCodes;
        data["datePIF"] = this.datePIF ? this.datePIF.toISOString() : <any>undefined;
        data["dateStartDeprec"] = this.dateStartDeprec ? this.dateStartDeprec.toISOString() : <any>undefined;
        data["durataUtila"] = this.durataUtila;
        data["durataScursaUtila"] = this.durataScursaUtila;
        data["initialValue"] = this.initialValue;
        data["currentValue"] = this.currentValue;
        data["monthlyDeprec"] = this.monthlyDeprec;
        data["cumulativDeprec"] = this.cumulativDeprec;
        data["yearDeprec"] = this.yearDeprec;
        data["storageName"] = this.storageName;
        data["outOfUse"] = this.outOfUse;
        data["isSold"] = this.isSold;
        data["isInUse"] = this.isInUse;
        data["imoAssetAccount"] = this.imoAssetAccount;
        data["deprecAccount"] = this.deprecAccount;
        data["expenseAccount"] = this.expenseAccount;
        data["hasModerniz"] = this.hasModerniz;
        if (Array.isArray(this.imoAssetModernizDetails)) {
            data["imoAssetModernizDetails"] = [];
            for (let item of this.imoAssetModernizDetails)
                data["imoAssetModernizDetails"].push(item.toJSON());
        }
        data["showModerniz"] = this.showModerniz;
        return data;
    }

    clone(): ImoAssetV2Details {
        const json = this.toJSON();
        let result = new ImoAssetV2Details();
        result.init(json);
        return result;
    }
}

export interface IImoAssetV2Details {
    imoAssetName: string | undefined;
    inventoryNumber: number;
    categoryName: string | undefined;
    assetClassCodes: string | undefined;
    datePIF: moment.Moment | undefined;
    dateStartDeprec: moment.Moment | undefined;
    durataUtila: number;
    durataScursaUtila: number;
    initialValue: number;
    currentValue: number;
    monthlyDeprec: number;
    cumulativDeprec: number;
    yearDeprec: number;
    storageName: string | undefined;
    outOfUse: string | undefined;
    isSold: string | undefined;
    isInUse: string | undefined;
    imoAssetAccount: string | undefined;
    deprecAccount: string | undefined;
    expenseAccount: string | undefined;
    hasModerniz: string | undefined;
    imoAssetModernizDetails: ImoAssetModerniz[] | undefined;
    showModerniz: boolean;
}

export class ImoAssetRegV2Report implements IImoAssetRegV2Report {
    operationDate: moment.Moment;
    storageName: string | undefined;
    imoAssetDetails: ImoAssetV2Details[] | undefined;

    constructor(data?: IImoAssetRegV2Report) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.storageName = _data["storageName"];
            if (Array.isArray(_data["imoAssetDetails"])) {
                this.imoAssetDetails = [] as any;
                for (let item of _data["imoAssetDetails"])
                    this.imoAssetDetails.push(ImoAssetV2Details.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImoAssetRegV2Report {
        data = typeof data === 'object' ? data : {};
        let result = new ImoAssetRegV2Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["storageName"] = this.storageName;
        if (Array.isArray(this.imoAssetDetails)) {
            data["imoAssetDetails"] = [];
            for (let item of this.imoAssetDetails)
                data["imoAssetDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): ImoAssetRegV2Report {
        const json = this.toJSON();
        let result = new ImoAssetRegV2Report();
        result.init(json);
        return result;
    }
}

export interface IImoAssetRegV2Report {
    operationDate: moment.Moment;
    storageName: string | undefined;
    imoAssetDetails: ImoAssetV2Details[] | undefined;
}

export class InventoryDetails implements IInventoryDetails {
    storage: string | undefined;
    imoAssetName: string | undefined;
    inventoryNr: number;
    um: string | undefined;
    stockScriptic: number;
    stockFaptic: number;
    unitPrice: number;
    inventoryValue: number;
    operationDate: moment.Moment | undefined;

    constructor(data?: IInventoryDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storage = _data["storage"];
            this.imoAssetName = _data["imoAssetName"];
            this.inventoryNr = _data["inventoryNr"];
            this.um = _data["um"];
            this.stockScriptic = _data["stockScriptic"];
            this.stockFaptic = _data["stockFaptic"];
            this.unitPrice = _data["unitPrice"];
            this.inventoryValue = _data["inventoryValue"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InventoryDetails {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storage"] = this.storage;
        data["imoAssetName"] = this.imoAssetName;
        data["inventoryNr"] = this.inventoryNr;
        data["um"] = this.um;
        data["stockScriptic"] = this.stockScriptic;
        data["stockFaptic"] = this.stockFaptic;
        data["unitPrice"] = this.unitPrice;
        data["inventoryValue"] = this.inventoryValue;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): InventoryDetails {
        const json = this.toJSON();
        let result = new InventoryDetails();
        result.init(json);
        return result;
    }
}

export interface IInventoryDetails {
    storage: string | undefined;
    imoAssetName: string | undefined;
    inventoryNr: number;
    um: string | undefined;
    stockScriptic: number;
    stockFaptic: number;
    unitPrice: number;
    inventoryValue: number;
    operationDate: moment.Moment | undefined;
}

export class InvObjectImoAssetReport implements IInvObjectImoAssetReport {
    operationDate: moment.Moment;
    storage: string | undefined;
    tenantId: number;
    parameters: string | undefined;
    inventoryDetails: InventoryDetails[] | undefined;

    constructor(data?: IInvObjectImoAssetReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.storage = _data["storage"];
            this.tenantId = _data["tenantId"];
            this.parameters = _data["parameters"];
            if (Array.isArray(_data["inventoryDetails"])) {
                this.inventoryDetails = [] as any;
                for (let item of _data["inventoryDetails"])
                    this.inventoryDetails.push(InventoryDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvObjectImoAssetReport {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectImoAssetReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["storage"] = this.storage;
        data["tenantId"] = this.tenantId;
        data["parameters"] = this.parameters;
        if (Array.isArray(this.inventoryDetails)) {
            data["inventoryDetails"] = [];
            for (let item of this.inventoryDetails)
                data["inventoryDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvObjectImoAssetReport {
        const json = this.toJSON();
        let result = new InvObjectImoAssetReport();
        result.init(json);
        return result;
    }
}

export interface IInvObjectImoAssetReport {
    operationDate: moment.Moment;
    storage: string | undefined;
    tenantId: number;
    parameters: string | undefined;
    inventoryDetails: InventoryDetails[] | undefined;
}

export class BonTransferDetail implements IBonTransferDetail {
    name: string | undefined;
    inventoryNumber: number;
    quantity: number;
    inventoryValue: number;

    constructor(data?: IBonTransferDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.inventoryNumber = _data["inventoryNumber"];
            this.quantity = _data["quantity"];
            this.inventoryValue = _data["inventoryValue"];
        }
    }

    static fromJS(data: any): BonTransferDetail {
        data = typeof data === 'object' ? data : {};
        let result = new BonTransferDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["inventoryNumber"] = this.inventoryNumber;
        data["quantity"] = this.quantity;
        data["inventoryValue"] = this.inventoryValue;
        return data;
    }

    clone(): BonTransferDetail {
        const json = this.toJSON();
        let result = new BonTransferDetail();
        result.init(json);
        return result;
    }
}

export interface IBonTransferDetail {
    name: string | undefined;
    inventoryNumber: number;
    quantity: number;
    inventoryValue: number;
}

export class BonTransferModel implements IBonTransferModel {
    documentNumber: number;
    operationDate: moment.Moment;
    storageInName: string | undefined;
    storageOutName: string | undefined;
    personStoreInName: string | undefined;
    personStoreOutName: string | undefined;
    tenantId: number;
    parameters: string | undefined;
    bonTransferDetails: BonTransferDetail[] | undefined;

    constructor(data?: IBonTransferModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentNumber = _data["documentNumber"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.storageInName = _data["storageInName"];
            this.storageOutName = _data["storageOutName"];
            this.personStoreInName = _data["personStoreInName"];
            this.personStoreOutName = _data["personStoreOutName"];
            this.tenantId = _data["tenantId"];
            this.parameters = _data["parameters"];
            if (Array.isArray(_data["bonTransferDetails"])) {
                this.bonTransferDetails = [] as any;
                for (let item of _data["bonTransferDetails"])
                    this.bonTransferDetails.push(BonTransferDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BonTransferModel {
        data = typeof data === 'object' ? data : {};
        let result = new BonTransferModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentNumber"] = this.documentNumber;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["storageInName"] = this.storageInName;
        data["storageOutName"] = this.storageOutName;
        data["personStoreInName"] = this.personStoreInName;
        data["personStoreOutName"] = this.personStoreOutName;
        data["tenantId"] = this.tenantId;
        data["parameters"] = this.parameters;
        if (Array.isArray(this.bonTransferDetails)) {
            data["bonTransferDetails"] = [];
            for (let item of this.bonTransferDetails)
                data["bonTransferDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): BonTransferModel {
        const json = this.toJSON();
        let result = new BonTransferModel();
        result.init(json);
        return result;
    }
}

export interface IBonTransferModel {
    documentNumber: number;
    operationDate: moment.Moment;
    storageInName: string | undefined;
    storageOutName: string | undefined;
    personStoreInName: string | undefined;
    personStoreOutName: string | undefined;
    tenantId: number;
    parameters: string | undefined;
    bonTransferDetails: BonTransferDetail[] | undefined;
}

export class DispositionModel implements IDispositionModel {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    headerParams: string | undefined;
    footerParams: string | undefined;
    sum: number;
    sumInWords: string | undefined;
    description: string | undefined;
    name: string | undefined;
    ci: string | undefined;
    serie_CI: string | undefined;
    nr_CI: string | undefined;
    documentNumber: number;
    documentDate: moment.Moment;
    currencyCode: string | undefined;
    plataSum: number | undefined;
    plataCurrencyCode: string | undefined;
    nrChitanta: number | undefined;
    numePrenume: string | undefined;
    tipDoc: string | undefined;
    actIdentitate: string | undefined;

    constructor(data?: IDispositionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.headerParams = _data["headerParams"];
            this.footerParams = _data["footerParams"];
            this.sum = _data["sum"];
            this.sumInWords = _data["sumInWords"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.ci = _data["ci"];
            this.serie_CI = _data["serie_CI"];
            this.nr_CI = _data["nr_CI"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.currencyCode = _data["currencyCode"];
            this.plataSum = _data["plataSum"];
            this.plataCurrencyCode = _data["plataCurrencyCode"];
            this.nrChitanta = _data["nrChitanta"];
            this.numePrenume = _data["numePrenume"];
            this.tipDoc = _data["tipDoc"];
            this.actIdentitate = _data["actIdentitate"];
        }
    }

    static fromJS(data: any): DispositionModel {
        data = typeof data === 'object' ? data : {};
        let result = new DispositionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["headerParams"] = this.headerParams;
        data["footerParams"] = this.footerParams;
        data["sum"] = this.sum;
        data["sumInWords"] = this.sumInWords;
        data["description"] = this.description;
        data["name"] = this.name;
        data["ci"] = this.ci;
        data["serie_CI"] = this.serie_CI;
        data["nr_CI"] = this.nr_CI;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["currencyCode"] = this.currencyCode;
        data["plataSum"] = this.plataSum;
        data["plataCurrencyCode"] = this.plataCurrencyCode;
        data["nrChitanta"] = this.nrChitanta;
        data["numePrenume"] = this.numePrenume;
        data["tipDoc"] = this.tipDoc;
        data["actIdentitate"] = this.actIdentitate;
        return data;
    }

    clone(): DispositionModel {
        const json = this.toJSON();
        let result = new DispositionModel();
        result.init(json);
        return result;
    }
}

export interface IDispositionModel {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    headerParams: string | undefined;
    footerParams: string | undefined;
    sum: number;
    sumInWords: string | undefined;
    description: string | undefined;
    name: string | undefined;
    ci: string | undefined;
    serie_CI: string | undefined;
    nr_CI: string | undefined;
    documentNumber: number;
    documentDate: moment.Moment;
    currencyCode: string | undefined;
    plataSum: number | undefined;
    plataCurrencyCode: string | undefined;
    nrChitanta: number | undefined;
    numePrenume: string | undefined;
    tipDoc: string | undefined;
    actIdentitate: string | undefined;
}

export class DeclaratieCasierDetails implements IDeclaratieCasierDetails {
    dispositionDate: moment.Moment;
    dispositionNumber: number;
    documentTypeName: string | undefined;
    description: string | undefined;
    quantity: number;
    um: number;
    price: number;
    value: number;

    constructor(data?: IDeclaratieCasierDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispositionDate = _data["dispositionDate"] ? moment(_data["dispositionDate"].toString()) : <any>undefined;
            this.dispositionNumber = _data["dispositionNumber"];
            this.documentTypeName = _data["documentTypeName"];
            this.description = _data["description"];
            this.quantity = _data["quantity"];
            this.um = _data["um"];
            this.price = _data["price"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DeclaratieCasierDetails {
        data = typeof data === 'object' ? data : {};
        let result = new DeclaratieCasierDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispositionDate"] = this.dispositionDate ? this.dispositionDate.toISOString() : <any>undefined;
        data["dispositionNumber"] = this.dispositionNumber;
        data["documentTypeName"] = this.documentTypeName;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["um"] = this.um;
        data["price"] = this.price;
        data["value"] = this.value;
        return data;
    }

    clone(): DeclaratieCasierDetails {
        const json = this.toJSON();
        let result = new DeclaratieCasierDetails();
        result.init(json);
        return result;
    }
}

export interface IDeclaratieCasierDetails {
    dispositionDate: moment.Moment;
    dispositionNumber: number;
    documentTypeName: string | undefined;
    description: string | undefined;
    quantity: number;
    um: number;
    price: number;
    value: number;
}

export class DeclaratieCasierModel implements IDeclaratieCasierModel {
    dataStart: moment.Moment;
    dataDecizie: moment.Moment;
    numeCasier: string | undefined;
    currencyId: number;
    currencyName: string | undefined;
    operationType: string | undefined;
    detailsIn: DeclaratieCasierDetails[] | undefined;
    detailsOut: DeclaratieCasierDetails[] | undefined;

    constructor(data?: IDeclaratieCasierModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataDecizie = _data["dataDecizie"] ? moment(_data["dataDecizie"].toString()) : <any>undefined;
            this.numeCasier = _data["numeCasier"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.operationType = _data["operationType"];
            if (Array.isArray(_data["detailsIn"])) {
                this.detailsIn = [] as any;
                for (let item of _data["detailsIn"])
                    this.detailsIn.push(DeclaratieCasierDetails.fromJS(item));
            }
            if (Array.isArray(_data["detailsOut"])) {
                this.detailsOut = [] as any;
                for (let item of _data["detailsOut"])
                    this.detailsOut.push(DeclaratieCasierDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeclaratieCasierModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeclaratieCasierModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataDecizie"] = this.dataDecizie ? this.dataDecizie.toISOString() : <any>undefined;
        data["numeCasier"] = this.numeCasier;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["operationType"] = this.operationType;
        if (Array.isArray(this.detailsIn)) {
            data["detailsIn"] = [];
            for (let item of this.detailsIn)
                data["detailsIn"].push(item.toJSON());
        }
        if (Array.isArray(this.detailsOut)) {
            data["detailsOut"] = [];
            for (let item of this.detailsOut)
                data["detailsOut"].push(item.toJSON());
        }
        return data;
    }

    clone(): DeclaratieCasierModel {
        const json = this.toJSON();
        let result = new DeclaratieCasierModel();
        result.init(json);
        return result;
    }
}

export interface IDeclaratieCasierModel {
    dataStart: moment.Moment;
    dataDecizie: moment.Moment;
    numeCasier: string | undefined;
    currencyId: number;
    currencyName: string | undefined;
    operationType: string | undefined;
    detailsIn: DeclaratieCasierDetails[] | undefined;
    detailsOut: DeclaratieCasierDetails[] | undefined;
}

export class ReportCalcItem implements IReportCalcItem {
    reportDate: moment.Moment;
    rowName: string | undefined;
    rowValue: number;
    rowCode: number | undefined;
    orderView: number;
    reportConfigRowId: number;
    bold: boolean;
    calculat: boolean;

    constructor(data?: IReportCalcItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportDate = _data["reportDate"] ? moment(_data["reportDate"].toString()) : <any>undefined;
            this.rowName = _data["rowName"];
            this.rowValue = _data["rowValue"];
            this.rowCode = _data["rowCode"];
            this.orderView = _data["orderView"];
            this.reportConfigRowId = _data["reportConfigRowId"];
            this.bold = _data["bold"];
            this.calculat = _data["calculat"];
        }
    }

    static fromJS(data: any): ReportCalcItem {
        data = typeof data === 'object' ? data : {};
        let result = new ReportCalcItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportDate"] = this.reportDate ? this.reportDate.toISOString() : <any>undefined;
        data["rowName"] = this.rowName;
        data["rowValue"] = this.rowValue;
        data["rowCode"] = this.rowCode;
        data["orderView"] = this.orderView;
        data["reportConfigRowId"] = this.reportConfigRowId;
        data["bold"] = this.bold;
        data["calculat"] = this.calculat;
        return data;
    }

    clone(): ReportCalcItem {
        const json = this.toJSON();
        let result = new ReportCalcItem();
        result.init(json);
        return result;
    }
}

export interface IReportCalcItem {
    reportDate: moment.Moment;
    rowName: string | undefined;
    rowValue: number;
    rowCode: number | undefined;
    orderView: number;
    reportConfigRowId: number;
    bold: boolean;
    calculat: boolean;
}

export class ReportCalc implements IReportCalc {
    appClientName: string | undefined;
    reportTitle: string | undefined;
    subTitle: string | undefined;
    reportCalcItems: ReportCalcItem[] | undefined;

    constructor(data?: IReportCalc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientName = _data["appClientName"];
            this.reportTitle = _data["reportTitle"];
            this.subTitle = _data["subTitle"];
            if (Array.isArray(_data["reportCalcItems"])) {
                this.reportCalcItems = [] as any;
                for (let item of _data["reportCalcItems"])
                    this.reportCalcItems.push(ReportCalcItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportCalc {
        data = typeof data === 'object' ? data : {};
        let result = new ReportCalc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientName"] = this.appClientName;
        data["reportTitle"] = this.reportTitle;
        data["subTitle"] = this.subTitle;
        if (Array.isArray(this.reportCalcItems)) {
            data["reportCalcItems"] = [];
            for (let item of this.reportCalcItems)
                data["reportCalcItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReportCalc {
        const json = this.toJSON();
        let result = new ReportCalc();
        result.init(json);
        return result;
    }
}

export interface IReportCalc {
    appClientName: string | undefined;
    reportTitle: string | undefined;
    subTitle: string | undefined;
    reportCalcItems: ReportCalcItem[] | undefined;
}

export class RegistruInventarItem implements IRegistruInventarItem {
    id: number;
    accountName: string | undefined;
    accountId: number;
    value: number;
    inventoryValue: number;

    constructor(data?: IRegistruInventarItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountName = _data["accountName"];
            this.accountId = _data["accountId"];
            this.value = _data["value"];
            this.inventoryValue = _data["inventoryValue"];
        }
    }

    static fromJS(data: any): RegistruInventarItem {
        data = typeof data === 'object' ? data : {};
        let result = new RegistruInventarItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountName"] = this.accountName;
        data["accountId"] = this.accountId;
        data["value"] = this.value;
        data["inventoryValue"] = this.inventoryValue;
        return data;
    }

    clone(): RegistruInventarItem {
        const json = this.toJSON();
        let result = new RegistruInventarItem();
        result.init(json);
        return result;
    }
}

export interface IRegistruInventarItem {
    id: number;
    accountName: string | undefined;
    accountId: number;
    value: number;
    inventoryValue: number;
}

export class RegistruInventarReport implements IRegistruInventarReport {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    reportDate: moment.Moment;
    registruInventarList: RegistruInventarItem[] | undefined;

    constructor(data?: IRegistruInventarReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.reportDate = _data["reportDate"] ? moment(_data["reportDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["registruInventarList"])) {
                this.registruInventarList = [] as any;
                for (let item of _data["registruInventarList"])
                    this.registruInventarList.push(RegistruInventarItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegistruInventarReport {
        data = typeof data === 'object' ? data : {};
        let result = new RegistruInventarReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["reportDate"] = this.reportDate ? this.reportDate.toISOString() : <any>undefined;
        if (Array.isArray(this.registruInventarList)) {
            data["registruInventarList"] = [];
            for (let item of this.registruInventarList)
                data["registruInventarList"].push(item.toJSON());
        }
        return data;
    }

    clone(): RegistruInventarReport {
        const json = this.toJSON();
        let result = new RegistruInventarReport();
        result.init(json);
        return result;
    }
}

export interface IRegistruInventarReport {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    reportDate: moment.Moment;
    registruInventarList: RegistruInventarItem[] | undefined;
}

export class InvoiceDetailsReport implements IInvoiceDetailsReport {
    description: string | undefined;
    quantity: number;
    value: number;

    constructor(data?: IInvoiceDetailsReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.quantity = _data["quantity"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): InvoiceDetailsReport {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetailsReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["value"] = this.value;
        return data;
    }

    clone(): InvoiceDetailsReport {
        const json = this.toJSON();
        let result = new InvoiceDetailsReport();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetailsReport {
    description: string | undefined;
    quantity: number;
    value: number;
}

export class InvoiceModel implements IInvoiceModel {
    tenantId: number;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    appClientAddress: string | undefined;
    appClientBank: string | undefined;
    appClientBankAccount: string | undefined;
    clientName: string | undefined;
    clientId1: string | undefined;
    clientId2: string | undefined;
    clientAddress: string | undefined;
    clientBank: string | undefined;
    clientBankAccount: string | undefined;
    value: number;
    currencyName: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    total: number;
    invoiceDetails: InvoiceDetailsReport[] | undefined;

    constructor(data?: IInvoiceModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.appClientAddress = _data["appClientAddress"];
            this.appClientBank = _data["appClientBank"];
            this.appClientBankAccount = _data["appClientBankAccount"];
            this.clientName = _data["clientName"];
            this.clientId1 = _data["clientId1"];
            this.clientId2 = _data["clientId2"];
            this.clientAddress = _data["clientAddress"];
            this.clientBank = _data["clientBank"];
            this.clientBankAccount = _data["clientBankAccount"];
            this.value = _data["value"];
            this.currencyName = _data["currencyName"];
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceSeries = _data["invoiceSeries"];
            this.total = _data["total"];
            if (Array.isArray(_data["invoiceDetails"])) {
                this.invoiceDetails = [] as any;
                for (let item of _data["invoiceDetails"])
                    this.invoiceDetails.push(InvoiceDetailsReport.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceModel {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["appClientAddress"] = this.appClientAddress;
        data["appClientBank"] = this.appClientBank;
        data["appClientBankAccount"] = this.appClientBankAccount;
        data["clientName"] = this.clientName;
        data["clientId1"] = this.clientId1;
        data["clientId2"] = this.clientId2;
        data["clientAddress"] = this.clientAddress;
        data["clientBank"] = this.clientBank;
        data["clientBankAccount"] = this.clientBankAccount;
        data["value"] = this.value;
        data["currencyName"] = this.currencyName;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceSeries"] = this.invoiceSeries;
        data["total"] = this.total;
        if (Array.isArray(this.invoiceDetails)) {
            data["invoiceDetails"] = [];
            for (let item of this.invoiceDetails)
                data["invoiceDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvoiceModel {
        const json = this.toJSON();
        let result = new InvoiceModel();
        result.init(json);
        return result;
    }
}

export interface IInvoiceModel {
    tenantId: number;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    appClientAddress: string | undefined;
    appClientBank: string | undefined;
    appClientBankAccount: string | undefined;
    clientName: string | undefined;
    clientId1: string | undefined;
    clientId2: string | undefined;
    clientAddress: string | undefined;
    clientBank: string | undefined;
    clientBankAccount: string | undefined;
    value: number;
    currencyName: string | undefined;
    invoiceDate: moment.Moment;
    invoiceNumber: string | undefined;
    invoiceSeries: string | undefined;
    total: number;
    invoiceDetails: InvoiceDetailsReport[] | undefined;
}

export class SitFinanReportColList implements ISitFinanReportColList {
    col1: string | undefined;
    col2: string | undefined;
    col3: string | undefined;
    col4: string | undefined;
    col5: string | undefined;
    col6: string | undefined;

    constructor(data?: ISitFinanReportColList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.col1 = _data["col1"];
            this.col2 = _data["col2"];
            this.col3 = _data["col3"];
            this.col4 = _data["col4"];
            this.col5 = _data["col5"];
            this.col6 = _data["col6"];
        }
    }

    static fromJS(data: any): SitFinanReportColList {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanReportColList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["col1"] = this.col1;
        data["col2"] = this.col2;
        data["col3"] = this.col3;
        data["col4"] = this.col4;
        data["col5"] = this.col5;
        data["col6"] = this.col6;
        return data;
    }

    clone(): SitFinanReportColList {
        const json = this.toJSON();
        let result = new SitFinanReportColList();
        result.init(json);
        return result;
    }
}

export interface ISitFinanReportColList {
    col1: string | undefined;
    col2: string | undefined;
    col3: string | undefined;
    col4: string | undefined;
    col5: string | undefined;
    col6: string | undefined;
}

export class SitFinanReportDetList implements ISitFinanReportDetList {
    calcRowId: number;
    rowId: number;
    rowName: string | undefined;
    rowNr: string | undefined;
    rowNota: string | undefined;
    orderView: number;
    totalRow: boolean;
    bold: boolean;
    negativeValue: boolean;
    decimalNr: number;
    val1: number | undefined;
    val2: number | undefined;
    val3: number | undefined;
    val4: number | undefined;
    val5: number | undefined;
    val6: number | undefined;
    balanceDate: moment.Moment | undefined;

    constructor(data?: ISitFinanReportDetList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calcRowId = _data["calcRowId"];
            this.rowId = _data["rowId"];
            this.rowName = _data["rowName"];
            this.rowNr = _data["rowNr"];
            this.rowNota = _data["rowNota"];
            this.orderView = _data["orderView"];
            this.totalRow = _data["totalRow"];
            this.bold = _data["bold"];
            this.negativeValue = _data["negativeValue"];
            this.decimalNr = _data["decimalNr"];
            this.val1 = _data["val1"];
            this.val2 = _data["val2"];
            this.val3 = _data["val3"];
            this.val4 = _data["val4"];
            this.val5 = _data["val5"];
            this.val6 = _data["val6"];
            this.balanceDate = _data["balanceDate"] ? moment(_data["balanceDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SitFinanReportDetList {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanReportDetList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calcRowId"] = this.calcRowId;
        data["rowId"] = this.rowId;
        data["rowName"] = this.rowName;
        data["rowNr"] = this.rowNr;
        data["rowNota"] = this.rowNota;
        data["orderView"] = this.orderView;
        data["totalRow"] = this.totalRow;
        data["bold"] = this.bold;
        data["negativeValue"] = this.negativeValue;
        data["decimalNr"] = this.decimalNr;
        data["val1"] = this.val1;
        data["val2"] = this.val2;
        data["val3"] = this.val3;
        data["val4"] = this.val4;
        data["val5"] = this.val5;
        data["val6"] = this.val6;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): SitFinanReportDetList {
        const json = this.toJSON();
        let result = new SitFinanReportDetList();
        result.init(json);
        return result;
    }
}

export interface ISitFinanReportDetList {
    calcRowId: number;
    rowId: number;
    rowName: string | undefined;
    rowNr: string | undefined;
    rowNota: string | undefined;
    orderView: number;
    totalRow: boolean;
    bold: boolean;
    negativeValue: boolean;
    decimalNr: number;
    val1: number | undefined;
    val2: number | undefined;
    val3: number | undefined;
    val4: number | undefined;
    val5: number | undefined;
    val6: number | undefined;
    balanceDate: moment.Moment | undefined;
}

export class SitFinanReportModel implements ISitFinanReportModel {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    balanceDate: moment.Moment;
    reportName: string | undefined;
    nrCol: number;
    notaBefore: string | undefined;
    notaAfter: string | undefined;
    columnReport: SitFinanReportColList;
    details: SitFinanReportDetList[] | undefined;

    constructor(data?: ISitFinanReportModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.balanceDate = _data["balanceDate"] ? moment(_data["balanceDate"].toString()) : <any>undefined;
            this.reportName = _data["reportName"];
            this.nrCol = _data["nrCol"];
            this.notaBefore = _data["notaBefore"];
            this.notaAfter = _data["notaAfter"];
            this.columnReport = _data["columnReport"] ? SitFinanReportColList.fromJS(_data["columnReport"]) : <any>undefined;
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(SitFinanReportDetList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitFinanReportModel {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanReportModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        data["reportName"] = this.reportName;
        data["nrCol"] = this.nrCol;
        data["notaBefore"] = this.notaBefore;
        data["notaAfter"] = this.notaAfter;
        data["columnReport"] = this.columnReport ? this.columnReport.toJSON() : <any>undefined;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): SitFinanReportModel {
        const json = this.toJSON();
        let result = new SitFinanReportModel();
        result.init(json);
        return result;
    }
}

export interface ISitFinanReportModel {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    balanceDate: moment.Moment;
    reportName: string | undefined;
    nrCol: number;
    notaBefore: string | undefined;
    notaAfter: string | undefined;
    columnReport: SitFinanReportColList;
    details: SitFinanReportDetList[] | undefined;
}

export class InvObjectReportDetail implements IInvObjectReportDetail {
    invObjectName: string | undefined;
    inventoryNr: number;
    documentDate: moment.Moment;
    inUseDate: moment.Moment | undefined;
    thirdParty: string | undefined;
    storageId: number | undefined;
    storage: string | undefined;
    value: number;
    inUse: string | undefined;
    invObjectAccount: string | undefined;
    accountForGroup: string | undefined;
    expenseAccount: string | undefined;

    constructor(data?: IInvObjectReportDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invObjectName = _data["invObjectName"];
            this.inventoryNr = _data["inventoryNr"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.inUseDate = _data["inUseDate"] ? moment(_data["inUseDate"].toString()) : <any>undefined;
            this.thirdParty = _data["thirdParty"];
            this.storageId = _data["storageId"];
            this.storage = _data["storage"];
            this.value = _data["value"];
            this.inUse = _data["inUse"];
            this.invObjectAccount = _data["invObjectAccount"];
            this.accountForGroup = _data["accountForGroup"];
            this.expenseAccount = _data["expenseAccount"];
        }
    }

    static fromJS(data: any): InvObjectReportDetail {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectReportDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invObjectName"] = this.invObjectName;
        data["inventoryNr"] = this.inventoryNr;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["inUseDate"] = this.inUseDate ? this.inUseDate.toISOString() : <any>undefined;
        data["thirdParty"] = this.thirdParty;
        data["storageId"] = this.storageId;
        data["storage"] = this.storage;
        data["value"] = this.value;
        data["inUse"] = this.inUse;
        data["invObjectAccount"] = this.invObjectAccount;
        data["accountForGroup"] = this.accountForGroup;
        data["expenseAccount"] = this.expenseAccount;
        return data;
    }

    clone(): InvObjectReportDetail {
        const json = this.toJSON();
        let result = new InvObjectReportDetail();
        result.init(json);
        return result;
    }
}

export interface IInvObjectReportDetail {
    invObjectName: string | undefined;
    inventoryNr: number;
    documentDate: moment.Moment;
    inUseDate: moment.Moment | undefined;
    thirdParty: string | undefined;
    storageId: number | undefined;
    storage: string | undefined;
    value: number;
    inUse: string | undefined;
    invObjectAccount: string | undefined;
    accountForGroup: string | undefined;
    expenseAccount: string | undefined;
}

export class InvObjectReportModel implements IInvObjectReportModel {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    invObjectDate: moment.Moment;
    invObjectDetails: InvObjectReportDetail[] | undefined;

    constructor(data?: IInvObjectReportModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.invObjectDate = _data["invObjectDate"] ? moment(_data["invObjectDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["invObjectDetails"])) {
                this.invObjectDetails = [] as any;
                for (let item of _data["invObjectDetails"])
                    this.invObjectDetails.push(InvObjectReportDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvObjectReportModel {
        data = typeof data === 'object' ? data : {};
        let result = new InvObjectReportModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["invObjectDate"] = this.invObjectDate ? this.invObjectDate.toISOString() : <any>undefined;
        if (Array.isArray(this.invObjectDetails)) {
            data["invObjectDetails"] = [];
            for (let item of this.invObjectDetails)
                data["invObjectDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvObjectReportModel {
        const json = this.toJSON();
        let result = new InvObjectReportModel();
        result.init(json);
        return result;
    }
}

export interface IInvObjectReportModel {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    invObjectDate: moment.Moment;
    invObjectDetails: InvObjectReportDetail[] | undefined;
}

export class BonConsumDetail implements IBonConsumDetail {
    name: string | undefined;
    quantity: number;
    inventoryValue: number;

    constructor(data?: IBonConsumDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.inventoryValue = _data["inventoryValue"];
        }
    }

    static fromJS(data: any): BonConsumDetail {
        data = typeof data === 'object' ? data : {};
        let result = new BonConsumDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["inventoryValue"] = this.inventoryValue;
        return data;
    }

    clone(): BonConsumDetail {
        const json = this.toJSON();
        let result = new BonConsumDetail();
        result.init(json);
        return result;
    }
}

export interface IBonConsumDetail {
    name: string | undefined;
    quantity: number;
    inventoryValue: number;
}

export class BonConsumModel implements IBonConsumModel {
    documentNumber: number;
    operationDate: moment.Moment;
    tenantId: number;
    personStoreInName: string | undefined;
    personStoreOutName: string | undefined;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    bonConsumDetails: BonConsumDetail[] | undefined;

    constructor(data?: IBonConsumModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentNumber = _data["documentNumber"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.personStoreInName = _data["personStoreInName"];
            this.personStoreOutName = _data["personStoreOutName"];
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            if (Array.isArray(_data["bonConsumDetails"])) {
                this.bonConsumDetails = [] as any;
                for (let item of _data["bonConsumDetails"])
                    this.bonConsumDetails.push(BonConsumDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BonConsumModel {
        data = typeof data === 'object' ? data : {};
        let result = new BonConsumModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentNumber"] = this.documentNumber;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["personStoreInName"] = this.personStoreInName;
        data["personStoreOutName"] = this.personStoreOutName;
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        if (Array.isArray(this.bonConsumDetails)) {
            data["bonConsumDetails"] = [];
            for (let item of this.bonConsumDetails)
                data["bonConsumDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): BonConsumModel {
        const json = this.toJSON();
        let result = new BonConsumModel();
        result.init(json);
        return result;
    }
}

export interface IBonConsumModel {
    documentNumber: number;
    operationDate: moment.Moment;
    tenantId: number;
    personStoreInName: string | undefined;
    personStoreOutName: string | undefined;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    bonConsumDetails: BonConsumDetail[] | undefined;
}

export class SoldDetail implements ISoldDetail {
    currencyId: number | undefined;
    currencyName: string | undefined;
    soldValuta: number;
    soldEchivalent: number;
    accountId: number;
    accountName: string | undefined;
    ic: string | undefined;
    rulajDb: number;
    rulajCr: number;
    comisionPerceput: number;
    dobandaIncasata: number;
    currentDate: moment.Moment;

    constructor(data?: ISoldDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.soldValuta = _data["soldValuta"];
            this.soldEchivalent = _data["soldEchivalent"];
            this.accountId = _data["accountId"];
            this.accountName = _data["accountName"];
            this.ic = _data["ic"];
            this.rulajDb = _data["rulajDb"];
            this.rulajCr = _data["rulajCr"];
            this.comisionPerceput = _data["comisionPerceput"];
            this.dobandaIncasata = _data["dobandaIncasata"];
            this.currentDate = _data["currentDate"] ? moment(_data["currentDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SoldDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SoldDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["soldValuta"] = this.soldValuta;
        data["soldEchivalent"] = this.soldEchivalent;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["ic"] = this.ic;
        data["rulajDb"] = this.rulajDb;
        data["rulajCr"] = this.rulajCr;
        data["comisionPerceput"] = this.comisionPerceput;
        data["dobandaIncasata"] = this.dobandaIncasata;
        data["currentDate"] = this.currentDate ? this.currentDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): SoldDetail {
        const json = this.toJSON();
        let result = new SoldDetail();
        result.init(json);
        return result;
    }
}

export interface ISoldDetail {
    currencyId: number | undefined;
    currencyName: string | undefined;
    soldValuta: number;
    soldEchivalent: number;
    accountId: number;
    accountName: string | undefined;
    ic: string | undefined;
    rulajDb: number;
    rulajCr: number;
    comisionPerceput: number;
    dobandaIncasata: number;
    currentDate: moment.Moment;
}

export class SoldContCurentModel implements ISoldContCurentModel {
    appClientName: string | undefined;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    tipPerioada: string | undefined;
    soldDetails: SoldDetail[] | undefined;

    constructor(data?: ISoldContCurentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientName = _data["appClientName"];
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.tipPerioada = _data["tipPerioada"];
            if (Array.isArray(_data["soldDetails"])) {
                this.soldDetails = [] as any;
                for (let item of _data["soldDetails"])
                    this.soldDetails.push(SoldDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SoldContCurentModel {
        data = typeof data === 'object' ? data : {};
        let result = new SoldContCurentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientName"] = this.appClientName;
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["tipPerioada"] = this.tipPerioada;
        if (Array.isArray(this.soldDetails)) {
            data["soldDetails"] = [];
            for (let item of this.soldDetails)
                data["soldDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): SoldContCurentModel {
        const json = this.toJSON();
        let result = new SoldContCurentModel();
        result.init(json);
        return result;
    }
}

export interface ISoldContCurentModel {
    appClientName: string | undefined;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    tipPerioada: string | undefined;
    soldDetails: SoldDetail[] | undefined;
}

export class SoldFurnizoriDebitoriDetails implements ISoldFurnizoriDebitoriDetails {
    documentType: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment | undefined;
    value: number;
    restPlata: number;

    constructor(data?: ISoldFurnizoriDebitoriDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"];
            this.documentNumber = _data["documentNumber"];
            this.documentDate = _data["documentDate"] ? moment(_data["documentDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.restPlata = _data["restPlata"];
        }
    }

    static fromJS(data: any): SoldFurnizoriDebitoriDetails {
        data = typeof data === 'object' ? data : {};
        let result = new SoldFurnizoriDebitoriDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        data["documentNumber"] = this.documentNumber;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["restPlata"] = this.restPlata;
        return data;
    }

    clone(): SoldFurnizoriDebitoriDetails {
        const json = this.toJSON();
        let result = new SoldFurnizoriDebitoriDetails();
        result.init(json);
        return result;
    }
}

export interface ISoldFurnizoriDebitoriDetails {
    documentType: string | undefined;
    documentNumber: string | undefined;
    documentDate: moment.Moment | undefined;
    value: number;
    restPlata: number;
}

export class SoldFurnizoriDebitoriModel implements ISoldFurnizoriDebitoriModel {
    appClientName: string | undefined;
    appClientAddress: string | undefined;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    thirdPartyName: string | undefined;
    thirdPartyAddress: string | undefined;
    thirdPartyId1: string | undefined;
    operationDate: moment.Moment;
    details: SoldFurnizoriDebitoriDetails[] | undefined;

    constructor(data?: ISoldFurnizoriDebitoriModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientName = _data["appClientName"];
            this.appClientAddress = _data["appClientAddress"];
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.thirdPartyName = _data["thirdPartyName"];
            this.thirdPartyAddress = _data["thirdPartyAddress"];
            this.thirdPartyId1 = _data["thirdPartyId1"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(SoldFurnizoriDebitoriDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SoldFurnizoriDebitoriModel {
        data = typeof data === 'object' ? data : {};
        let result = new SoldFurnizoriDebitoriModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientName"] = this.appClientName;
        data["appClientAddress"] = this.appClientAddress;
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["thirdPartyName"] = this.thirdPartyName;
        data["thirdPartyAddress"] = this.thirdPartyAddress;
        data["thirdPartyId1"] = this.thirdPartyId1;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): SoldFurnizoriDebitoriModel {
        const json = this.toJSON();
        let result = new SoldFurnizoriDebitoriModel();
        result.init(json);
        return result;
    }
}

export interface ISoldFurnizoriDebitoriModel {
    appClientName: string | undefined;
    appClientAddress: string | undefined;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    thirdPartyName: string | undefined;
    thirdPartyAddress: string | undefined;
    thirdPartyId1: string | undefined;
    operationDate: moment.Moment;
    details: SoldFurnizoriDebitoriDetails[] | undefined;
}

export class BugePrevAllDepartmentByMonth implements IBugePrevAllDepartmentByMonth {
    monthName: moment.Moment;
    id: number;
    description: string | undefined;
    value: number;
    activityType: string | undefined;
    valueActivity: number;
    orderView: number;

    constructor(data?: IBugePrevAllDepartmentByMonth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.monthName = _data["monthName"] ? moment(_data["monthName"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.activityType = _data["activityType"];
            this.valueActivity = _data["valueActivity"];
            this.orderView = _data["orderView"];
        }
    }

    static fromJS(data: any): BugePrevAllDepartmentByMonth {
        data = typeof data === 'object' ? data : {};
        let result = new BugePrevAllDepartmentByMonth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monthName"] = this.monthName ? this.monthName.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["description"] = this.description;
        data["value"] = this.value;
        data["activityType"] = this.activityType;
        data["valueActivity"] = this.valueActivity;
        data["orderView"] = this.orderView;
        return data;
    }

    clone(): BugePrevAllDepartmentByMonth {
        const json = this.toJSON();
        let result = new BugePrevAllDepartmentByMonth();
        result.init(json);
        return result;
    }
}

export interface IBugePrevAllDepartmentByMonth {
    monthName: moment.Moment;
    id: number;
    description: string | undefined;
    value: number;
    activityType: string | undefined;
    valueActivity: number;
    orderView: number;
}

export class BugePrevDepartmentByMonth implements IBugePrevDepartmentByMonth {
    monthName: moment.Moment;
    id: number;
    description: string | undefined;
    activityType: string | undefined;
    valueActivity: number;
    orderView: number;
    value: number;

    constructor(data?: IBugePrevDepartmentByMonth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.monthName = _data["monthName"] ? moment(_data["monthName"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.description = _data["description"];
            this.activityType = _data["activityType"];
            this.valueActivity = _data["valueActivity"];
            this.orderView = _data["orderView"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BugePrevDepartmentByMonth {
        data = typeof data === 'object' ? data : {};
        let result = new BugePrevDepartmentByMonth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monthName"] = this.monthName ? this.monthName.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["description"] = this.description;
        data["activityType"] = this.activityType;
        data["valueActivity"] = this.valueActivity;
        data["orderView"] = this.orderView;
        data["value"] = this.value;
        return data;
    }

    clone(): BugePrevDepartmentByMonth {
        const json = this.toJSON();
        let result = new BugePrevDepartmentByMonth();
        result.init(json);
        return result;
    }
}

export interface IBugePrevDepartmentByMonth {
    monthName: moment.Moment;
    id: number;
    description: string | undefined;
    activityType: string | undefined;
    valueActivity: number;
    orderView: number;
    value: number;
}

export class BugetPrevReportDto implements IBugetPrevReportDto {
    appClientName: string | undefined;
    departmentName: string | undefined;
    bugetPrevAllDepMonths: BugePrevAllDepartmentByMonth[] | undefined;
    bugetPrevDepMonths: BugePrevDepartmentByMonth[] | undefined;

    constructor(data?: IBugetPrevReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientName = _data["appClientName"];
            this.departmentName = _data["departmentName"];
            if (Array.isArray(_data["bugetPrevAllDepMonths"])) {
                this.bugetPrevAllDepMonths = [] as any;
                for (let item of _data["bugetPrevAllDepMonths"])
                    this.bugetPrevAllDepMonths.push(BugePrevAllDepartmentByMonth.fromJS(item));
            }
            if (Array.isArray(_data["bugetPrevDepMonths"])) {
                this.bugetPrevDepMonths = [] as any;
                for (let item of _data["bugetPrevDepMonths"])
                    this.bugetPrevDepMonths.push(BugePrevDepartmentByMonth.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BugetPrevReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientName"] = this.appClientName;
        data["departmentName"] = this.departmentName;
        if (Array.isArray(this.bugetPrevAllDepMonths)) {
            data["bugetPrevAllDepMonths"] = [];
            for (let item of this.bugetPrevAllDepMonths)
                data["bugetPrevAllDepMonths"].push(item.toJSON());
        }
        if (Array.isArray(this.bugetPrevDepMonths)) {
            data["bugetPrevDepMonths"] = [];
            for (let item of this.bugetPrevDepMonths)
                data["bugetPrevDepMonths"].push(item.toJSON());
        }
        return data;
    }

    clone(): BugetPrevReportDto {
        const json = this.toJSON();
        let result = new BugetPrevReportDto();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevReportDto {
    appClientName: string | undefined;
    departmentName: string | undefined;
    bugetPrevAllDepMonths: BugePrevAllDepartmentByMonth[] | undefined;
    bugetPrevDepMonths: BugePrevDepartmentByMonth[] | undefined;
}

export class Anexa1Model implements IAnexa1Model {
    anexaDetailId: number;
    orderView: number;
    nrCrt: string | undefined;
    codRand: string | undefined;
    sector_S121: number;
    sector_S122: number;
    sector_S1311: number;
    sector_S1313: number;
    sector_S1314: number;
    sector_S123: number;
    sector_S124: number;
    sector_S126: number;
    sector_S128: number;
    sector_S129: number;
    sector_S11: number;
    sector_S14: number;
    sector_S15: number;
    sector_S211: number;
    sector_S212: number;
    sector_S22: number;
    sector_S125: number;
    anexaDetailName: string | undefined;
    instrumentFinanciar: string | undefined;
    total: number;

    constructor(data?: IAnexa1Model) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.anexaDetailId = _data["anexaDetailId"];
            this.orderView = _data["orderView"];
            this.nrCrt = _data["nrCrt"];
            this.codRand = _data["codRand"];
            this.sector_S121 = _data["sector_S121"];
            this.sector_S122 = _data["sector_S122"];
            this.sector_S1311 = _data["sector_S1311"];
            this.sector_S1313 = _data["sector_S1313"];
            this.sector_S1314 = _data["sector_S1314"];
            this.sector_S123 = _data["sector_S123"];
            this.sector_S124 = _data["sector_S124"];
            this.sector_S126 = _data["sector_S126"];
            this.sector_S128 = _data["sector_S128"];
            this.sector_S129 = _data["sector_S129"];
            this.sector_S11 = _data["sector_S11"];
            this.sector_S14 = _data["sector_S14"];
            this.sector_S15 = _data["sector_S15"];
            this.sector_S211 = _data["sector_S211"];
            this.sector_S212 = _data["sector_S212"];
            this.sector_S22 = _data["sector_S22"];
            this.sector_S125 = _data["sector_S125"];
            this.anexaDetailName = _data["anexaDetailName"];
            this.instrumentFinanciar = _data["instrumentFinanciar"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): Anexa1Model {
        data = typeof data === 'object' ? data : {};
        let result = new Anexa1Model();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["anexaDetailId"] = this.anexaDetailId;
        data["orderView"] = this.orderView;
        data["nrCrt"] = this.nrCrt;
        data["codRand"] = this.codRand;
        data["sector_S121"] = this.sector_S121;
        data["sector_S122"] = this.sector_S122;
        data["sector_S1311"] = this.sector_S1311;
        data["sector_S1313"] = this.sector_S1313;
        data["sector_S1314"] = this.sector_S1314;
        data["sector_S123"] = this.sector_S123;
        data["sector_S124"] = this.sector_S124;
        data["sector_S126"] = this.sector_S126;
        data["sector_S128"] = this.sector_S128;
        data["sector_S129"] = this.sector_S129;
        data["sector_S11"] = this.sector_S11;
        data["sector_S14"] = this.sector_S14;
        data["sector_S15"] = this.sector_S15;
        data["sector_S211"] = this.sector_S211;
        data["sector_S212"] = this.sector_S212;
        data["sector_S22"] = this.sector_S22;
        data["sector_S125"] = this.sector_S125;
        data["anexaDetailName"] = this.anexaDetailName;
        data["instrumentFinanciar"] = this.instrumentFinanciar;
        data["total"] = this.total;
        return data;
    }

    clone(): Anexa1Model {
        const json = this.toJSON();
        let result = new Anexa1Model();
        result.init(json);
        return result;
    }
}

export interface IAnexa1Model {
    anexaDetailId: number;
    orderView: number;
    nrCrt: string | undefined;
    codRand: string | undefined;
    sector_S121: number;
    sector_S122: number;
    sector_S1311: number;
    sector_S1313: number;
    sector_S1314: number;
    sector_S123: number;
    sector_S124: number;
    sector_S126: number;
    sector_S128: number;
    sector_S129: number;
    sector_S11: number;
    sector_S14: number;
    sector_S15: number;
    sector_S211: number;
    sector_S212: number;
    sector_S22: number;
    sector_S125: number;
    anexaDetailName: string | undefined;
    instrumentFinanciar: string | undefined;
    total: number;
}

export class Anexa2Model implements IAnexa2Model {
    orderView: number;
    nrCrt: string | undefined;
    operationDate: moment.Moment;
    anexaDetailName: string | undefined;
    valoare: number;

    constructor(data?: IAnexa2Model) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderView = _data["orderView"];
            this.nrCrt = _data["nrCrt"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.anexaDetailName = _data["anexaDetailName"];
            this.valoare = _data["valoare"];
        }
    }

    static fromJS(data: any): Anexa2Model {
        data = typeof data === 'object' ? data : {};
        let result = new Anexa2Model();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderView"] = this.orderView;
        data["nrCrt"] = this.nrCrt;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["anexaDetailName"] = this.anexaDetailName;
        data["valoare"] = this.valoare;
        return data;
    }

    clone(): Anexa2Model {
        const json = this.toJSON();
        let result = new Anexa2Model();
        result.init(json);
        return result;
    }
}

export interface IAnexa2Model {
    orderView: number;
    nrCrt: string | undefined;
    operationDate: moment.Moment;
    anexaDetailName: string | undefined;
    valoare: number;
}

export class Anexa3Model implements IAnexa3Model {
    orderView: number;
    nrCrt: string | undefined;
    indicator: string | undefined;
    valoare: number;

    constructor(data?: IAnexa3Model) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderView = _data["orderView"];
            this.nrCrt = _data["nrCrt"];
            this.indicator = _data["indicator"];
            this.valoare = _data["valoare"];
        }
    }

    static fromJS(data: any): Anexa3Model {
        data = typeof data === 'object' ? data : {};
        let result = new Anexa3Model();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderView"] = this.orderView;
        data["nrCrt"] = this.nrCrt;
        data["indicator"] = this.indicator;
        data["valoare"] = this.valoare;
        return data;
    }

    clone(): Anexa3Model {
        const json = this.toJSON();
        let result = new Anexa3Model();
        result.init(json);
        return result;
    }
}

export interface IAnexa3Model {
    orderView: number;
    nrCrt: string | undefined;
    indicator: string | undefined;
    valoare: number;
}

export class Anexa4Model implements IAnexa4Model {
    orderView: number;
    nrCrt: string | undefined;
    denumireRand: string | undefined;
    valoareCresteri: number;
    valoareReduceri: number;

    constructor(data?: IAnexa4Model) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderView = _data["orderView"];
            this.nrCrt = _data["nrCrt"];
            this.denumireRand = _data["denumireRand"];
            this.valoareCresteri = _data["valoareCresteri"];
            this.valoareReduceri = _data["valoareReduceri"];
        }
    }

    static fromJS(data: any): Anexa4Model {
        data = typeof data === 'object' ? data : {};
        let result = new Anexa4Model();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderView"] = this.orderView;
        data["nrCrt"] = this.nrCrt;
        data["denumireRand"] = this.denumireRand;
        data["valoareCresteri"] = this.valoareCresteri;
        data["valoareReduceri"] = this.valoareReduceri;
        return data;
    }

    clone(): Anexa4Model {
        const json = this.toJSON();
        let result = new Anexa4Model();
        result.init(json);
        return result;
    }
}

export interface IAnexa4Model {
    orderView: number;
    nrCrt: string | undefined;
    denumireRand: string | undefined;
    valoareCresteri: number;
    valoareReduceri: number;
}

export class AnexaReportModel implements IAnexaReportModel {
    appClientName: string | undefined;
    savedBalanceId: number;
    savedBalanceDate: moment.Moment;
    anexaA1Details: Anexa1Model[] | undefined;
    anexaB1Details: Anexa1Model[] | undefined;
    anexa2Details: Anexa2Model[] | undefined;
    anexa3Details: Anexa3Model[] | undefined;
    anexa4Details: Anexa4Model[] | undefined;

    constructor(data?: IAnexaReportModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientName = _data["appClientName"];
            this.savedBalanceId = _data["savedBalanceId"];
            this.savedBalanceDate = _data["savedBalanceDate"] ? moment(_data["savedBalanceDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["anexaA1Details"])) {
                this.anexaA1Details = [] as any;
                for (let item of _data["anexaA1Details"])
                    this.anexaA1Details.push(Anexa1Model.fromJS(item));
            }
            if (Array.isArray(_data["anexaB1Details"])) {
                this.anexaB1Details = [] as any;
                for (let item of _data["anexaB1Details"])
                    this.anexaB1Details.push(Anexa1Model.fromJS(item));
            }
            if (Array.isArray(_data["anexa2Details"])) {
                this.anexa2Details = [] as any;
                for (let item of _data["anexa2Details"])
                    this.anexa2Details.push(Anexa2Model.fromJS(item));
            }
            if (Array.isArray(_data["anexa3Details"])) {
                this.anexa3Details = [] as any;
                for (let item of _data["anexa3Details"])
                    this.anexa3Details.push(Anexa3Model.fromJS(item));
            }
            if (Array.isArray(_data["anexa4Details"])) {
                this.anexa4Details = [] as any;
                for (let item of _data["anexa4Details"])
                    this.anexa4Details.push(Anexa4Model.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AnexaReportModel {
        data = typeof data === 'object' ? data : {};
        let result = new AnexaReportModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientName"] = this.appClientName;
        data["savedBalanceId"] = this.savedBalanceId;
        data["savedBalanceDate"] = this.savedBalanceDate ? this.savedBalanceDate.toISOString() : <any>undefined;
        if (Array.isArray(this.anexaA1Details)) {
            data["anexaA1Details"] = [];
            for (let item of this.anexaA1Details)
                data["anexaA1Details"].push(item.toJSON());
        }
        if (Array.isArray(this.anexaB1Details)) {
            data["anexaB1Details"] = [];
            for (let item of this.anexaB1Details)
                data["anexaB1Details"].push(item.toJSON());
        }
        if (Array.isArray(this.anexa2Details)) {
            data["anexa2Details"] = [];
            for (let item of this.anexa2Details)
                data["anexa2Details"].push(item.toJSON());
        }
        if (Array.isArray(this.anexa3Details)) {
            data["anexa3Details"] = [];
            for (let item of this.anexa3Details)
                data["anexa3Details"].push(item.toJSON());
        }
        if (Array.isArray(this.anexa4Details)) {
            data["anexa4Details"] = [];
            for (let item of this.anexa4Details)
                data["anexa4Details"].push(item.toJSON());
        }
        return data;
    }

    clone(): AnexaReportModel {
        const json = this.toJSON();
        let result = new AnexaReportModel();
        result.init(json);
        return result;
    }
}

export interface IAnexaReportModel {
    appClientName: string | undefined;
    savedBalanceId: number;
    savedBalanceDate: moment.Moment;
    anexaA1Details: Anexa1Model[] | undefined;
    anexaB1Details: Anexa1Model[] | undefined;
    anexa2Details: Anexa2Model[] | undefined;
    anexa3Details: Anexa3Model[] | undefined;
    anexa4Details: Anexa4Model[] | undefined;
}

export class BugetPrevazutModel implements IBugetPrevazutModel {
    id: number;
    tipRand: number;
    orderView: number;
    denumireRand: string | undefined;
    dataLuna: moment.Moment;
    valoare: number;
    activityTypeId: number;
    an: number;

    constructor(data?: IBugetPrevazutModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tipRand = _data["tipRand"];
            this.orderView = _data["orderView"];
            this.denumireRand = _data["denumireRand"];
            this.dataLuna = _data["dataLuna"] ? moment(_data["dataLuna"].toString()) : <any>undefined;
            this.valoare = _data["valoare"];
            this.activityTypeId = _data["activityTypeId"];
            this.an = _data["an"];
        }
    }

    static fromJS(data: any): BugetPrevazutModel {
        data = typeof data === 'object' ? data : {};
        let result = new BugetPrevazutModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tipRand"] = this.tipRand;
        data["orderView"] = this.orderView;
        data["denumireRand"] = this.denumireRand;
        data["dataLuna"] = this.dataLuna ? this.dataLuna.toISOString() : <any>undefined;
        data["valoare"] = this.valoare;
        data["activityTypeId"] = this.activityTypeId;
        data["an"] = this.an;
        return data;
    }

    clone(): BugetPrevazutModel {
        const json = this.toJSON();
        let result = new BugetPrevazutModel();
        result.init(json);
        return result;
    }
}

export interface IBugetPrevazutModel {
    id: number;
    tipRand: number;
    orderView: number;
    denumireRand: string | undefined;
    dataLuna: moment.Moment;
    valoare: number;
    activityTypeId: number;
    an: number;
}

export class BVC_Report implements IBVC_Report {
    titlu: string | undefined;
    anBuget: number;
    parameters: string | undefined;
    appClientName: string | undefined;
    frecventa: string | undefined;
    bugetDetails: BugetPrevazutModel[] | undefined;

    constructor(data?: IBVC_Report) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titlu = _data["titlu"];
            this.anBuget = _data["anBuget"];
            this.parameters = _data["parameters"];
            this.appClientName = _data["appClientName"];
            this.frecventa = _data["frecventa"];
            if (Array.isArray(_data["bugetDetails"])) {
                this.bugetDetails = [] as any;
                for (let item of _data["bugetDetails"])
                    this.bugetDetails.push(BugetPrevazutModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BVC_Report {
        data = typeof data === 'object' ? data : {};
        let result = new BVC_Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titlu"] = this.titlu;
        data["anBuget"] = this.anBuget;
        data["parameters"] = this.parameters;
        data["appClientName"] = this.appClientName;
        data["frecventa"] = this.frecventa;
        if (Array.isArray(this.bugetDetails)) {
            data["bugetDetails"] = [];
            for (let item of this.bugetDetails)
                data["bugetDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): BVC_Report {
        const json = this.toJSON();
        let result = new BVC_Report();
        result.init(json);
        return result;
    }
}

export interface IBVC_Report {
    titlu: string | undefined;
    anBuget: number;
    parameters: string | undefined;
    appClientName: string | undefined;
    frecventa: string | undefined;
    bugetDetails: BugetPrevazutModel[] | undefined;
}

export class BVC_RealizatDetail implements IBVC_RealizatDetail {
    denumireRand: string | undefined;
    valoareRealizat: number;
    valoarePrevazut: number;
    valoareDiferenta: number;
    procent: number;

    constructor(data?: IBVC_RealizatDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.denumireRand = _data["denumireRand"];
            this.valoareRealizat = _data["valoareRealizat"];
            this.valoarePrevazut = _data["valoarePrevazut"];
            this.valoareDiferenta = _data["valoareDiferenta"];
            this.procent = _data["procent"];
        }
    }

    static fromJS(data: any): BVC_RealizatDetail {
        data = typeof data === 'object' ? data : {};
        let result = new BVC_RealizatDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["denumireRand"] = this.denumireRand;
        data["valoareRealizat"] = this.valoareRealizat;
        data["valoarePrevazut"] = this.valoarePrevazut;
        data["valoareDiferenta"] = this.valoareDiferenta;
        data["procent"] = this.procent;
        return data;
    }

    clone(): BVC_RealizatDetail {
        const json = this.toJSON();
        let result = new BVC_RealizatDetail();
        result.init(json);
        return result;
    }
}

export interface IBVC_RealizatDetail {
    denumireRand: string | undefined;
    valoareRealizat: number;
    valoarePrevazut: number;
    valoareDiferenta: number;
    procent: number;
}

export class BVC_Realizat_Report implements IBVC_Realizat_Report {
    titlu: string | undefined;
    appClientName: string | undefined;
    an: number;
    operationDate: moment.Moment;
    details: BVC_RealizatDetail[] | undefined;

    constructor(data?: IBVC_Realizat_Report) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titlu = _data["titlu"];
            this.appClientName = _data["appClientName"];
            this.an = _data["an"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(BVC_RealizatDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BVC_Realizat_Report {
        data = typeof data === 'object' ? data : {};
        let result = new BVC_Realizat_Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titlu"] = this.titlu;
        data["appClientName"] = this.appClientName;
        data["an"] = this.an;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): BVC_Realizat_Report {
        const json = this.toJSON();
        let result = new BVC_Realizat_Report();
        result.init(json);
        return result;
    }
}

export interface IBVC_Realizat_Report {
    titlu: string | undefined;
    appClientName: string | undefined;
    an: number;
    operationDate: moment.Moment;
    details: BVC_RealizatDetail[] | undefined;
}

export class SitFinanReportDetailList implements ISitFinanReportDetailList {
    calcRowId: number;
    rowId: number;
    rowName: string | undefined;
    rowNr: string | undefined;
    rowNota: string | undefined;
    orderView: number;
    totalRow: boolean;
    bold: boolean;
    negativeValue: boolean;
    decimalNr: number;
    val: number | undefined;
    val6: number | undefined;
    balanceDate: moment.Moment | undefined;

    constructor(data?: ISitFinanReportDetailList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calcRowId = _data["calcRowId"];
            this.rowId = _data["rowId"];
            this.rowName = _data["rowName"];
            this.rowNr = _data["rowNr"];
            this.rowNota = _data["rowNota"];
            this.orderView = _data["orderView"];
            this.totalRow = _data["totalRow"];
            this.bold = _data["bold"];
            this.negativeValue = _data["negativeValue"];
            this.decimalNr = _data["decimalNr"];
            this.val = _data["val"];
            this.val6 = _data["val6"];
            this.balanceDate = _data["balanceDate"] ? moment(_data["balanceDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SitFinanReportDetailList {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanReportDetailList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calcRowId"] = this.calcRowId;
        data["rowId"] = this.rowId;
        data["rowName"] = this.rowName;
        data["rowNr"] = this.rowNr;
        data["rowNota"] = this.rowNota;
        data["orderView"] = this.orderView;
        data["totalRow"] = this.totalRow;
        data["bold"] = this.bold;
        data["negativeValue"] = this.negativeValue;
        data["decimalNr"] = this.decimalNr;
        data["val"] = this.val;
        data["val6"] = this.val6;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): SitFinanReportDetailList {
        const json = this.toJSON();
        let result = new SitFinanReportDetailList();
        result.init(json);
        return result;
    }
}

export interface ISitFinanReportDetailList {
    calcRowId: number;
    rowId: number;
    rowName: string | undefined;
    rowNr: string | undefined;
    rowNota: string | undefined;
    orderView: number;
    totalRow: boolean;
    bold: boolean;
    negativeValue: boolean;
    decimalNr: number;
    val: number | undefined;
    val6: number | undefined;
    balanceDate: moment.Moment | undefined;
}

export class SitFinanRaport implements ISitFinanRaport {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    reportName: string | undefined;
    columnName: string | undefined;
    dateRange: string | undefined;
    balanceType: string | undefined;
    notaBefore: string | undefined;
    notaAfter: string | undefined;
    details: SitFinanReportDetailList[] | undefined;

    constructor(data?: ISitFinanRaport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.reportName = _data["reportName"];
            this.columnName = _data["columnName"];
            this.dateRange = _data["dateRange"];
            this.balanceType = _data["balanceType"];
            this.notaBefore = _data["notaBefore"];
            this.notaAfter = _data["notaAfter"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(SitFinanReportDetailList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitFinanRaport {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanRaport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["reportName"] = this.reportName;
        data["columnName"] = this.columnName;
        data["dateRange"] = this.dateRange;
        data["balanceType"] = this.balanceType;
        data["notaBefore"] = this.notaBefore;
        data["notaAfter"] = this.notaAfter;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): SitFinanRaport {
        const json = this.toJSON();
        let result = new SitFinanRaport();
        result.init(json);
        return result;
    }
}

export interface ISitFinanRaport {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    reportName: string | undefined;
    columnName: string | undefined;
    dateRange: string | undefined;
    balanceType: string | undefined;
    notaBefore: string | undefined;
    notaAfter: string | undefined;
    details: SitFinanReportDetailList[] | undefined;
}

export class CursValutarBNRDetails implements ICursValutarBNRDetails {
    currencyId: number | undefined;
    currencyName: string | undefined;
    valoarePrecedenta: number;
    valoareCurenta: number;
    variatie: number;

    constructor(data?: ICursValutarBNRDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.valoarePrecedenta = _data["valoarePrecedenta"];
            this.valoareCurenta = _data["valoareCurenta"];
            this.variatie = _data["variatie"];
        }
    }

    static fromJS(data: any): CursValutarBNRDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CursValutarBNRDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["valoarePrecedenta"] = this.valoarePrecedenta;
        data["valoareCurenta"] = this.valoareCurenta;
        data["variatie"] = this.variatie;
        return data;
    }

    clone(): CursValutarBNRDetails {
        const json = this.toJSON();
        let result = new CursValutarBNRDetails();
        result.init(json);
        return result;
    }
}

export interface ICursValutarBNRDetails {
    currencyId: number | undefined;
    currencyName: string | undefined;
    valoarePrecedenta: number;
    valoareCurenta: number;
    variatie: number;
}

export class CursValutarBNRModel implements ICursValutarBNRModel {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    details: CursValutarBNRDetails[] | undefined;

    constructor(data?: ICursValutarBNRModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.dataStart = _data["dataStart"] ? moment(_data["dataStart"].toString()) : <any>undefined;
            this.dataEnd = _data["dataEnd"] ? moment(_data["dataEnd"].toString()) : <any>undefined;
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(CursValutarBNRDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CursValutarBNRModel {
        data = typeof data === 'object' ? data : {};
        let result = new CursValutarBNRModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["dataStart"] = this.dataStart ? this.dataStart.toISOString() : <any>undefined;
        data["dataEnd"] = this.dataEnd ? this.dataEnd.toISOString() : <any>undefined;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): CursValutarBNRModel {
        const json = this.toJSON();
        let result = new CursValutarBNRModel();
        result.init(json);
        return result;
    }
}

export interface ICursValutarBNRModel {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    dataStart: moment.Moment;
    dataEnd: moment.Moment;
    details: CursValutarBNRDetails[] | undefined;
}

export class LichidCalcModel implements ILichidCalcModel {
    description: string | undefined;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    calcDate: moment.Moment;
    lichidCalcList: LichidCalcListDetDto[] | undefined;
    lichidCalcCurrList: LichidCalcCurrListDto[] | undefined;

    constructor(data?: ILichidCalcModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.calcDate = _data["calcDate"] ? moment(_data["calcDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["lichidCalcList"])) {
                this.lichidCalcList = [] as any;
                for (let item of _data["lichidCalcList"])
                    this.lichidCalcList.push(LichidCalcListDetDto.fromJS(item));
            }
            if (Array.isArray(_data["lichidCalcCurrList"])) {
                this.lichidCalcCurrList = [] as any;
                for (let item of _data["lichidCalcCurrList"])
                    this.lichidCalcCurrList.push(LichidCalcCurrListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LichidCalcModel {
        data = typeof data === 'object' ? data : {};
        let result = new LichidCalcModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["calcDate"] = this.calcDate ? this.calcDate.toISOString() : <any>undefined;
        if (Array.isArray(this.lichidCalcList)) {
            data["lichidCalcList"] = [];
            for (let item of this.lichidCalcList)
                data["lichidCalcList"].push(item.toJSON());
        }
        if (Array.isArray(this.lichidCalcCurrList)) {
            data["lichidCalcCurrList"] = [];
            for (let item of this.lichidCalcCurrList)
                data["lichidCalcCurrList"].push(item.toJSON());
        }
        return data;
    }

    clone(): LichidCalcModel {
        const json = this.toJSON();
        let result = new LichidCalcModel();
        result.init(json);
        return result;
    }
}

export interface ILichidCalcModel {
    description: string | undefined;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    calcDate: moment.Moment;
    lichidCalcList: LichidCalcListDetDto[] | undefined;
    lichidCalcCurrList: LichidCalcCurrListDto[] | undefined;
}

export class DepozitBancarDetailDto implements IDepozitBancarDetailDto {
    idPlasament: string | undefined;
    denumireBanca: string | undefined;
    sumaInvestita: number;
    maximRezidual: number;
    dobanda: number;

    constructor(data?: IDepozitBancarDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idPlasament = _data["idPlasament"];
            this.denumireBanca = _data["denumireBanca"];
            this.sumaInvestita = _data["sumaInvestita"];
            this.maximRezidual = _data["maximRezidual"];
            this.dobanda = _data["dobanda"];
        }
    }

    static fromJS(data: any): DepozitBancarDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepozitBancarDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idPlasament"] = this.idPlasament;
        data["denumireBanca"] = this.denumireBanca;
        data["sumaInvestita"] = this.sumaInvestita;
        data["maximRezidual"] = this.maximRezidual;
        data["dobanda"] = this.dobanda;
        return data;
    }

    clone(): DepozitBancarDetailDto {
        const json = this.toJSON();
        let result = new DepozitBancarDetailDto();
        result.init(json);
        return result;
    }
}

export interface IDepozitBancarDetailDto {
    idPlasament: string | undefined;
    denumireBanca: string | undefined;
    sumaInvestita: number;
    maximRezidual: number;
    dobanda: number;
}

export class DepozitBancarDto implements IDepozitBancarDto {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    balanceDate: moment.Moment;
    reportName: string | undefined;
    details: DepozitBancarDetailDto[] | undefined;
    totalDepozit: number;
    conturiCurente: number;
    totalDepozitConturi: number;

    constructor(data?: IDepozitBancarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            this.balanceDate = _data["balanceDate"] ? moment(_data["balanceDate"].toString()) : <any>undefined;
            this.reportName = _data["reportName"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(DepozitBancarDetailDto.fromJS(item));
            }
            this.totalDepozit = _data["totalDepozit"];
            this.conturiCurente = _data["conturiCurente"];
            this.totalDepozitConturi = _data["totalDepozitConturi"];
        }
    }

    static fromJS(data: any): DepozitBancarDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepozitBancarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        data["reportName"] = this.reportName;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        data["totalDepozit"] = this.totalDepozit;
        data["conturiCurente"] = this.conturiCurente;
        data["totalDepozitConturi"] = this.totalDepozitConturi;
        return data;
    }

    clone(): DepozitBancarDto {
        const json = this.toJSON();
        let result = new DepozitBancarDto();
        result.init(json);
        return result;
    }
}

export interface IDepozitBancarDto {
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    balanceDate: moment.Moment;
    reportName: string | undefined;
    details: DepozitBancarDetailDto[] | undefined;
    totalDepozit: number;
    conturiCurente: number;
    totalDepozitConturi: number;
}

export class BVC_BalRealizatDetail implements IBVC_BalRealizatDetail {
    denumireRand: string | undefined;
    valoareBalRealizat: number;
    valoarePrevazut: number;
    valoareDiferenta: number;
    procent: number;
    aprobat: number | undefined;
    ramasDeRealizat: number | undefined;

    constructor(data?: IBVC_BalRealizatDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.denumireRand = _data["denumireRand"];
            this.valoareBalRealizat = _data["valoareBalRealizat"];
            this.valoarePrevazut = _data["valoarePrevazut"];
            this.valoareDiferenta = _data["valoareDiferenta"];
            this.procent = _data["procent"];
            this.aprobat = _data["aprobat"];
            this.ramasDeRealizat = _data["ramasDeRealizat"];
        }
    }

    static fromJS(data: any): BVC_BalRealizatDetail {
        data = typeof data === 'object' ? data : {};
        let result = new BVC_BalRealizatDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["denumireRand"] = this.denumireRand;
        data["valoareBalRealizat"] = this.valoareBalRealizat;
        data["valoarePrevazut"] = this.valoarePrevazut;
        data["valoareDiferenta"] = this.valoareDiferenta;
        data["procent"] = this.procent;
        data["aprobat"] = this.aprobat;
        data["ramasDeRealizat"] = this.ramasDeRealizat;
        return data;
    }

    clone(): BVC_BalRealizatDetail {
        const json = this.toJSON();
        let result = new BVC_BalRealizatDetail();
        result.init(json);
        return result;
    }
}

export interface IBVC_BalRealizatDetail {
    denumireRand: string | undefined;
    valoareBalRealizat: number;
    valoarePrevazut: number;
    valoareDiferenta: number;
    procent: number;
    aprobat: number | undefined;
    ramasDeRealizat: number | undefined;
}

export class VenitDinFond implements IVenitDinFond {
    denumireRand: string | undefined;
    valoareFondBalRealizat: number;
    valoareFondPrevazut: number;
    valoareFondDiferenta: number;
    procent: number;
    aprobatFond: number | undefined;
    fondRamasDeRealizat: number | undefined;

    constructor(data?: IVenitDinFond) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.denumireRand = _data["denumireRand"];
            this.valoareFondBalRealizat = _data["valoareFondBalRealizat"];
            this.valoareFondPrevazut = _data["valoareFondPrevazut"];
            this.valoareFondDiferenta = _data["valoareFondDiferenta"];
            this.procent = _data["procent"];
            this.aprobatFond = _data["aprobatFond"];
            this.fondRamasDeRealizat = _data["fondRamasDeRealizat"];
        }
    }

    static fromJS(data: any): VenitDinFond {
        data = typeof data === 'object' ? data : {};
        let result = new VenitDinFond();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["denumireRand"] = this.denumireRand;
        data["valoareFondBalRealizat"] = this.valoareFondBalRealizat;
        data["valoareFondPrevazut"] = this.valoareFondPrevazut;
        data["valoareFondDiferenta"] = this.valoareFondDiferenta;
        data["procent"] = this.procent;
        data["aprobatFond"] = this.aprobatFond;
        data["fondRamasDeRealizat"] = this.fondRamasDeRealizat;
        return data;
    }

    clone(): VenitDinFond {
        const json = this.toJSON();
        let result = new VenitDinFond();
        result.init(json);
        return result;
    }
}

export interface IVenitDinFond {
    denumireRand: string | undefined;
    valoareFondBalRealizat: number;
    valoareFondPrevazut: number;
    valoareFondDiferenta: number;
    procent: number;
    aprobatFond: number | undefined;
    fondRamasDeRealizat: number | undefined;
}

export class BVC_BalRealizat_Report implements IBVC_BalRealizat_Report {
    titlu: string | undefined;
    appClientName: string | undefined;
    tipBuget: string | undefined;
    an: number;
    activityTypeName: number;
    operationDate: moment.Moment;
    hideTotalVenituri: boolean;
    details: BVC_BalRealizatDetail[] | undefined;
    venitDinFonduri: VenitDinFond[] | undefined;

    constructor(data?: IBVC_BalRealizat_Report) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hideTotalVenituri = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titlu = _data["titlu"];
            this.appClientName = _data["appClientName"];
            this.tipBuget = _data["tipBuget"];
            this.an = _data["an"];
            this.activityTypeName = _data["activityTypeName"];
            this.operationDate = _data["operationDate"] ? moment(_data["operationDate"].toString()) : <any>undefined;
            this.hideTotalVenituri = _data["hideTotalVenituri"] !== undefined ? _data["hideTotalVenituri"] : false;
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(BVC_BalRealizatDetail.fromJS(item));
            }
            if (Array.isArray(_data["venitDinFonduri"])) {
                this.venitDinFonduri = [] as any;
                for (let item of _data["venitDinFonduri"])
                    this.venitDinFonduri.push(VenitDinFond.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BVC_BalRealizat_Report {
        data = typeof data === 'object' ? data : {};
        let result = new BVC_BalRealizat_Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titlu"] = this.titlu;
        data["appClientName"] = this.appClientName;
        data["tipBuget"] = this.tipBuget;
        data["an"] = this.an;
        data["activityTypeName"] = this.activityTypeName;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["hideTotalVenituri"] = this.hideTotalVenituri;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        if (Array.isArray(this.venitDinFonduri)) {
            data["venitDinFonduri"] = [];
            for (let item of this.venitDinFonduri)
                data["venitDinFonduri"].push(item.toJSON());
        }
        return data;
    }

    clone(): BVC_BalRealizat_Report {
        const json = this.toJSON();
        let result = new BVC_BalRealizat_Report();
        result.init(json);
        return result;
    }
}

export interface IBVC_BalRealizat_Report {
    titlu: string | undefined;
    appClientName: string | undefined;
    tipBuget: string | undefined;
    an: number;
    activityTypeName: number;
    operationDate: moment.Moment;
    hideTotalVenituri: boolean;
    details: BVC_BalRealizatDetail[] | undefined;
    venitDinFonduri: VenitDinFond[] | undefined;
}

export class BVC_PrevResurseDto implements IBVC_PrevResurseDto {
    descriere: string | undefined;
    orderView: number;
    suma: number;
    activityTypeId: number;
    activityTypeName: string | undefined;
    tenantId: number;

    constructor(data?: IBVC_PrevResurseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.descriere = _data["descriere"];
            this.orderView = _data["orderView"];
            this.suma = _data["suma"];
            this.activityTypeId = _data["activityTypeId"];
            this.activityTypeName = _data["activityTypeName"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BVC_PrevResurseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BVC_PrevResurseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["descriere"] = this.descriere;
        data["orderView"] = this.orderView;
        data["suma"] = this.suma;
        data["activityTypeId"] = this.activityTypeId;
        data["activityTypeName"] = this.activityTypeName;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BVC_PrevResurseDto {
        const json = this.toJSON();
        let result = new BVC_PrevResurseDto();
        result.init(json);
        return result;
    }
}

export interface IBVC_PrevResurseDto {
    descriere: string | undefined;
    orderView: number;
    suma: number;
    activityTypeId: number;
    activityTypeName: string | undefined;
    tenantId: number;
}

export class BVC_PrevResurseModel implements IBVC_PrevResurseModel {
    an: number;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    prevResurse: BVC_PrevResurseDto[] | undefined;

    constructor(data?: IBVC_PrevResurseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.an = _data["an"];
            this.appClientId1 = _data["appClientId1"];
            this.appClientId2 = _data["appClientId2"];
            this.appClientName = _data["appClientName"];
            if (Array.isArray(_data["prevResurse"])) {
                this.prevResurse = [] as any;
                for (let item of _data["prevResurse"])
                    this.prevResurse.push(BVC_PrevResurseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BVC_PrevResurseModel {
        data = typeof data === 'object' ? data : {};
        let result = new BVC_PrevResurseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["an"] = this.an;
        data["appClientId1"] = this.appClientId1;
        data["appClientId2"] = this.appClientId2;
        data["appClientName"] = this.appClientName;
        if (Array.isArray(this.prevResurse)) {
            data["prevResurse"] = [];
            for (let item of this.prevResurse)
                data["prevResurse"].push(item.toJSON());
        }
        return data;
    }

    clone(): BVC_PrevResurseModel {
        const json = this.toJSON();
        let result = new BVC_PrevResurseModel();
        result.init(json);
        return result;
    }
}

export interface IBVC_PrevResurseModel {
    an: number;
    appClientId1: string | undefined;
    appClientId2: string | undefined;
    appClientName: string | undefined;
    prevResurse: BVC_PrevResurseDto[] | undefined;
}

export class BugetRaportareDetails implements IBugetRaportareDetails {
    idTransa: number;
    idPaap: number;
    idRand: number;
    denumireRand: string | undefined;
    orderView: number;
    descriere: string | undefined;
    data: moment.Moment;
    valoareLei: number;
    bold: boolean;
    orderViewDet: number;
    starePaaP: string | undefined;

    constructor(data?: IBugetRaportareDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTransa = _data["idTransa"];
            this.idPaap = _data["idPaap"];
            this.idRand = _data["idRand"];
            this.denumireRand = _data["denumireRand"];
            this.orderView = _data["orderView"];
            this.descriere = _data["descriere"];
            this.data = _data["data"] ? moment(_data["data"].toString()) : <any>undefined;
            this.valoareLei = _data["valoareLei"];
            this.bold = _data["bold"];
            this.orderViewDet = _data["orderViewDet"];
            this.starePaaP = _data["starePaaP"];
        }
    }

    static fromJS(data: any): BugetRaportareDetails {
        data = typeof data === 'object' ? data : {};
        let result = new BugetRaportareDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTransa"] = this.idTransa;
        data["idPaap"] = this.idPaap;
        data["idRand"] = this.idRand;
        data["denumireRand"] = this.denumireRand;
        data["orderView"] = this.orderView;
        data["descriere"] = this.descriere;
        data["data"] = this.data ? this.data.toISOString() : <any>undefined;
        data["valoareLei"] = this.valoareLei;
        data["bold"] = this.bold;
        data["orderViewDet"] = this.orderViewDet;
        data["starePaaP"] = this.starePaaP;
        return data;
    }

    clone(): BugetRaportareDetails {
        const json = this.toJSON();
        let result = new BugetRaportareDetails();
        result.init(json);
        return result;
    }
}

export interface IBugetRaportareDetails {
    idTransa: number;
    idPaap: number;
    idRand: number;
    denumireRand: string | undefined;
    orderView: number;
    descriere: string | undefined;
    data: moment.Moment;
    valoareLei: number;
    bold: boolean;
    orderViewDet: number;
    starePaaP: string | undefined;
}

export class BugetRaportare implements IBugetRaportare {
    anBVC: number;
    titlu: string | undefined;
    appClientName: string | undefined;
    raportareDetails: BugetRaportareDetails[] | undefined;

    constructor(data?: IBugetRaportare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.anBVC = _data["anBVC"];
            this.titlu = _data["titlu"];
            this.appClientName = _data["appClientName"];
            if (Array.isArray(_data["raportareDetails"])) {
                this.raportareDetails = [] as any;
                for (let item of _data["raportareDetails"])
                    this.raportareDetails.push(BugetRaportareDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BugetRaportare {
        data = typeof data === 'object' ? data : {};
        let result = new BugetRaportare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["anBVC"] = this.anBVC;
        data["titlu"] = this.titlu;
        data["appClientName"] = this.appClientName;
        if (Array.isArray(this.raportareDetails)) {
            data["raportareDetails"] = [];
            for (let item of this.raportareDetails)
                data["raportareDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): BugetRaportare {
        const json = this.toJSON();
        let result = new BugetRaportare();
        result.init(json);
        return result;
    }
}

export interface IBugetRaportare {
    anBVC: number;
    titlu: string | undefined;
    appClientName: string | undefined;
    raportareDetails: BugetRaportareDetails[] | undefined;
}

export class InvoiceDetailsList implements IInvoiceDetailsList {
    invoiceDate: moment.Moment;
    contCheltuiala: string | undefined;
    invoiceElementsDetailsCategory: string | undefined;
    invoiceElementsDetails: string | undefined;
    thirdPartyName: string | undefined;
    documentTypeName: string | undefined;
    documentNumber: string | undefined;
    value: number;
    currencyName: string | undefined;
    valoareValuta: number;
    explicatii: string | undefined;
    tenantId: number;

    constructor(data?: IInvoiceDetailsList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceDate = _data["invoiceDate"] ? moment(_data["invoiceDate"].toString()) : <any>undefined;
            this.contCheltuiala = _data["contCheltuiala"];
            this.invoiceElementsDetailsCategory = _data["invoiceElementsDetailsCategory"];
            this.invoiceElementsDetails = _data["invoiceElementsDetails"];
            this.thirdPartyName = _data["thirdPartyName"];
            this.documentTypeName = _data["documentTypeName"];
            this.documentNumber = _data["documentNumber"];
            this.value = _data["value"];
            this.currencyName = _data["currencyName"];
            this.valoareValuta = _data["valoareValuta"];
            this.explicatii = _data["explicatii"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): InvoiceDetailsList {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetailsList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["contCheltuiala"] = this.contCheltuiala;
        data["invoiceElementsDetailsCategory"] = this.invoiceElementsDetailsCategory;
        data["invoiceElementsDetails"] = this.invoiceElementsDetails;
        data["thirdPartyName"] = this.thirdPartyName;
        data["documentTypeName"] = this.documentTypeName;
        data["documentNumber"] = this.documentNumber;
        data["value"] = this.value;
        data["currencyName"] = this.currencyName;
        data["valoareValuta"] = this.valoareValuta;
        data["explicatii"] = this.explicatii;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): InvoiceDetailsList {
        const json = this.toJSON();
        let result = new InvoiceDetailsList();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetailsList {
    invoiceDate: moment.Moment;
    contCheltuiala: string | undefined;
    invoiceElementsDetailsCategory: string | undefined;
    invoiceElementsDetails: string | undefined;
    thirdPartyName: string | undefined;
    documentTypeName: string | undefined;
    documentNumber: string | undefined;
    value: number;
    currencyName: string | undefined;
    valoareValuta: number;
    explicatii: string | undefined;
    tenantId: number;
}

export class InvoiceDetailsReportDto implements IInvoiceDetailsReportDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    invoiceElementsDetailsId: number | undefined;
    invoiceElementsDetails: string | undefined;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsCategory: string | undefined;
    contCheltuialaId: number | undefined;
    contCheltuiala: string | undefined;
    details: InvoiceDetailsList[] | undefined;

    constructor(data?: IInvoiceDetailsReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.invoiceElementsDetailsId = _data["invoiceElementsDetailsId"];
            this.invoiceElementsDetails = _data["invoiceElementsDetails"];
            this.invoiceElementsDetailsCategoryId = _data["invoiceElementsDetailsCategoryId"];
            this.invoiceElementsDetailsCategory = _data["invoiceElementsDetailsCategory"];
            this.contCheltuialaId = _data["contCheltuialaId"];
            this.contCheltuiala = _data["contCheltuiala"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details.push(InvoiceDetailsList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceDetailsReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetailsReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["invoiceElementsDetailsId"] = this.invoiceElementsDetailsId;
        data["invoiceElementsDetails"] = this.invoiceElementsDetails;
        data["invoiceElementsDetailsCategoryId"] = this.invoiceElementsDetailsCategoryId;
        data["invoiceElementsDetailsCategory"] = this.invoiceElementsDetailsCategory;
        data["contCheltuialaId"] = this.contCheltuialaId;
        data["contCheltuiala"] = this.contCheltuiala;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvoiceDetailsReportDto {
        const json = this.toJSON();
        let result = new InvoiceDetailsReportDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDetailsReportDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    invoiceElementsDetailsId: number | undefined;
    invoiceElementsDetails: string | undefined;
    invoiceElementsDetailsCategoryId: number | undefined;
    invoiceElementsDetailsCategory: string | undefined;
    contCheltuialaId: number | undefined;
    contCheltuiala: string | undefined;
    details: InvoiceDetailsList[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;
}

export class SavedBalanceListDto implements ISavedBalanceListDto {
    id: number;
    balanceDate: string | undefined;
    balanceName: string | undefined;
    okDelete: boolean;

    constructor(data?: ISavedBalanceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.balanceDate = _data["balanceDate"];
            this.balanceName = _data["balanceName"];
            this.okDelete = _data["okDelete"];
        }
    }

    static fromJS(data: any): SavedBalanceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SavedBalanceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["balanceDate"] = this.balanceDate;
        data["balanceName"] = this.balanceName;
        data["okDelete"] = this.okDelete;
        return data;
    }

    clone(): SavedBalanceListDto {
        const json = this.toJSON();
        let result = new SavedBalanceListDto();
        result.init(json);
        return result;
    }
}

export interface ISavedBalanceListDto {
    id: number;
    balanceDate: string | undefined;
    balanceName: string | undefined;
    okDelete: boolean;
}

export class ViewSavedBalanceDetailDto implements IViewSavedBalanceDetailDto {
    id: number;
    balanceDate: string | undefined;
    balanceName: string | undefined;
    searchAccount: string | undefined;
    balanceTypeStr: string | undefined;
    nivelRand: number | undefined;
    balanceType: BalanceType;
    currencyId: number;
    balanceDetail: BalanceDetailDto[] | undefined;

    constructor(data?: IViewSavedBalanceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.balanceDate = _data["balanceDate"];
            this.balanceName = _data["balanceName"];
            this.searchAccount = _data["searchAccount"];
            this.balanceTypeStr = _data["balanceTypeStr"];
            this.nivelRand = _data["nivelRand"];
            this.balanceType = _data["balanceType"];
            this.currencyId = _data["currencyId"];
            if (Array.isArray(_data["balanceDetail"])) {
                this.balanceDetail = [] as any;
                for (let item of _data["balanceDetail"])
                    this.balanceDetail.push(BalanceDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViewSavedBalanceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewSavedBalanceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["balanceDate"] = this.balanceDate;
        data["balanceName"] = this.balanceName;
        data["searchAccount"] = this.searchAccount;
        data["balanceTypeStr"] = this.balanceTypeStr;
        data["nivelRand"] = this.nivelRand;
        data["balanceType"] = this.balanceType;
        data["currencyId"] = this.currencyId;
        if (Array.isArray(this.balanceDetail)) {
            data["balanceDetail"] = [];
            for (let item of this.balanceDetail)
                data["balanceDetail"].push(item.toJSON());
        }
        return data;
    }

    clone(): ViewSavedBalanceDetailDto {
        const json = this.toJSON();
        let result = new ViewSavedBalanceDetailDto();
        result.init(json);
        return result;
    }
}

export interface IViewSavedBalanceDetailDto {
    id: number;
    balanceDate: string | undefined;
    balanceName: string | undefined;
    searchAccount: string | undefined;
    balanceTypeStr: string | undefined;
    nivelRand: number | undefined;
    balanceType: BalanceType;
    currencyId: number;
    balanceDetail: BalanceDetailDto[] | undefined;
}

export class SaveBalanceFormDto implements ISaveBalanceFormDto {
    dailyBalanceDate: moment.Moment;
    calcBalanceId: number;
    balanceName: string | undefined;
    isDaily: boolean;

    constructor(data?: ISaveBalanceFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dailyBalanceDate = _data["dailyBalanceDate"] ? moment(_data["dailyBalanceDate"].toString()) : <any>undefined;
            this.calcBalanceId = _data["calcBalanceId"];
            this.balanceName = _data["balanceName"];
            this.isDaily = _data["isDaily"];
        }
    }

    static fromJS(data: any): SaveBalanceFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveBalanceFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dailyBalanceDate"] = this.dailyBalanceDate ? this.dailyBalanceDate.toISOString() : <any>undefined;
        data["calcBalanceId"] = this.calcBalanceId;
        data["balanceName"] = this.balanceName;
        data["isDaily"] = this.isDaily;
        return data;
    }

    clone(): SaveBalanceFormDto {
        const json = this.toJSON();
        let result = new SaveBalanceFormDto();
        result.init(json);
        return result;
    }
}

export interface ISaveBalanceFormDto {
    dailyBalanceDate: moment.Moment;
    calcBalanceId: number;
    balanceName: string | undefined;
    isDaily: boolean;
}

export class SavedBalanceDto implements ISavedBalanceDto {
    searchStartDate: moment.Moment;
    searchEndDate: moment.Moment;
    isDaily: boolean;
    externalSave: boolean;
    showSaveForm: boolean;
    balanceList: SavedBalanceListDto[] | undefined;
    showBalanceDetails: boolean;
    viewBalanceDetail: ViewSavedBalanceDetailDto;
    savedBalanceForm: SaveBalanceFormDto;

    constructor(data?: ISavedBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchStartDate = _data["searchStartDate"] ? moment(_data["searchStartDate"].toString()) : <any>undefined;
            this.searchEndDate = _data["searchEndDate"] ? moment(_data["searchEndDate"].toString()) : <any>undefined;
            this.isDaily = _data["isDaily"];
            this.externalSave = _data["externalSave"];
            this.showSaveForm = _data["showSaveForm"];
            if (Array.isArray(_data["balanceList"])) {
                this.balanceList = [] as any;
                for (let item of _data["balanceList"])
                    this.balanceList.push(SavedBalanceListDto.fromJS(item));
            }
            this.showBalanceDetails = _data["showBalanceDetails"];
            this.viewBalanceDetail = _data["viewBalanceDetail"] ? ViewSavedBalanceDetailDto.fromJS(_data["viewBalanceDetail"]) : <any>undefined;
            this.savedBalanceForm = _data["savedBalanceForm"] ? SaveBalanceFormDto.fromJS(_data["savedBalanceForm"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SavedBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SavedBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchStartDate"] = this.searchStartDate ? this.searchStartDate.toISOString() : <any>undefined;
        data["searchEndDate"] = this.searchEndDate ? this.searchEndDate.toISOString() : <any>undefined;
        data["isDaily"] = this.isDaily;
        data["externalSave"] = this.externalSave;
        data["showSaveForm"] = this.showSaveForm;
        if (Array.isArray(this.balanceList)) {
            data["balanceList"] = [];
            for (let item of this.balanceList)
                data["balanceList"].push(item.toJSON());
        }
        data["showBalanceDetails"] = this.showBalanceDetails;
        data["viewBalanceDetail"] = this.viewBalanceDetail ? this.viewBalanceDetail.toJSON() : <any>undefined;
        data["savedBalanceForm"] = this.savedBalanceForm ? this.savedBalanceForm.toJSON() : <any>undefined;
        return data;
    }

    clone(): SavedBalanceDto {
        const json = this.toJSON();
        let result = new SavedBalanceDto();
        result.init(json);
        return result;
    }
}

export interface ISavedBalanceDto {
    searchStartDate: moment.Moment;
    searchEndDate: moment.Moment;
    isDaily: boolean;
    externalSave: boolean;
    showSaveForm: boolean;
    balanceList: SavedBalanceListDto[] | undefined;
    showBalanceDetails: boolean;
    viewBalanceDetail: ViewSavedBalanceDetailDto;
    savedBalanceForm: SaveBalanceFormDto;
}

export class BNR_BalanceListDto implements IBNR_BalanceListDto {
    id: number;
    balanceDate: moment.Moment;
    balanceDesc: string | undefined;
    tenantId: number;

    constructor(data?: IBNR_BalanceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.balanceDate = _data["balanceDate"] ? moment(_data["balanceDate"].toString()) : <any>undefined;
            this.balanceDesc = _data["balanceDesc"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BNR_BalanceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BNR_BalanceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        data["balanceDesc"] = this.balanceDesc;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): BNR_BalanceListDto {
        const json = this.toJSON();
        let result = new BNR_BalanceListDto();
        result.init(json);
        return result;
    }
}

export interface IBNR_BalanceListDto {
    id: number;
    balanceDate: moment.Moment;
    balanceDesc: string | undefined;
    tenantId: number;
}

export class LichidSavedBalanceListDto implements ILichidSavedBalanceListDto {
    id: number;
    savedBalanceDate: moment.Moment;
    savedBalanceDesc: string | undefined;
    tenantId: number;

    constructor(data?: ILichidSavedBalanceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.savedBalanceDate = _data["savedBalanceDate"] ? moment(_data["savedBalanceDate"].toString()) : <any>undefined;
            this.savedBalanceDesc = _data["savedBalanceDesc"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): LichidSavedBalanceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LichidSavedBalanceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["savedBalanceDate"] = this.savedBalanceDate ? this.savedBalanceDate.toISOString() : <any>undefined;
        data["savedBalanceDesc"] = this.savedBalanceDesc;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): LichidSavedBalanceListDto {
        const json = this.toJSON();
        let result = new LichidSavedBalanceListDto();
        result.init(json);
        return result;
    }
}

export interface ILichidSavedBalanceListDto {
    id: number;
    savedBalanceDate: moment.Moment;
    savedBalanceDesc: string | undefined;
    tenantId: number;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = this.features[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class SitFinanBalanceList implements ISitFinanBalanceList {
    id: number;
    balanceName: string | undefined;
    saveDate: moment.Moment;
    calcSitFinan: boolean;

    constructor(data?: ISitFinanBalanceList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.balanceName = _data["balanceName"];
            this.saveDate = _data["saveDate"] ? moment(_data["saveDate"].toString()) : <any>undefined;
            this.calcSitFinan = _data["calcSitFinan"];
        }
    }

    static fromJS(data: any): SitFinanBalanceList {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanBalanceList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["balanceName"] = this.balanceName;
        data["saveDate"] = this.saveDate ? this.saveDate.toISOString() : <any>undefined;
        data["calcSitFinan"] = this.calcSitFinan;
        return data;
    }

    clone(): SitFinanBalanceList {
        const json = this.toJSON();
        let result = new SitFinanBalanceList();
        result.init(json);
        return result;
    }
}

export interface ISitFinanBalanceList {
    id: number;
    balanceName: string | undefined;
    saveDate: moment.Moment;
    calcSitFinan: boolean;
}

export class SitFinanCalcForm implements ISitFinanCalcForm {
    isDailyBalance: boolean;
    startDate: moment.Moment;
    endDate: moment.Moment;
    balanceList: SitFinanBalanceList[] | undefined;

    constructor(data?: ISitFinanCalcForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDailyBalance = _data["isDailyBalance"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["balanceList"])) {
                this.balanceList = [] as any;
                for (let item of _data["balanceList"])
                    this.balanceList.push(SitFinanBalanceList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitFinanCalcForm {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanCalcForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDailyBalance"] = this.isDailyBalance;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.balanceList)) {
            data["balanceList"] = [];
            for (let item of this.balanceList)
                data["balanceList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SitFinanCalcForm {
        const json = this.toJSON();
        let result = new SitFinanCalcForm();
        result.init(json);
        return result;
    }
}

export interface ISitFinanCalcForm {
    isDailyBalance: boolean;
    startDate: moment.Moment;
    endDate: moment.Moment;
    balanceList: SitFinanBalanceList[] | undefined;
}

export class SitFinanCalcReportList implements ISitFinanCalcReportList {
    id: number;
    reportName: string | undefined;

    constructor(data?: ISitFinanCalcReportList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reportName = _data["reportName"];
        }
    }

    static fromJS(data: any): SitFinanCalcReportList {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanCalcReportList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reportName"] = this.reportName;
        return data;
    }

    clone(): SitFinanCalcReportList {
        const json = this.toJSON();
        let result = new SitFinanCalcReportList();
        result.init(json);
        return result;
    }
}

export interface ISitFinanCalcReportList {
    id: number;
    reportName: string | undefined;
}

export class SitFinanCalcReportDetList implements ISitFinanCalcReportDetList {
    calcRowId: number;
    rowId: number;
    rowName: string | undefined;
    rowNr: string | undefined;
    rowNota: string | undefined;
    orderView: number;
    totalRow: boolean;
    bold: boolean;
    negativeValue: boolean;
    val1: number | undefined;
    val2: number | undefined;
    val3: number | undefined;
    val4: number | undefined;
    val5: number | undefined;
    val6: number | undefined;

    constructor(data?: ISitFinanCalcReportDetList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calcRowId = _data["calcRowId"];
            this.rowId = _data["rowId"];
            this.rowName = _data["rowName"];
            this.rowNr = _data["rowNr"];
            this.rowNota = _data["rowNota"];
            this.orderView = _data["orderView"];
            this.totalRow = _data["totalRow"];
            this.bold = _data["bold"];
            this.negativeValue = _data["negativeValue"];
            this.val1 = _data["val1"];
            this.val2 = _data["val2"];
            this.val3 = _data["val3"];
            this.val4 = _data["val4"];
            this.val5 = _data["val5"];
            this.val6 = _data["val6"];
        }
    }

    static fromJS(data: any): SitFinanCalcReportDetList {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanCalcReportDetList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calcRowId"] = this.calcRowId;
        data["rowId"] = this.rowId;
        data["rowName"] = this.rowName;
        data["rowNr"] = this.rowNr;
        data["rowNota"] = this.rowNota;
        data["orderView"] = this.orderView;
        data["totalRow"] = this.totalRow;
        data["bold"] = this.bold;
        data["negativeValue"] = this.negativeValue;
        data["val1"] = this.val1;
        data["val2"] = this.val2;
        data["val3"] = this.val3;
        data["val4"] = this.val4;
        data["val5"] = this.val5;
        data["val6"] = this.val6;
        return data;
    }

    clone(): SitFinanCalcReportDetList {
        const json = this.toJSON();
        let result = new SitFinanCalcReportDetList();
        result.init(json);
        return result;
    }
}

export interface ISitFinanCalcReportDetList {
    calcRowId: number;
    rowId: number;
    rowName: string | undefined;
    rowNr: string | undefined;
    rowNota: string | undefined;
    orderView: number;
    totalRow: boolean;
    bold: boolean;
    negativeValue: boolean;
    val1: number | undefined;
    val2: number | undefined;
    val3: number | undefined;
    val4: number | undefined;
    val5: number | undefined;
    val6: number | undefined;
}

export class SitFinanCalcValDet implements ISitFinanCalcValDet {
    elementDet: string | undefined;
    val: number;

    constructor(data?: ISitFinanCalcValDet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.elementDet = _data["elementDet"];
            this.val = _data["val"];
        }
    }

    static fromJS(data: any): SitFinanCalcValDet {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanCalcValDet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elementDet"] = this.elementDet;
        data["val"] = this.val;
        return data;
    }

    clone(): SitFinanCalcValDet {
        const json = this.toJSON();
        let result = new SitFinanCalcValDet();
        result.init(json);
        return result;
    }
}

export interface ISitFinanCalcValDet {
    elementDet: string | undefined;
    val: number;
}

export class SitFinanCalcVal implements ISitFinanCalcVal {
    rowId: number;
    columnId: number;
    rowName: string | undefined;
    formula: string | undefined;
    formulaVal: string | undefined;
    detailValueList: SitFinanCalcValDet[] | undefined;

    constructor(data?: ISitFinanCalcVal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowId = _data["rowId"];
            this.columnId = _data["columnId"];
            this.rowName = _data["rowName"];
            this.formula = _data["formula"];
            this.formulaVal = _data["formulaVal"];
            if (Array.isArray(_data["detailValueList"])) {
                this.detailValueList = [] as any;
                for (let item of _data["detailValueList"])
                    this.detailValueList.push(SitFinanCalcValDet.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitFinanCalcVal {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanCalcVal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowId"] = this.rowId;
        data["columnId"] = this.columnId;
        data["rowName"] = this.rowName;
        data["formula"] = this.formula;
        data["formulaVal"] = this.formulaVal;
        if (Array.isArray(this.detailValueList)) {
            data["detailValueList"] = [];
            for (let item of this.detailValueList)
                data["detailValueList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SitFinanCalcVal {
        const json = this.toJSON();
        let result = new SitFinanCalcVal();
        result.init(json);
        return result;
    }
}

export interface ISitFinanCalcVal {
    rowId: number;
    columnId: number;
    rowName: string | undefined;
    formula: string | undefined;
    formulaVal: string | undefined;
    detailValueList: SitFinanCalcValDet[] | undefined;
}

export class SitFinanCalcDetNote implements ISitFinanCalcDetNote {
    id: number;
    beforeNote: string | undefined;
    afterNote: string | undefined;

    constructor(data?: ISitFinanCalcDetNote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.beforeNote = _data["beforeNote"];
            this.afterNote = _data["afterNote"];
        }
    }

    static fromJS(data: any): SitFinanCalcDetNote {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanCalcDetNote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["beforeNote"] = this.beforeNote;
        data["afterNote"] = this.afterNote;
        return data;
    }

    clone(): SitFinanCalcDetNote {
        const json = this.toJSON();
        let result = new SitFinanCalcDetNote();
        result.init(json);
        return result;
    }
}

export interface ISitFinanCalcDetNote {
    id: number;
    beforeNote: string | undefined;
    afterNote: string | undefined;
}

export class SitFinanCalcReportForm implements ISitFinanCalcReportForm {
    balanceId: number;
    saveDate: moment.Moment;
    balanceName: string | undefined;
    reportList: SitFinanCalcReportList[] | undefined;
    selReportId: number;
    selReportName: string | undefined;
    selReportNrCol: number;
    reportDetList: SitFinanCalcReportDetList[] | undefined;
    valueDetails: SitFinanCalcVal;
    detNote: SitFinanCalcDetNote;
    showReport: boolean;
    showValueDetail: boolean;
    showNota: boolean;

    constructor(data?: ISitFinanCalcReportForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.balanceId = _data["balanceId"];
            this.saveDate = _data["saveDate"] ? moment(_data["saveDate"].toString()) : <any>undefined;
            this.balanceName = _data["balanceName"];
            if (Array.isArray(_data["reportList"])) {
                this.reportList = [] as any;
                for (let item of _data["reportList"])
                    this.reportList.push(SitFinanCalcReportList.fromJS(item));
            }
            this.selReportId = _data["selReportId"];
            this.selReportName = _data["selReportName"];
            this.selReportNrCol = _data["selReportNrCol"];
            if (Array.isArray(_data["reportDetList"])) {
                this.reportDetList = [] as any;
                for (let item of _data["reportDetList"])
                    this.reportDetList.push(SitFinanCalcReportDetList.fromJS(item));
            }
            this.valueDetails = _data["valueDetails"] ? SitFinanCalcVal.fromJS(_data["valueDetails"]) : <any>undefined;
            this.detNote = _data["detNote"] ? SitFinanCalcDetNote.fromJS(_data["detNote"]) : <any>undefined;
            this.showReport = _data["showReport"];
            this.showValueDetail = _data["showValueDetail"];
            this.showNota = _data["showNota"];
        }
    }

    static fromJS(data: any): SitFinanCalcReportForm {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanCalcReportForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balanceId"] = this.balanceId;
        data["saveDate"] = this.saveDate ? this.saveDate.toISOString() : <any>undefined;
        data["balanceName"] = this.balanceName;
        if (Array.isArray(this.reportList)) {
            data["reportList"] = [];
            for (let item of this.reportList)
                data["reportList"].push(item.toJSON());
        }
        data["selReportId"] = this.selReportId;
        data["selReportName"] = this.selReportName;
        data["selReportNrCol"] = this.selReportNrCol;
        if (Array.isArray(this.reportDetList)) {
            data["reportDetList"] = [];
            for (let item of this.reportDetList)
                data["reportDetList"].push(item.toJSON());
        }
        data["valueDetails"] = this.valueDetails ? this.valueDetails.toJSON() : <any>undefined;
        data["detNote"] = this.detNote ? this.detNote.toJSON() : <any>undefined;
        data["showReport"] = this.showReport;
        data["showValueDetail"] = this.showValueDetail;
        data["showNota"] = this.showNota;
        return data;
    }

    clone(): SitFinanCalcReportForm {
        const json = this.toJSON();
        let result = new SitFinanCalcReportForm();
        result.init(json);
        return result;
    }
}

export interface ISitFinanCalcReportForm {
    balanceId: number;
    saveDate: moment.Moment;
    balanceName: string | undefined;
    reportList: SitFinanCalcReportList[] | undefined;
    selReportId: number;
    selReportName: string | undefined;
    selReportNrCol: number;
    reportDetList: SitFinanCalcReportDetList[] | undefined;
    valueDetails: SitFinanCalcVal;
    detNote: SitFinanCalcDetNote;
    showReport: boolean;
    showValueDetail: boolean;
    showNota: boolean;
}

export class SitFinanCalcDetail implements ISitFinanCalcDetail {
    rowId: number;
    rowName: string | undefined;
    elementDet: string | undefined;
    formula: string | undefined;
    valoare: number;
    orderView: number;

    constructor(data?: ISitFinanCalcDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowId = _data["rowId"];
            this.rowName = _data["rowName"];
            this.elementDet = _data["elementDet"];
            this.formula = _data["formula"];
            this.valoare = _data["valoare"];
            this.orderView = _data["orderView"];
        }
    }

    static fromJS(data: any): SitFinanCalcDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanCalcDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowId"] = this.rowId;
        data["rowName"] = this.rowName;
        data["elementDet"] = this.elementDet;
        data["formula"] = this.formula;
        data["valoare"] = this.valoare;
        data["orderView"] = this.orderView;
        return data;
    }

    clone(): SitFinanCalcDetail {
        const json = this.toJSON();
        let result = new SitFinanCalcDetail();
        result.init(json);
        return result;
    }
}

export interface ISitFinanCalcDetail {
    rowId: number;
    rowName: string | undefined;
    elementDet: string | undefined;
    formula: string | undefined;
    valoare: number;
    orderView: number;
}

export class SitFinanConfigDto implements ISitFinanConfigDto {
    id: number;
    rapDate: moment.Moment;
    copyReport: boolean;
    prevDateId: number | undefined;

    constructor(data?: ISitFinanConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rapDate = _data["rapDate"] ? moment(_data["rapDate"].toString()) : <any>undefined;
            this.copyReport = _data["copyReport"];
            this.prevDateId = _data["prevDateId"];
        }
    }

    static fromJS(data: any): SitFinanConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rapDate"] = this.rapDate ? this.rapDate.toISOString() : <any>undefined;
        data["copyReport"] = this.copyReport;
        data["prevDateId"] = this.prevDateId;
        return data;
    }

    clone(): SitFinanConfigDto {
        const json = this.toJSON();
        let result = new SitFinanConfigDto();
        result.init(json);
        return result;
    }
}

export interface ISitFinanConfigDto {
    id: number;
    rapDate: moment.Moment;
    copyReport: boolean;
    prevDateId: number | undefined;
}

export class SitFinanDto implements ISitFinanDto {
    id: number;
    rapDate: moment.Moment;

    constructor(data?: ISitFinanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rapDate = _data["rapDate"] ? moment(_data["rapDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SitFinanDto {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rapDate"] = this.rapDate ? this.rapDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): SitFinanDto {
        const json = this.toJSON();
        let result = new SitFinanDto();
        result.init(json);
        return result;
    }
}

export interface ISitFinanDto {
    id: number;
    rapDate: moment.Moment;
}

export class SitFinanForm implements ISitFinanForm {
    sitFinan: SitFinanConfigDto;
    sitFinanList: SitFinanDto[] | undefined;
    showList: boolean;
    showEdit: boolean;

    constructor(data?: ISitFinanForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sitFinan = _data["sitFinan"] ? SitFinanConfigDto.fromJS(_data["sitFinan"]) : <any>undefined;
            if (Array.isArray(_data["sitFinanList"])) {
                this.sitFinanList = [] as any;
                for (let item of _data["sitFinanList"])
                    this.sitFinanList.push(SitFinanDto.fromJS(item));
            }
            this.showList = _data["showList"];
            this.showEdit = _data["showEdit"];
        }
    }

    static fromJS(data: any): SitFinanForm {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sitFinan"] = this.sitFinan ? this.sitFinan.toJSON() : <any>undefined;
        if (Array.isArray(this.sitFinanList)) {
            data["sitFinanList"] = [];
            for (let item of this.sitFinanList)
                data["sitFinanList"].push(item.toJSON());
        }
        data["showList"] = this.showList;
        data["showEdit"] = this.showEdit;
        return data;
    }

    clone(): SitFinanForm {
        const json = this.toJSON();
        let result = new SitFinanForm();
        result.init(json);
        return result;
    }
}

export interface ISitFinanForm {
    sitFinan: SitFinanConfigDto;
    sitFinanList: SitFinanDto[] | undefined;
    showList: boolean;
    showEdit: boolean;
}

export enum SitFinanFluxRowType {
    _0 = 0,
    _1 = 1,
}

export class SitFinanRapFluxConfigDto implements ISitFinanRapFluxConfigDto {
    id: number;
    sitFinanRapId: number;
    debit: string | undefined;
    credit: string | undefined;
    sitFinanFluxRowType: SitFinanFluxRowType;
    tenantId: number;

    constructor(data?: ISitFinanRapFluxConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sitFinanRapId = _data["sitFinanRapId"];
            this.debit = _data["debit"];
            this.credit = _data["credit"];
            this.sitFinanFluxRowType = _data["sitFinanFluxRowType"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): SitFinanRapFluxConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanRapFluxConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sitFinanRapId"] = this.sitFinanRapId;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["sitFinanFluxRowType"] = this.sitFinanFluxRowType;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): SitFinanRapFluxConfigDto {
        const json = this.toJSON();
        let result = new SitFinanRapFluxConfigDto();
        result.init(json);
        return result;
    }
}

export interface ISitFinanRapFluxConfigDto {
    id: number;
    sitFinanRapId: number;
    debit: string | undefined;
    credit: string | undefined;
    sitFinanFluxRowType: SitFinanFluxRowType;
    tenantId: number;
}

export class SitFinanDDDto implements ISitFinanDDDto {
    id: number;
    rapDate: string | undefined;

    constructor(data?: ISitFinanDDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rapDate = _data["rapDate"];
        }
    }

    static fromJS(data: any): SitFinanDDDto {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanDDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rapDate"] = this.rapDate;
        return data;
    }

    clone(): SitFinanDDDto {
        const json = this.toJSON();
        let result = new SitFinanDDDto();
        result.init(json);
        return result;
    }
}

export interface ISitFinanDDDto {
    id: number;
    rapDate: string | undefined;
}

export enum SitFinanRowModCalc {
    _0 = 0,
    _1 = 1,
}

export class SitFinanRapDto implements ISitFinanRapDto {
    id: number;
    reportName: string | undefined;
    reportSymbol: string | undefined;
    orderView: number;
    nrCol: number;
    perioadaEchivalenta: boolean;
    sitFinanId: number;
    sitFinanRowModCalc: SitFinanRowModCalc;

    constructor(data?: ISitFinanRapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reportName = _data["reportName"];
            this.reportSymbol = _data["reportSymbol"];
            this.orderView = _data["orderView"];
            this.nrCol = _data["nrCol"];
            this.perioadaEchivalenta = _data["perioadaEchivalenta"];
            this.sitFinanId = _data["sitFinanId"];
            this.sitFinanRowModCalc = _data["sitFinanRowModCalc"];
        }
    }

    static fromJS(data: any): SitFinanRapDto {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanRapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reportName"] = this.reportName;
        data["reportSymbol"] = this.reportSymbol;
        data["orderView"] = this.orderView;
        data["nrCol"] = this.nrCol;
        data["perioadaEchivalenta"] = this.perioadaEchivalenta;
        data["sitFinanId"] = this.sitFinanId;
        data["sitFinanRowModCalc"] = this.sitFinanRowModCalc;
        return data;
    }

    clone(): SitFinanRapDto {
        const json = this.toJSON();
        let result = new SitFinanRapDto();
        result.init(json);
        return result;
    }
}

export interface ISitFinanRapDto {
    id: number;
    reportName: string | undefined;
    reportSymbol: string | undefined;
    orderView: number;
    nrCol: number;
    perioadaEchivalenta: boolean;
    sitFinanId: number;
    sitFinanRowModCalc: SitFinanRowModCalc;
}

export class SitFinanReportForm implements ISitFinanReportForm {
    sitFinanId: number;
    sitFinanDate: moment.Moment;
    sitFinanRapList: SitFinanRapDto[] | undefined;

    constructor(data?: ISitFinanReportForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sitFinanId = _data["sitFinanId"];
            this.sitFinanDate = _data["sitFinanDate"] ? moment(_data["sitFinanDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["sitFinanRapList"])) {
                this.sitFinanRapList = [] as any;
                for (let item of _data["sitFinanRapList"])
                    this.sitFinanRapList.push(SitFinanRapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitFinanReportForm {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanReportForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sitFinanId"] = this.sitFinanId;
        data["sitFinanDate"] = this.sitFinanDate ? this.sitFinanDate.toISOString() : <any>undefined;
        if (Array.isArray(this.sitFinanRapList)) {
            data["sitFinanRapList"] = [];
            for (let item of this.sitFinanRapList)
                data["sitFinanRapList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SitFinanReportForm {
        const json = this.toJSON();
        let result = new SitFinanReportForm();
        result.init(json);
        return result;
    }
}

export interface ISitFinanReportForm {
    sitFinanId: number;
    sitFinanDate: moment.Moment;
    sitFinanRapList: SitFinanRapDto[] | undefined;
}

export class SitFinanRapConfigColDto implements ISitFinanRapConfigColDto {
    id: number;
    columnNr: number;
    columnName: string | undefined;
    columnModCalc: number | undefined;

    constructor(data?: ISitFinanRapConfigColDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.columnNr = _data["columnNr"];
            this.columnName = _data["columnName"];
            this.columnModCalc = _data["columnModCalc"];
        }
    }

    static fromJS(data: any): SitFinanRapConfigColDto {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanRapConfigColDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["columnNr"] = this.columnNr;
        data["columnName"] = this.columnName;
        data["columnModCalc"] = this.columnModCalc;
        return data;
    }

    clone(): SitFinanRapConfigColDto {
        const json = this.toJSON();
        let result = new SitFinanRapConfigColDto();
        result.init(json);
        return result;
    }
}

export interface ISitFinanRapConfigColDto {
    id: number;
    columnNr: number;
    columnName: string | undefined;
    columnModCalc: number | undefined;
}

export class SitFinanRapConfigDto implements ISitFinanRapConfigDto {
    id: number;
    rowName: string | undefined;
    rowCode: number;
    rowNr: string | undefined;
    rowNota: string | undefined;
    orderView: number;
    col1: string | undefined;
    col2: string | undefined;
    col3: string | undefined;
    col4: string | undefined;
    col5: string | undefined;
    col6: string | undefined;
    totalRow: boolean;
    bold: boolean;
    negativeValue: boolean;
    decimalNr: number;
    sitFinanRowModCalc: SitFinanRowModCalc;

    constructor(data?: ISitFinanRapConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rowName = _data["rowName"];
            this.rowCode = _data["rowCode"];
            this.rowNr = _data["rowNr"];
            this.rowNota = _data["rowNota"];
            this.orderView = _data["orderView"];
            this.col1 = _data["col1"];
            this.col2 = _data["col2"];
            this.col3 = _data["col3"];
            this.col4 = _data["col4"];
            this.col5 = _data["col5"];
            this.col6 = _data["col6"];
            this.totalRow = _data["totalRow"];
            this.bold = _data["bold"];
            this.negativeValue = _data["negativeValue"];
            this.decimalNr = _data["decimalNr"];
            this.sitFinanRowModCalc = _data["sitFinanRowModCalc"];
        }
    }

    static fromJS(data: any): SitFinanRapConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanRapConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rowName"] = this.rowName;
        data["rowCode"] = this.rowCode;
        data["rowNr"] = this.rowNr;
        data["rowNota"] = this.rowNota;
        data["orderView"] = this.orderView;
        data["col1"] = this.col1;
        data["col2"] = this.col2;
        data["col3"] = this.col3;
        data["col4"] = this.col4;
        data["col5"] = this.col5;
        data["col6"] = this.col6;
        data["totalRow"] = this.totalRow;
        data["bold"] = this.bold;
        data["negativeValue"] = this.negativeValue;
        data["decimalNr"] = this.decimalNr;
        data["sitFinanRowModCalc"] = this.sitFinanRowModCalc;
        return data;
    }

    clone(): SitFinanRapConfigDto {
        const json = this.toJSON();
        let result = new SitFinanRapConfigDto();
        result.init(json);
        return result;
    }
}

export interface ISitFinanRapConfigDto {
    id: number;
    rowName: string | undefined;
    rowCode: number;
    rowNr: string | undefined;
    rowNota: string | undefined;
    orderView: number;
    col1: string | undefined;
    col2: string | undefined;
    col3: string | undefined;
    col4: string | undefined;
    col5: string | undefined;
    col6: string | undefined;
    totalRow: boolean;
    bold: boolean;
    negativeValue: boolean;
    decimalNr: number;
    sitFinanRowModCalc: SitFinanRowModCalc;
}

export class SitFinanFormuleForm implements ISitFinanFormuleForm {
    sitFinanId: number;
    reportId: number;
    reportName: string | undefined;
    nrCol: number;
    reportSymbol: string | undefined;
    configColList: SitFinanRapConfigColDto[] | undefined;
    configFormulaList: SitFinanRapConfigDto[] | undefined;

    constructor(data?: ISitFinanFormuleForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sitFinanId = _data["sitFinanId"];
            this.reportId = _data["reportId"];
            this.reportName = _data["reportName"];
            this.nrCol = _data["nrCol"];
            this.reportSymbol = _data["reportSymbol"];
            if (Array.isArray(_data["configColList"])) {
                this.configColList = [] as any;
                for (let item of _data["configColList"])
                    this.configColList.push(SitFinanRapConfigColDto.fromJS(item));
            }
            if (Array.isArray(_data["configFormulaList"])) {
                this.configFormulaList = [] as any;
                for (let item of _data["configFormulaList"])
                    this.configFormulaList.push(SitFinanRapConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitFinanFormuleForm {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanFormuleForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sitFinanId"] = this.sitFinanId;
        data["reportId"] = this.reportId;
        data["reportName"] = this.reportName;
        data["nrCol"] = this.nrCol;
        data["reportSymbol"] = this.reportSymbol;
        if (Array.isArray(this.configColList)) {
            data["configColList"] = [];
            for (let item of this.configColList)
                data["configColList"].push(item.toJSON());
        }
        if (Array.isArray(this.configFormulaList)) {
            data["configFormulaList"] = [];
            for (let item of this.configFormulaList)
                data["configFormulaList"].push(item.toJSON());
        }
        return data;
    }

    clone(): SitFinanFormuleForm {
        const json = this.toJSON();
        let result = new SitFinanFormuleForm();
        result.init(json);
        return result;
    }
}

export interface ISitFinanFormuleForm {
    sitFinanId: number;
    reportId: number;
    reportName: string | undefined;
    nrCol: number;
    reportSymbol: string | undefined;
    configColList: SitFinanRapConfigColDto[] | undefined;
    configFormulaList: SitFinanRapConfigDto[] | undefined;
}

export class SitFinanRapConfigNoteDto implements ISitFinanRapConfigNoteDto {
    sitFinanId: number;
    reportId: number;
    reportName: string | undefined;
    reportSymbol: string | undefined;
    id: number;
    beforeNote: string | undefined;
    afterNote: string | undefined;

    constructor(data?: ISitFinanRapConfigNoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sitFinanId = _data["sitFinanId"];
            this.reportId = _data["reportId"];
            this.reportName = _data["reportName"];
            this.reportSymbol = _data["reportSymbol"];
            this.id = _data["id"];
            this.beforeNote = _data["beforeNote"];
            this.afterNote = _data["afterNote"];
        }
    }

    static fromJS(data: any): SitFinanRapConfigNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanRapConfigNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sitFinanId"] = this.sitFinanId;
        data["reportId"] = this.reportId;
        data["reportName"] = this.reportName;
        data["reportSymbol"] = this.reportSymbol;
        data["id"] = this.id;
        data["beforeNote"] = this.beforeNote;
        data["afterNote"] = this.afterNote;
        return data;
    }

    clone(): SitFinanRapConfigNoteDto {
        const json = this.toJSON();
        let result = new SitFinanRapConfigNoteDto();
        result.init(json);
        return result;
    }
}

export interface ISitFinanRapConfigNoteDto {
    sitFinanId: number;
    reportId: number;
    reportName: string | undefined;
    reportSymbol: string | undefined;
    id: number;
    beforeNote: string | undefined;
    afterNote: string | undefined;
}

export class SitFinanCalcBalanceListDto implements ISitFinanCalcBalanceListDto {
    savedBalanceId: number;
    calcDate: moment.Moment;
    calcDateStr: string | undefined;

    constructor(data?: ISitFinanCalcBalanceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.savedBalanceId = _data["savedBalanceId"];
            this.calcDate = _data["calcDate"] ? moment(_data["calcDate"].toString()) : <any>undefined;
            this.calcDateStr = _data["calcDateStr"];
        }
    }

    static fromJS(data: any): SitFinanCalcBalanceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanCalcBalanceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["savedBalanceId"] = this.savedBalanceId;
        data["calcDate"] = this.calcDate ? this.calcDate.toISOString() : <any>undefined;
        data["calcDateStr"] = this.calcDateStr;
        return data;
    }

    clone(): SitFinanCalcBalanceListDto {
        const json = this.toJSON();
        let result = new SitFinanCalcBalanceListDto();
        result.init(json);
        return result;
    }
}

export interface ISitFinanCalcBalanceListDto {
    savedBalanceId: number;
    calcDate: moment.Moment;
    calcDateStr: string | undefined;
}

export class SitFinanCalcRapListDto implements ISitFinanCalcRapListDto {
    raportId: number;
    isDailyBalance: boolean;
    isDateRange: boolean;
    colNumber: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    raportName: string | undefined;
    orderView: number;

    constructor(data?: ISitFinanCalcRapListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.raportId = _data["raportId"];
            this.isDailyBalance = _data["isDailyBalance"];
            this.isDateRange = _data["isDateRange"];
            this.colNumber = _data["colNumber"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.raportName = _data["raportName"];
            this.orderView = _data["orderView"];
        }
    }

    static fromJS(data: any): SitFinanCalcRapListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanCalcRapListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["raportId"] = this.raportId;
        data["isDailyBalance"] = this.isDailyBalance;
        data["isDateRange"] = this.isDateRange;
        data["colNumber"] = this.colNumber;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["raportName"] = this.raportName;
        data["orderView"] = this.orderView;
        return data;
    }

    clone(): SitFinanCalcRapListDto {
        const json = this.toJSON();
        let result = new SitFinanCalcRapListDto();
        result.init(json);
        return result;
    }
}

export interface ISitFinanCalcRapListDto {
    raportId: number;
    isDailyBalance: boolean;
    isDateRange: boolean;
    colNumber: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    raportName: string | undefined;
    orderView: number;
}

export class SitFinanReportColumn implements ISitFinanReportColumn {
    id: number;
    columnName: string | undefined;
    columnNr: number;

    constructor(data?: ISitFinanReportColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.columnName = _data["columnName"];
            this.columnNr = _data["columnNr"];
        }
    }

    static fromJS(data: any): SitFinanReportColumn {
        data = typeof data === 'object' ? data : {};
        let result = new SitFinanReportColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["columnName"] = this.columnName;
        data["columnNr"] = this.columnNr;
        return data;
    }

    clone(): SitFinanReportColumn {
        const json = this.toJSON();
        let result = new SitFinanReportColumn();
        result.init(json);
        return result;
    }
}

export interface ISitFinanReportColumn {
    id: number;
    columnName: string | undefined;
    columnNr: number;
}

export class SoldInitialDto implements ISoldInitialDto {
    id: number;
    dispositionDate: moment.Moment;
    value: number;
    sumOper: number;
    currencyName: string | undefined;

    constructor(data?: ISoldInitialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dispositionDate = _data["dispositionDate"] ? moment(_data["dispositionDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.sumOper = _data["sumOper"];
            this.currencyName = _data["currencyName"];
        }
    }

    static fromJS(data: any): SoldInitialDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoldInitialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dispositionDate"] = this.dispositionDate ? this.dispositionDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["sumOper"] = this.sumOper;
        data["currencyName"] = this.currencyName;
        return data;
    }

    clone(): SoldInitialDto {
        const json = this.toJSON();
        let result = new SoldInitialDto();
        result.init(json);
        return result;
    }
}

export interface ISoldInitialDto {
    id: number;
    dispositionDate: moment.Moment;
    value: number;
    sumOper: number;
    currencyName: string | undefined;
}

export class SoldInitialEditDto implements ISoldInitialEditDto {
    id: number;
    operationType: string | undefined;
    dispositionDate: moment.Moment;
    value: number;
    sumOper: number;
    currencyId: number;
    tenantId: number;

    constructor(data?: ISoldInitialEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationType = _data["operationType"];
            this.dispositionDate = _data["dispositionDate"] ? moment(_data["dispositionDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.sumOper = _data["sumOper"];
            this.currencyId = _data["currencyId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): SoldInitialEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoldInitialEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationType"] = this.operationType;
        data["dispositionDate"] = this.dispositionDate ? this.dispositionDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["sumOper"] = this.sumOper;
        data["currencyId"] = this.currencyId;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): SoldInitialEditDto {
        const json = this.toJSON();
        let result = new SoldInitialEditDto();
        result.init(json);
        return result;
    }
}

export interface ISoldInitialEditDto {
    id: number;
    operationType: string | undefined;
    dispositionDate: moment.Moment;
    value: number;
    sumOper: number;
    currencyId: number;
    tenantId: number;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class TragereDto implements ITragereDto {
    id: number;
    tipTragere: TipTragere;
    tipTragereString: string | undefined;
    dataTragere: moment.Moment;
    sumaDisponibila: number;
    sumaTrasa: number;
    dobanda: number;
    sumaImprumutata: number;
    comision: number;
    comisionSum: number;
    currencyId: number;
    currencyS: string | undefined;
    state: State;
    imprumutId: number | undefined;
    tenantId: number;
    comisions: DataComisionDto[] | undefined;

    constructor(data?: ITragereDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tipTragere = _data["tipTragere"];
            this.tipTragereString = _data["tipTragereString"];
            this.dataTragere = _data["dataTragere"] ? moment(_data["dataTragere"].toString()) : <any>undefined;
            this.sumaDisponibila = _data["sumaDisponibila"];
            this.sumaTrasa = _data["sumaTrasa"];
            this.dobanda = _data["dobanda"];
            this.sumaImprumutata = _data["sumaImprumutata"];
            this.comision = _data["comision"];
            this.comisionSum = _data["comisionSum"];
            this.currencyId = _data["currencyId"];
            this.currencyS = _data["currencyS"];
            this.state = _data["state"];
            this.imprumutId = _data["imprumutId"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["comisions"])) {
                this.comisions = [] as any;
                for (let item of _data["comisions"])
                    this.comisions.push(DataComisionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TragereDto {
        data = typeof data === 'object' ? data : {};
        let result = new TragereDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tipTragere"] = this.tipTragere;
        data["tipTragereString"] = this.tipTragereString;
        data["dataTragere"] = this.dataTragere ? this.dataTragere.toISOString() : <any>undefined;
        data["sumaDisponibila"] = this.sumaDisponibila;
        data["sumaTrasa"] = this.sumaTrasa;
        data["dobanda"] = this.dobanda;
        data["sumaImprumutata"] = this.sumaImprumutata;
        data["comision"] = this.comision;
        data["comisionSum"] = this.comisionSum;
        data["currencyId"] = this.currencyId;
        data["currencyS"] = this.currencyS;
        data["state"] = this.state;
        data["imprumutId"] = this.imprumutId;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.comisions)) {
            data["comisions"] = [];
            for (let item of this.comisions)
                data["comisions"].push(item.toJSON());
        }
        return data;
    }

    clone(): TragereDto {
        const json = this.toJSON();
        let result = new TragereDto();
        result.init(json);
        return result;
    }
}

export interface ITragereDto {
    id: number;
    tipTragere: TipTragere;
    tipTragereString: string | undefined;
    dataTragere: moment.Moment;
    sumaDisponibila: number;
    sumaTrasa: number;
    dobanda: number;
    sumaImprumutata: number;
    comision: number;
    comisionSum: number;
    currencyId: number;
    currencyS: string | undefined;
    state: State;
    imprumutId: number | undefined;
    tenantId: number;
    comisions: DataComisionDto[] | undefined;
}

export class DataTragereDto implements IDataTragereDto {
    id: number;
    dataTragere: moment.Moment;

    constructor(data?: IDataTragereDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataTragere = _data["dataTragere"] ? moment(_data["dataTragere"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DataTragereDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataTragereDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataTragere"] = this.dataTragere ? this.dataTragere.toISOString() : <any>undefined;
        return data;
    }

    clone(): DataTragereDto {
        const json = this.toJSON();
        let result = new DataTragereDto();
        result.init(json);
        return result;
    }
}

export interface IDataTragereDto {
    id: number;
    dataTragere: moment.Moment;
}

export class TranzactiiFonduriDto implements ITranzactiiFonduriDto {
    numar: number;
    data: moment.Moment;
    debit: string | undefined;
    credit: string | undefined;
    suma: number;
    fel_doc: string | undefined;
    nr_doc: string | undefined;
    data_doc: moment.Moment;
    explicatie: string | undefined;
    tip: string | undefined;
    nota: string | undefined;

    constructor(data?: ITranzactiiFonduriDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numar = _data["numar"];
            this.data = _data["data"] ? moment(_data["data"].toString()) : <any>undefined;
            this.debit = _data["debit"];
            this.credit = _data["credit"];
            this.suma = _data["suma"];
            this.fel_doc = _data["fel_doc"];
            this.nr_doc = _data["nr_doc"];
            this.data_doc = _data["data_doc"] ? moment(_data["data_doc"].toString()) : <any>undefined;
            this.explicatie = _data["explicatie"];
            this.tip = _data["tip"];
            this.nota = _data["nota"];
        }
    }

    static fromJS(data: any): TranzactiiFonduriDto {
        data = typeof data === 'object' ? data : {};
        let result = new TranzactiiFonduriDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numar"] = this.numar;
        data["data"] = this.data ? this.data.toISOString() : <any>undefined;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["suma"] = this.suma;
        data["fel_doc"] = this.fel_doc;
        data["nr_doc"] = this.nr_doc;
        data["data_doc"] = this.data_doc ? this.data_doc.toISOString() : <any>undefined;
        data["explicatie"] = this.explicatie;
        data["tip"] = this.tip;
        data["nota"] = this.nota;
        return data;
    }

    clone(): TranzactiiFonduriDto {
        const json = this.toJSON();
        let result = new TranzactiiFonduriDto();
        result.init(json);
        return result;
    }
}

export interface ITranzactiiFonduriDto {
    numar: number;
    data: moment.Moment;
    debit: string | undefined;
    credit: string | undefined;
    suma: number;
    fel_doc: string | undefined;
    nr_doc: string | undefined;
    data_doc: moment.Moment;
    explicatie: string | undefined;
    tip: string | undefined;
    nota: string | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}